From 653d7a4e594d7cd99f2a47354ab209ce4f7c65e3 Mon Sep 17 00:00:00 2001
From: Antony Pavlov <antonynpavlov@gmail.com>
Date: Thu, 26 Jan 2012 20:29:47 +0400
Subject: [PATCH 1/5] MIPS: add Ingenic JZ4750D support

This commit is based on ftp://ftp.ingenic.cn/3sw/01linux/02kernel/linux-2.6.31/linux-2.6.31.3-jz-20110719-tag-r1198.patch.tar.bz2

Signed-off-by: Antony Pavlov <antonynpavlov@gmail.com>
---
 Makefile                                           |    4 +-
 arch/mips/Kconfig                                  |   37 +-
 arch/mips/Makefile                                 |    8 +
 arch/mips/include/asm/bootinfo.h                   |    8 +-
 arch/mips/include/asm/break.h                      |    2 +
 arch/mips/include/asm/cacheflush.h                 |   30 +
 arch/mips/include/asm/cacheops.h                   |    1 +
 arch/mips/include/asm/cpu.h                        |   13 +-
 arch/mips/include/asm/inst.h                       |   15 +-
 arch/mips/include/asm/jzpm/jz_act8930.h            |  151 +
 arch/mips/include/asm/jzpm/jz_axp192.h             |   81 +
 arch/mips/include/asm/jzpm/jz_wm831x.h             |  118 +
 arch/mips/include/asm/jzsoc.h                      |   55 +
 arch/mips/include/asm/mach-generic/irq.h           |    2 +-
 arch/mips/include/asm/mach-jz4750d/board-cetus.h   |  279 ++
 arch/mips/include/asm/mach-jz4750d/clock.h         |  230 ++
 arch/mips/include/asm/mach-jz4750d/dma.h           |  307 ++
 arch/mips/include/asm/mach-jz4750d/i2c.h           |   70 +
 arch/mips/include/asm/mach-jz4750d/jz4750d.h       |   44 +
 arch/mips/include/asm/mach-jz4750d/misc.h          |   44 +
 arch/mips/include/asm/mach-jz4750d/ops.h           | 3452 +++++++++++++++++++
 arch/mips/include/asm/mach-jz4750d/platform.h      |   32 +
 arch/mips/include/asm/mach-jz4750d/regs.h          | 3458 ++++++++++++++++++++
 arch/mips/include/asm/mach-jz4750d/serial.h        |   30 +
 arch/mips/include/asm/mach-jz4750d/spi.h           |   72 +
 arch/mips/include/asm/mach-jz4750d/war.h           |   25 +
 arch/mips/include/asm/ptrace.h                     |    4 +
 arch/mips/include/asm/r4kcache.h                   |  239 ++
 arch/mips/include/asm/stackframe.h                 |   25 +
 arch/mips/jz4750d/Makefile                         |   22 +
 arch/mips/jz4750d/board-cetus.c                    |  252 ++
 arch/mips/jz4750d/cpufreq.c                        |  598 ++++
 arch/mips/jz4750d/dma.c                            |  822 +++++
 arch/mips/jz4750d/i2c.c                            |  388 +++
 arch/mips/jz4750d/irq.c                            |  299 ++
 arch/mips/jz4750d/platform.c                       |  348 ++
 arch/mips/jz4750d/pm.c                             |  384 +++
 arch/mips/jz4750d/proc.c                           |  831 +++++
 arch/mips/jz4750d/prom.c                           |  198 ++
 arch/mips/jz4750d/reset.c                          |   42 +
 arch/mips/jz4750d/setup.c                          |  161 +
 arch/mips/jz4750d/time.c                           |  214 ++
 arch/mips/kernel/cpu-probe.c                       |   27 +-
 arch/mips/kernel/cpufreq/Kconfig                   |    9 +
 arch/mips/kernel/entry.S                           |   15 +-
 arch/mips/kernel/irq.c                             |    7 +
 arch/mips/kernel/traps.c                           |    6 +-
 arch/mips/mm/c-r4k.c                               |   50 +-
 arch/mips/mm/cache.c                               |    2 +
 arch/mips/mm/tlbex.c                               |    5 +
 drivers/char/Kconfig                               |    9 +
 drivers/char/Makefile                              |    3 +
 drivers/char/jzchar/Kconfig                        |   24 +
 drivers/char/jzchar/Makefile                       |    9 +
 drivers/char/jzchar/example/i_i2c_tool.c           |   81 +
 drivers/char/jzchar/i_i2c.c                        |  190 ++
 drivers/char/jzchar/i_i2c_abi.h                    |   33 +
 drivers/char/jzchar/jz_ow.c                        |  497 +++
 drivers/char/jzchar/jzchars.c                      |  168 +
 drivers/char/jzchar/jzchars.h                      |   47 +
 drivers/char/jzchar/tcsm.c                         |  123 +
 drivers/char/rtc_jz.c                              |  619 ++++
 drivers/char/rtc_jz.h                              |   74 +
 drivers/gpio/Kconfig                               |    2 +-
 drivers/mmc/card/block.c                           |   18 +
 drivers/mmc/core/core.c                            |    6 +-
 drivers/mmc/core/mmc.c                             |   18 +-
 drivers/mmc/core/sd.c                              |   22 +-
 drivers/mmc/host/Kconfig                           |  113 +
 drivers/mmc/host/Makefile                          |    2 +
 drivers/mmc/host/jzmmc/Makefile                    |   10 +
 drivers/mmc/host/jzmmc/include/jz_mmc_controller.h |   42 +
 drivers/mmc/host/jzmmc/include/jz_mmc_dma.h        |   31 +
 drivers/mmc/host/jzmmc/include/jz_mmc_gpio.h       |   33 +
 drivers/mmc/host/jzmmc/include/jz_mmc_host.h       |  110 +
 drivers/mmc/host/jzmmc/include/jz_mmc_msc.h        |   32 +
 drivers/mmc/host/jzmmc/include/jz_mmc_pio.h        |    7 +
 drivers/mmc/host/jzmmc/jz_mmc_controller.c         |   91 +
 drivers/mmc/host/jzmmc/jz_mmc_dma.c                |  550 ++++
 drivers/mmc/host/jzmmc/jz_mmc_gpio.c               |  213 ++
 drivers/mmc/host/jzmmc/jz_mmc_main.c               |  522 +++
 drivers/mmc/host/jzmmc/jz_mmc_msc.c                |  823 +++++
 drivers/mmc/host/jzmmc/jz_mmc_pio.c                |  100 +
 drivers/serial/8250.c                              |  103 +
 drivers/usb/Kconfig                                |    1 +
 drivers/usb/core/hub.c                             |   31 +
 drivers/usb/gadget/Kconfig                         |   17 +
 drivers/usb/gadget/Makefile                        |    1 +
 drivers/usb/gadget/epautoconf.c                    |    1 +
 drivers/usb/gadget/file_storage.c                  |    4 +-
 drivers/usb/gadget/gadget_chips.h                  |    9 +
 drivers/usb/gadget/jz4740_udc.c                    | 2364 +++++++++++++
 drivers/usb/gadget/jz4740_udc.h                    |  105 +
 drivers/usb/gadget/udc_hotplug.c                   |  762 +++++
 drivers/video/Kconfig                              |  100 +
 drivers/video/Makefile                             |    5 +
 drivers/video/console/Kconfig                      |    8 +
 drivers/video/console/fbcon.c                      |    2 +
 drivers/video/jz4750_lcd.c                         | 2295 +++++++++++++
 drivers/video/jz4750_lcd.h                         |  269 ++
 drivers/video/jz4750_tve.c                         |  104 +
 drivers/video/jz4750_tve.h                         |   45 +
 drivers/video/jz475x/Makefile                      |    1 +
 drivers/video/jz475x/abi.h                         |  114 +
 drivers/video/jz475x/common.c                      |   33 +
 drivers/video/jz475x/config.h                      |  104 +
 drivers/video/jz475x/core/desc.c                   |  346 ++
 drivers/video/jz475x/core/framebuffer.c            |  356 ++
 drivers/video/jz475x/core/hw.c                     |  632 ++++
 drivers/video/jz475x/core/ot.c                     |  167 +
 drivers/video/jz475x/core/win.c                    |  179 +
 drivers/video/jz475x/drv/ctrl-drv.c                |  122 +
 drivers/video/jz475x/drv/fb-drv.c                  |  303 ++
 drivers/video/jz475x/jz-fb.c                       |  305 ++
 drivers/video/jz475x/jz-fb.h                       |  237 ++
 drivers/video/jz475x/output/config.c               |   75 +
 drivers/video/jz475x/output/control.c              |  100 +
 drivers/video/jz475x/output/lcd/auo-a043fl01v2.c   |  161 +
 drivers/video/jz475x/output/lcd/lcd-control.c      |   73 +
 drivers/video/jz475x/output/lcd/lcd-output.c       |  193 ++
 drivers/video/jz475x/output/output.c               |   38 +
 drivers/video/jz475x/output/tve/tve-common.c       |  169 +
 drivers/video/jz475x/output/tve/tve-control.c      |   64 +
 drivers/video/jz475x/output/tve/tve-hw.c           |  272 ++
 drivers/video/jz475x/output/tve/tve-ntsc-output.c  |   99 +
 drivers/video/jz475x/output/tve/tve-pal-output.c   |   98 +
 drivers/video/jz475x/test/Makefile                 |   23 +
 drivers/video/jz475x/test/fb_common.c              |   88 +
 drivers/video/jz475x/test/fb_fill.c                |   76 +
 drivers/video/jz475x/test/fb_h_colorbar.c          |  138 +
 drivers/video/jz475x/test/fb_info.c                |  126 +
 drivers/video/jz475x/test/fb_v_colorbar.c          |  163 +
 drivers/video/jz475x/test/lcd_ot_ctrl.c            |  167 +
 drivers/video/jz475x/test/tve_ntsc_ot_ctrl.c       |  189 ++
 drivers/video/jz475x/test/tve_pal_ot_ctrl.c        |  189 ++
 drivers/video/jz475x/userspace-config.h            |   22 +
 fs/mpage.c                                         |   11 +
 include/linux/vt.h                                 |    6 +
 init/do_mounts.c                                   |    3 +-
 139 files changed, 29777 insertions(+), 29 deletions(-)
 create mode 100644 arch/mips/include/asm/jzpm/jz_act8930.h
 create mode 100644 arch/mips/include/asm/jzpm/jz_axp192.h
 create mode 100644 arch/mips/include/asm/jzpm/jz_wm831x.h
 create mode 100644 arch/mips/include/asm/jzsoc.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/board-cetus.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/clock.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/dma.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/i2c.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/jz4750d.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/misc.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/ops.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/platform.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/regs.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/serial.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/spi.h
 create mode 100644 arch/mips/include/asm/mach-jz4750d/war.h
 create mode 100644 arch/mips/jz4750d/Makefile
 create mode 100644 arch/mips/jz4750d/board-cetus.c
 create mode 100644 arch/mips/jz4750d/cpufreq.c
 create mode 100644 arch/mips/jz4750d/dma.c
 create mode 100644 arch/mips/jz4750d/i2c.c
 create mode 100644 arch/mips/jz4750d/irq.c
 create mode 100644 arch/mips/jz4750d/platform.c
 create mode 100644 arch/mips/jz4750d/pm.c
 create mode 100644 arch/mips/jz4750d/proc.c
 create mode 100644 arch/mips/jz4750d/prom.c
 create mode 100644 arch/mips/jz4750d/reset.c
 create mode 100644 arch/mips/jz4750d/setup.c
 create mode 100644 arch/mips/jz4750d/time.c
 create mode 100644 drivers/char/jzchar/Kconfig
 create mode 100644 drivers/char/jzchar/Makefile
 create mode 100644 drivers/char/jzchar/example/i_i2c_tool.c
 create mode 100644 drivers/char/jzchar/i_i2c.c
 create mode 100644 drivers/char/jzchar/i_i2c_abi.h
 create mode 100644 drivers/char/jzchar/jz_ow.c
 create mode 100644 drivers/char/jzchar/jzchars.c
 create mode 100644 drivers/char/jzchar/jzchars.h
 create mode 100644 drivers/char/jzchar/tcsm.c
 create mode 100644 drivers/char/rtc_jz.c
 create mode 100644 drivers/char/rtc_jz.h
 create mode 100644 drivers/mmc/host/jzmmc/Makefile
 create mode 100644 drivers/mmc/host/jzmmc/include/jz_mmc_controller.h
 create mode 100644 drivers/mmc/host/jzmmc/include/jz_mmc_dma.h
 create mode 100644 drivers/mmc/host/jzmmc/include/jz_mmc_gpio.h
 create mode 100644 drivers/mmc/host/jzmmc/include/jz_mmc_host.h
 create mode 100644 drivers/mmc/host/jzmmc/include/jz_mmc_msc.h
 create mode 100644 drivers/mmc/host/jzmmc/include/jz_mmc_pio.h
 create mode 100644 drivers/mmc/host/jzmmc/jz_mmc_controller.c
 create mode 100644 drivers/mmc/host/jzmmc/jz_mmc_dma.c
 create mode 100644 drivers/mmc/host/jzmmc/jz_mmc_gpio.c
 create mode 100644 drivers/mmc/host/jzmmc/jz_mmc_main.c
 create mode 100644 drivers/mmc/host/jzmmc/jz_mmc_msc.c
 create mode 100644 drivers/mmc/host/jzmmc/jz_mmc_pio.c
 create mode 100644 drivers/usb/gadget/jz4740_udc.c
 create mode 100644 drivers/usb/gadget/jz4740_udc.h
 create mode 100644 drivers/usb/gadget/udc_hotplug.c
 create mode 100644 drivers/video/jz4750_lcd.c
 create mode 100644 drivers/video/jz4750_lcd.h
 create mode 100644 drivers/video/jz4750_tve.c
 create mode 100644 drivers/video/jz4750_tve.h
 create mode 100644 drivers/video/jz475x/Makefile
 create mode 100644 drivers/video/jz475x/abi.h
 create mode 100644 drivers/video/jz475x/common.c
 create mode 100644 drivers/video/jz475x/config.h
 create mode 100644 drivers/video/jz475x/core/desc.c
 create mode 100644 drivers/video/jz475x/core/framebuffer.c
 create mode 100644 drivers/video/jz475x/core/hw.c
 create mode 100644 drivers/video/jz475x/core/ot.c
 create mode 100644 drivers/video/jz475x/core/win.c
 create mode 100644 drivers/video/jz475x/drv/ctrl-drv.c
 create mode 100644 drivers/video/jz475x/drv/fb-drv.c
 create mode 100644 drivers/video/jz475x/jz-fb.c
 create mode 100644 drivers/video/jz475x/jz-fb.h
 create mode 100644 drivers/video/jz475x/output/config.c
 create mode 100644 drivers/video/jz475x/output/control.c
 create mode 100644 drivers/video/jz475x/output/lcd/auo-a043fl01v2.c
 create mode 100644 drivers/video/jz475x/output/lcd/lcd-control.c
 create mode 100644 drivers/video/jz475x/output/lcd/lcd-output.c
 create mode 100644 drivers/video/jz475x/output/output.c
 create mode 100644 drivers/video/jz475x/output/tve/tve-common.c
 create mode 100644 drivers/video/jz475x/output/tve/tve-control.c
 create mode 100644 drivers/video/jz475x/output/tve/tve-hw.c
 create mode 100644 drivers/video/jz475x/output/tve/tve-ntsc-output.c
 create mode 100644 drivers/video/jz475x/output/tve/tve-pal-output.c
 create mode 100644 drivers/video/jz475x/test/Makefile
 create mode 100644 drivers/video/jz475x/test/fb_common.c
 create mode 100644 drivers/video/jz475x/test/fb_fill.c
 create mode 100644 drivers/video/jz475x/test/fb_h_colorbar.c
 create mode 100644 drivers/video/jz475x/test/fb_info.c
 create mode 100644 drivers/video/jz475x/test/fb_v_colorbar.c
 create mode 100644 drivers/video/jz475x/test/lcd_ot_ctrl.c
 create mode 100644 drivers/video/jz475x/test/tve_ntsc_ot_ctrl.c
 create mode 100644 drivers/video/jz475x/test/tve_pal_ot_ctrl.c
 create mode 100644 drivers/video/jz475x/userspace-config.h

diff --git a/Makefile b/Makefile
index ebc8225..b367ac9 100644
--- a/Makefile
+++ b/Makefile
@@ -186,8 +186,8 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= mips
+CROSS_COMPILE	?= mipsel-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 7e6fd1c..78e356f 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -23,6 +23,14 @@ choice
 	prompt "System type"
 	default SGI_IP22
 
+config JZ4750D_CETUS
+	bool "Ingenic JZ4750d CETUS board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4750D
+
 config MACH_ALCHEMY
 	bool "Alchemy processor based machines"
 	select SYS_SUPPORTS_ZBOOT
@@ -698,6 +706,25 @@ source "arch/mips/loongson/Kconfig"
 
 endmenu
 
+#####################################################
+# Ingenic SOC series
+#####################################################
+
+config SOC_JZ4750D
+	bool
+	select JZSOC
+
+config JZSOC
+	bool
+	select JZRISC
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+
+config JZRISC
+	bool
+
+####################################################
+
 config RWSEM_GENERIC_SPINLOCK
 	bool
 	default y
@@ -820,7 +847,7 @@ config NEED_DMA_MAP_STATE
 	bool
 
 config SYS_HAS_EARLY_PRINTK
-	bool
+	bool "early printk"
 
 config HOTPLUG_CPU
 	bool "Support for hot-pluggable CPUs"
@@ -2169,6 +2196,14 @@ config I8253
 config ZONE_DMA32
 	bool
 
+config FORCE_MAX_ZONEORDER
+	prompt "MAX_ZONEORDER"
+	depends on JZSOC
+	int
+	default "13"
+help
+	 The max memory that can be allocated = 4KB * 2^(CONFIG_FORCE_MAX_ZONEORDER - 1)
+
 source "drivers/pcmcia/Kconfig"
 
 source "drivers/pci/hotplug/Kconfig"
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 0b9c01a..6953616 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -211,6 +211,14 @@ endif
 #
 
 #
+# Commond Ingenic JZ4750d series
+#
+
+core-$(CONFIG_SOC_JZ4750D)	+= arch/mips/jz4750d/
+cflags-$(CONFIG_SOC_JZ4750D)	+= -I$(srctree)/arch/mips/include/asm/mach-jz4750d
+load-$(CONFIG_SOC_JZ4750D)	+= 0xffffffff80010000
+
+#
 # Texas Instruments AR7
 #
 core-$(CONFIG_AR7)		+= arch/mips/ar7/
diff --git a/arch/mips/include/asm/bootinfo.h b/arch/mips/include/asm/bootinfo.h
index 09eee09..8d04057 100644
--- a/arch/mips/include/asm/bootinfo.h
+++ b/arch/mips/include/asm/bootinfo.h
@@ -52,11 +52,12 @@
 #define MACH_MSP7120_FPGA       5	/* PMC-Sierra MSP7120 Emulation */
 #define MACH_MSP_OTHER        255	/* PMC-Sierra unknown board type */
 
+#define MACH_WRPPMC             1
+
 /*
- * Valid machtype for group Mikrotik
+ * Valid machtype for group INGENIC
  */
-#define	MACH_MIKROTIK_RB532	0	/* Mikrotik RouterBoard 532 	*/
-#define MACH_MIKROTIK_RB532A	1	/* Mikrotik RouterBoard 532A 	*/
+#define  MACH_INGENIC_JZ4750D	3	/* JZ4750D SOC		*/
 
 /*
  * Valid machtype for Loongson family
@@ -71,7 +72,6 @@
 #define MACH_LEMOTE_LL2F       7
 #define MACH_LOONGSON_END      8
 
-extern char *system_type;
 const char *get_system_type(void);
 
 extern unsigned long mips_machtype;
diff --git a/arch/mips/include/asm/break.h b/arch/mips/include/asm/break.h
index 44437ed..9161e68 100644
--- a/arch/mips/include/asm/break.h
+++ b/arch/mips/include/asm/break.h
@@ -30,6 +30,8 @@
 #define BRK_BUG		512	/* Used by BUG() */
 #define BRK_KDB		513	/* Used in KDB_ENTER() */
 #define BRK_MEMU	514	/* Used by FPU emulator */
+#define BRK_KPROBE_BP	515	/* Kprobe break */
+#define BRK_KPROBE_SSTEPBP 516	/* Kprobe single step software implementation */
 #define BRK_MULOVF	1023	/* Multiply overflow */
 
 #endif /* __ASM_BREAK_H */
diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h
index 40bb9fd..1f50d36 100644
--- a/arch/mips/include/asm/cacheflush.h
+++ b/arch/mips/include/asm/cacheflush.h
@@ -10,6 +10,7 @@
 #define _ASM_CACHEFLUSH_H
 
 /* Keep includes the same across arches.  */
+#include <linux/fs.h>
 #include <linux/mm.h>
 #include <asm/cpu-features.h>
 
@@ -58,10 +59,39 @@ static inline void flush_anon_page(struct vm_area_struct *vma,
 		__flush_anon_page(page, vmaddr);
 }
 
+#ifdef CONFIG_JZRISC
+extern void (*flush_insn_cache_page)(unsigned long addr);
+static inline void flush_icache_page(struct vm_area_struct *vma,
+	struct page *page)
+{
+	struct address_space *mapping = page_mapping(page);
+	unsigned long addr;
+
+	if (PageHighMem(page))
+	  return;
+
+	if (mapping && !mapping_mapped(mapping)) {
+	  return;
+	}
+
+	__flush_dcache_page(page);
+
+	/*
+	 * We could delay the flush for the !page_mapping case too.  But that
+	 * case is for exec env/arg pages and those are %99 certainly going to
+	 * get faulted into the tlb (and thus flushed) anyways.
+	 */
+
+	addr = (unsigned long) page_address(page);
+
+	flush_insn_cache_page(addr);
+}
+#else
 static inline void flush_icache_page(struct vm_area_struct *vma,
 	struct page *page)
 {
 }
+#endif
 
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
 extern void (*local_flush_icache_range)(unsigned long start, unsigned long end);
diff --git a/arch/mips/include/asm/cacheops.h b/arch/mips/include/asm/cacheops.h
index 256ad2c..9b9e5c8 100644
--- a/arch/mips/include/asm/cacheops.h
+++ b/arch/mips/include/asm/cacheops.h
@@ -35,6 +35,7 @@
 #define Fill			0x14
 #define Hit_Writeback_I		0x18
 #define Hit_Writeback_D		0x19
+#define Index_Prefetch_I	0x1c
 
 /*
  * R4000SC and R4400SC-specific cacheops
diff --git a/arch/mips/include/asm/cpu.h b/arch/mips/include/asm/cpu.h
index a5acda4..e67aebb 100644
--- a/arch/mips/include/asm/cpu.h
+++ b/arch/mips/include/asm/cpu.h
@@ -34,7 +34,7 @@
 #define PRID_COMP_LSI		0x080000
 #define PRID_COMP_LEXRA		0x0b0000
 #define PRID_COMP_CAVIUM	0x0d0000
-
+#define PRID_COMP_INGENIC	0xd00000
 
 /*
  * Assigned values for the product ID register.  In order to detect a
@@ -133,6 +133,12 @@
 #define PRID_IMP_CAVIUM_CN52XX 0x0700
 
 /*
+ * These are the PRID's for when 23:16 == PRID_COMP_INGENIC
+ */
+
+#define PRID_IMP_JZRISC        0x0200
+
+/*
  * Definitions for 7:0 on legacy processors
  */
 
@@ -226,6 +232,11 @@ enum cpu_type_enum {
 	CPU_5KC, CPU_20KC, CPU_25KF, CPU_SB1, CPU_SB1A, CPU_LOONGSON2,
 	CPU_CAVIUM_OCTEON, CPU_CAVIUM_OCTEON_PLUS,
 
+	/*
+	 * Ingenic class processors
+	 */
+	CPU_JZRISC, CPU_XBURST,
+
 	CPU_LAST
 };
 
diff --git a/arch/mips/include/asm/inst.h b/arch/mips/include/asm/inst.h
index 6489f00..444ff71 100644
--- a/arch/mips/include/asm/inst.h
+++ b/arch/mips/include/asm/inst.h
@@ -247,6 +247,12 @@ struct ma_format {	/* FPU multipy and add format (MIPS IV) */
 	unsigned int fmt : 2;
 };
 
+struct b_format { /* BREAK and SYSCALL */
+	unsigned int opcode:6;
+	unsigned int code:20;
+	unsigned int func:6;
+};
+
 #elif defined(__MIPSEL__)
 
 struct j_format {	/* Jump format */
@@ -314,6 +320,12 @@ struct ma_format {	/* FPU multipy and add format (MIPS IV) */
 	unsigned int opcode : 6;
 };
 
+struct b_format { /* BREAK and SYSCALL */
+	unsigned int func:6;
+	unsigned int code:20;
+	unsigned int opcode:6;
+};
+
 #else /* !defined (__MIPSEB__) && !defined (__MIPSEL__) */
 #error "MIPS but neither __MIPSEL__ nor __MIPSEB__?"
 #endif
@@ -328,7 +340,8 @@ union mips_instruction {
 	struct c_format c_format;
 	struct r_format r_format;
 	struct f_format f_format;
-        struct ma_format ma_format;
+	struct ma_format ma_format;
+	struct b_format b_format;
 };
 
 /* HACHACHAHCAHC ...  */
diff --git a/arch/mips/include/asm/jzpm/jz_act8930.h b/arch/mips/include/asm/jzpm/jz_act8930.h
new file mode 100644
index 0000000..5443329
--- /dev/null
+++ b/arch/mips/include/asm/jzpm/jz_act8930.h
@@ -0,0 +1,151 @@
+
+/*
+ * This is a interface file for jz soc ,if you ues jz soc ,this file is need . 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#if defined(CONFIG_JZ4760_LYNX) || defined(CONFIG_JZ4760B_LYNX)
+#define PMU_HDMI_1_8              0x54
+#define PMU_HDMI_3_3   			  0x50
+#else
+#define PMU_MSC0    			       0x50
+#define PMU_LCD                        0x54
+#endif
+#define PMU_WIFI                       0x60
+#define PMU_COMPASS                    0x64
+
+#define PMU_V3_3		0x39
+#define PMU_V1_8		0x24
+
+extern int act8930_ldo_disable(int voltage_set_reg);
+extern int act8930_ldo_enable(int voltage_set_reg, int voltage);
+extern int dc_power_detect(void);
+	
+#if defined(CONFIG_JZ4760_LYNX) || defined(CONFIG_JZ4760B_LYNX)
+//-------------------------------------------------------------------
+//for hdmi 
+#define __hdmi_power_on() 						         \
+	do {											\
+		while(act8930_ldo_enable(PMU_HDMI_3_3,PMU_V3_3))		\
+			printk("act8930 : enable lcd power err.\n");		\
+		while(act8930_ldo_enable(PMU_HDMI_1_8,PMU_V1_8))		\
+			printk("act8930 : enable lcd power err.\n");		\
+	} while (0)
+
+#define __hdmi_power_off() 						\
+	do {					        		                   \
+		while(act8930_ldo_disable(PMU_HDMI_1_8))		\
+			printk("act8930 : disable lcd power err.\n");	\
+		while(act8930_ldo_disable(PMU_HDMI_3_3))		\
+			printk("act8930 : disable lcd power err.\n");	\
+	} while (0)
+//------------------------------------------------------------------
+//for tf card
+#define __msc0_power_on()			\
+	do {					        \
+		__gpio_clear_pin(GPIO_SD1_VCC_EN_N);	\
+	} while (0)
+
+#define __msc0_power_off()			\
+	do {					        \
+		__gpio_set_pin(GPIO_SD1_VCC_EN_N);	\
+	} while (0)
+//-------------------------------------------------------------------
+//for lcd 
+#define __lcd_power_on() 						         \
+	do {					        \
+		__gpio_set_pin(GPIO_LCD_VCC_EN);	\
+	} while (0)
+
+#define __lcd_power_off() 						\
+	do {					        \
+		__gpio_clear_pin(GPIO_LCD_VCC_EN);	\
+	} while (0)
+//------------------------------------------------------------------
+#else
+//-------------------------------------------------------------------
+//for lcd 
+#define __lcd_power_on() 						         \
+	do {											\
+		while(act8930_ldo_enable(PMU_LCD,PMU_V3_3))		\
+			printk("act8930 : enable lcd power err.\n");		\
+	} while (0)
+
+#define __lcd_power_off() 						\
+	do {					        		                   \
+		while(act8930_ldo_disable(PMU_LCD))		\
+			printk("act8930 : disable lcd power err.\n");	\
+	} while (0)
+//------------------------------------------------------------------
+//for tf card
+#define __msc0_power_on()			\
+	do {					        \
+		while(act8930_ldo_enable(PMU_MSC0, PMU_V3_3))			\
+			printk("act8930 : disable msc0 power err.\n");		\
+	} while (0)
+
+#define __msc0_power_off()			\
+	do {						\
+		while(act8930_ldo_disable(PMU_MSC0))			\
+			printk("act8930 : disable msc0 power err.\n");		\
+	} while (0)
+//-------------------------------------------------------------------
+#endif
+//for msc0
+#define __msc0_enable_power()			\
+	do {					        \
+		__gpio_clear_pin(GPIO_SD0_VCC_EN_N);	\
+	} while (0)
+
+#define __msc0_disable_power()			\
+	do {						\
+		__gpio_set_pin(GPIO_SD0_VCC_EN_N);	\
+	} while (0)
+//-------------------------------------------------------------------
+//for compass sensor
+#define __compass_power_on() 						\
+	do {					        		\
+		while(act8930_ldo_enable(PMU_COMPASS, PMU_V3_3))		\
+			printk("act8930 : enable compass power err.\n");		\
+	} while (0)
+
+#define __compass_power_off() 						\
+	do {					        		\
+		while(act8930_ldo_disable(PMU_COMPASS))		\
+			printk("act8930 : disable compass power err.\n");	\
+	} while (0)
+
+
+//-------------------------------------------------------------------
+//for wifi
+#define __wifi_power_on() 						\
+	do {				        		\
+		while(act8930_ldo_enable(PMU_WIFI, PMU_V3_3))			\
+			printk("act8930 : enable wifi power err.\n");		\
+	} while (0)
+
+#define __wifi_power_off() 						\
+	do {				        		\
+		while(act8930_ldo_disable(PMU_WIFI))			\
+			printk("act8930 : disable wifi power err.\n");		\
+	} while (0)
+//-------------------------------------------------------------------
+
+//four ldo power off
+#define __pmu_power_off()			\
+	do {						\
+		while(act8930_ldo_disable( 0x50))			\
+			printk("act8930 : disable lcd power err.\n");		\
+		while(act8930_ldo_disable( 0x60))			\
+			printk("act8930 : disable wifii power err.\n");		\
+		while(act8930_ldo_disable( 0x64))			\
+			printk("act8930 : disable compass power err.\n");		\
+		while(act8930_ldo_disable( 0x54))			\
+			printk("act8930 : disable msc0 power err.\n");		\
+	} while (0)
+//-------------------------------------------------------------------
+
diff --git a/arch/mips/include/asm/jzpm/jz_axp192.h b/arch/mips/include/asm/jzpm/jz_axp192.h
new file mode 100644
index 0000000..416ebcb
--- /dev/null
+++ b/arch/mips/include/asm/jzpm/jz_axp192.h
@@ -0,0 +1,81 @@
+/*
+ * This is a interface file for jz soc ,if you ues jz soc ,this file is need . 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define AXP192_COMPASS              	2      //LDO2
+#define AXP192_HDMI			3      //LDO3
+
+#define __lcd_power_on()    do{}while(0)
+#define __lcd_power_off()   do{}while(0)
+
+int axp192_ldo_disable(int ldo_num);
+
+//-------------------------------------------------------------------
+//for compass sensor
+#define __compass_power_on() 						\
+	do {					        		\
+		while(axp192_ldo_enable(AXP192_COMPASS))		\
+		printk("axp192 : enable compass power err.\n");		\
+	} while (0)
+
+#define __compass_power_off() 						\
+	do {					        		\
+		while(axp192_ldo_disable(AXP192_COMPASS))		\
+		printk("axp192 : disable compass power err.\n");	\
+	} while (0)
+
+
+//-------------------------------------------------------------------
+//for compass sensor
+#define __hdmi_power_on() 						\
+	do {					        		\
+		while(axp192_ldo_enable(AXP192_HDMI))			\
+		printk("axp192 : enable hdmi power err.\n");		\
+	} while (0)
+
+#define __hdmi_power_off() 						\
+	do {					        		\
+		while(axp192_ldo_disable(AXP192_HDMI))			\
+		printk("axp192 : disable hdmi power err.\n");		\
+	} while (0)
+
+//-------------------------------------------------------------------
+//for wifi
+#define __msc0_enable_power()			\
+	do {					        \
+		__gpio_clear_pin(GPIO_SD0_VCC_EN_N);	\
+	} while (0)
+
+
+//-------------------------------------------------------------------
+//for wifi
+#define __msc0_disable_power()			\
+	do {						\
+		__gpio_set_pin(GPIO_SD0_VCC_EN_N);	\
+	} while (0)
+
+
+//-------------------------------------------------------------------
+//when system power on ,this power is enabled.
+#define __camera_power_on()			\
+	do{					        \
+	}while(0)
+#define __camera_power_off()			\
+	do{					        \
+	}while(0)
+
+#define __gps_power_on()   do{}while(0)
+#define __gps_power_off()  do{}while(0)
+
+#define __msc1_enable_power()			\
+	do {\
+		__gpio_clear_pin(GPIO_SD1_VCC_EN_N);	\
+	} while (0)
+
+#define __msc1_disable_power()\
+	do {\
+		__gpio_set_pin(GPIO_SD1_VCC_EN_N);\
+	} while (0)
diff --git a/arch/mips/include/asm/jzpm/jz_wm831x.h b/arch/mips/include/asm/jzpm/jz_wm831x.h
new file mode 100644
index 0000000..2228215
--- /dev/null
+++ b/arch/mips/include/asm/jzpm/jz_wm831x.h
@@ -0,0 +1,118 @@
+
+/*
+ * This is a interface file for jz-soc & wm8310 model, this file is need . 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define WM8310_BT_WIFI_VPA           0      //LDO1
+#define WM8310_CIM_VCORE             1      //LDO2
+#define WM8310_GPS_VDD               2      //LDO3
+#define WM8310_LCD_VDD               3      //LDO4
+#define WM8310_LCD_VDDA              4      //LDO5
+#define WM8310_VCC_MSCI              5      //LDO6
+#define WM8310_BT_WIFI_VCORE         6      //LDO7
+#define WM8310_BT_WIFI_VCC           7      //LDO8
+#define WM8310_CIM_AVDD              8      //LDO9
+#define WM8310_CIM_DVDD              9      //LDO10
+
+#define __lcd_power_on()			         \
+do {						         \
+	while (wm8310_ldo_enable(WM8310_LCD_VDD))	 \
+	printk("lcd power1: enable lcd power err.\n");  \
+	while (wm8310_ldo_enable(WM8310_LCD_VDDA))	 \
+	printk("lcd power2: enable lcd power err.\n");  \
+} while (0)
+
+#define __lcd_power_off()			         \
+do {						         \
+	while (wm8310_ldo_disable(WM8310_LCD_VDD))	 \
+	printk("lcd power1: disable lcd power err.\n");  \
+	while (wm8310_ldo_disable(WM8310_LCD_VDDA))	 \
+	printk("lcd power2: disable lcd power err.\n");  \
+} while (0)
+
+//for wifi
+#define __msc0_enable_power()			        \
+do {	 					        \
+	while (wm8310_ldo_enable(WM8310_BT_WIFI_VPA))	\
+	printk("wifi power1: enable wifi power err.\n");\
+	while (wm8310_ldo_enable(WM8310_BT_WIFI_VCC))	\
+	printk("wifi power2: enable wifi power err.\n");\
+	while (wm8310_ldo_enable(WM8310_BT_WIFI_VCORE))	\
+	printk("wifi power3: enable wifi power err.\n");\
+} while (0)
+
+//for wifi
+#define __msc0_disable_power()			         \
+do {						         \
+	while (wm8310_ldo_disable(WM8310_BT_WIFI_VCORE))	 \
+	printk("wifi power1: disable wifi power err.\n");\
+	while (wm8310_ldo_disable(WM8310_BT_WIFI_VCC)) \
+	printk("wifi power2: disable wifi power err.\n");\
+	while (wm8310_ldo_disable(WM8310_BT_WIFI_VPA))	 \
+	printk("wifi power3: disable wifi power err.\n");\
+} while (0)
+
+#define __camera_power_on()			            \
+do {						            \
+	printk("----------------------camera_power_on\n");	\
+	while (wm8310_ldo_enable(WM8310_CIM_DVDD))	    \
+	printk("camera power2: enable camera power err.\n");\
+	while (wm8310_ldo_enable(WM8310_CIM_VCORE))	    \
+	printk("camera power3: enable camera power err.\n");\
+	while (wm8310_ldo_enable(WM8310_CIM_AVDD))	    \
+	printk("camera power1: enable camera power err.\n");\
+} while (0)
+
+/*
+#define __camera_power_on()			            \
+do {						            \
+	while (wm8310_ldo_enable(WM8310_CIM_AVDD))	    \
+	printk("camera power1: enable camera power err.\n");\
+	msleep(1);					    \
+	while (wm8310_ldo_enable(WM8310_CIM_DVDD))	    \
+	printk("camera power2: enable camera power err.\n");\
+	msleep(1);					    \
+	while (wm8310_ldo_enable(WM8310_CIM_VCORE))	    \
+	printk("camera power3: enable camera power err.\n");\
+} while (0)
+*/
+#define __camera_power_off()			             \
+do {						             \
+	printk("----------------------camera_power_off\n");  \
+	while (wm8310_ldo_disable(WM8310_CIM_AVDD))	     \
+	printk("camera power1: disable camera power err.\n");\
+	while (wm8310_ldo_disable(WM8310_CIM_DVDD))	     \
+	printk("camera power2: disable camera power err.\n");\
+	while (wm8310_ldo_disable(WM8310_CIM_VCORE))	     \
+	printk("camera power3: disable camera power err.\n");\
+} while (0)
+
+#define __compass_power_on() __gps_power_on()
+#define __gps_power_on()                                     \
+do {  		                                             \
+	while (wm8310_ldo_enable(WM8310_GPS_VDD))	     \
+	printk("gps power1: enable gps power err.\n");       \
+} while (0)
+
+#define __compass_power_off() __gps_power_off()
+#define __gps_power_off()                                    \
+do {  		                                             \
+	while (wm8310_ldo_disable(WM8310_GPS_VDD))	     \
+	printk("gps power1: disable gps power err.\n");      \
+} while (0)
+
+#define __msc1_enable_power()			            \
+do {  		                                            \
+	while (wm8310_ldo_enable(WM8310_VCC_MSCI))	    \
+	printk("msc1 power1: enable msc1 power err.\n");    \
+} while (0)
+
+#define __msc1_disable_power()			           \
+do {  		                                           \
+	while (wm8310_ldo_disable(WM8310_VCC_MSCI))	                   \
+	printk("msc1 power1: disable msc1 power err.\n");  \
+} while (0)
diff --git a/arch/mips/include/asm/jzsoc.h b/arch/mips/include/asm/jzsoc.h
new file mode 100644
index 0000000..4c86f72
--- /dev/null
+++ b/arch/mips/include/asm/jzsoc.h
@@ -0,0 +1,55 @@
+/*
+ *  linux/include/asm-mips/jzsoc.h
+ *
+ *  Ingenic's JZXXXX SoC common include.
+ *
+ *  Copyright (C) 2006 - 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZSOC_H__
+#define __ASM_JZSOC_H__
+
+/*
+ * SoC include
+ */
+
+#ifdef CONFIG_SOC_JZ4750D
+#include <asm/mach-jz4750d/jz4750d.h>
+#endif
+
+#ifdef CONFIG_MFD_WM831X
+#include <linux/mfd/wm831x/core.h>
+#include <asm/jzpm/jz_wm831x.h>
+#else
+    #ifdef CONFIG_PMU_AXP192
+    #include <linux/axp192.h>
+    #include <asm/jzpm/jz_axp192.h>
+    #elif defined(CONFIG_PMU_ACT8930_SUPPORT)
+    #include <asm/jzpm/jz_act8930.h>
+    #endif
+#endif
+/*
+#else
+
+#include <asm/jzpm/jz.h>
+#endif
+*/
+
+/*
+ * Generic I/O routines
+ */
+#define readb(addr)	(*(volatile unsigned char *)(addr))
+#define readw(addr)	(*(volatile unsigned short *)(addr))
+#define readl(addr)	(*(volatile unsigned int *)(addr))
+
+#define writeb(b,addr)	((*(volatile unsigned char *)(addr)) = (b))
+#define writew(b,addr)	((*(volatile unsigned short *)(addr)) = (b))
+#define writel(b,addr)	((*(volatile unsigned int *)(addr)) = (b))
+
+#endif /* __ASM_JZSOC_H__ */
diff --git a/arch/mips/include/asm/mach-generic/irq.h b/arch/mips/include/asm/mach-generic/irq.h
index 70d9a25..73b7a83 100644
--- a/arch/mips/include/asm/mach-generic/irq.h
+++ b/arch/mips/include/asm/mach-generic/irq.h
@@ -9,7 +9,7 @@
 #define __ASM_MACH_GENERIC_IRQ_H
 
 #ifndef NR_IRQS
-#define NR_IRQS	128
+#define NR_IRQS	256
 #endif
 
 #ifdef CONFIG_I8259
diff --git a/arch/mips/include/asm/mach-jz4750d/board-cetus.h b/arch/mips/include/asm/mach-jz4750d/board-cetus.h
new file mode 100644
index 0000000..e199c56
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/board-cetus.h
@@ -0,0 +1,279 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/board-cetus.h
+ *
+ *  JZ4750D-based CETUS board ver 1.x definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750D_CETUS_H__
+#define __ASM_JZ4750D_CETUS_H__
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		24000000
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+//#define CFG_DIV                 1         /* hclk=pclk=mclk=CFG_EXTAL/CFG_DIV, just for FPGA board */
+
+
+/*====================================================================== 
+ * GPIO
+ */
+
+#define GPIO_SD0_VCC_EN_N	(32*4+0) /* CIM_D0 */
+#define GPIO_SD0_CD_N		(32*4+1) /* CIM_D1 */
+#define GPIO_SD0_WP		(32*4+2) /* CIM_D2 */
+#define GPIO_SD1_VCC_EN_N	(32*4+3) /* CIM_D3 */
+#define GPIO_SD1_CD_N		(32*4+4) /* CIM_D4 */
+
+#define GPIO_USB_DETE		(32*4+6) /* CIM_D6 */
+#define GPIO_DC_DETE_N		(32*4+8) /* CIM_MCLK */
+#define GPIO_CHARG_STAT_N	(32*4+10) /* CIM_VSYNC */
+#define GPIO_DISP_OFF_N		(32*4+18) /* SDATO */
+#define GPIO_LCD_VCC_EN_N	(32*4+19) /* SDATI */
+//#define GPIO_LED_EN       	124 /* GPD28 */
+
+#define GPIO_UDC_HOTPLUG	GPIO_USB_DETE
+
+/*====================================================================== 
+ * LCD backlight
+ */
+#define GPIO_LCD_PWM   		(32*4+22) /* GPE22 PWM2 */ 
+#define LCD_PWM_CHN 2    /* pwm channel */
+
+#define LCD_MAX_BACKLIGHT		100
+#define LCD_MIN_BACKLIGHT		1
+#define LCD_DEFAULT_BACKLIGHT		80
+
+/* LCD Backlight PWM Control - River. */
+#define HAVE_LCD_PWM_CONTROL	1
+
+#ifdef HAVE_LCD_PWM_CONTROL
+static inline void __lcd_pwm_set_backlight_level(int n)
+{
+	__tcu_stop_counter(LCD_PWM_CHN);
+	
+	__tcu_set_pwm_output_shutdown_abrupt(LCD_PWM_CHN);
+	__tcu_disable_pwm_output(LCD_PWM_CHN);
+
+	__tcu_set_count(LCD_PWM_CHN, 0);
+	__tcu_set_full_data(LCD_PWM_CHN, LCD_MAX_BACKLIGHT + 1);
+	__tcu_set_half_data(LCD_PWM_CHN, n);
+
+	__tcu_enable_pwm_output(LCD_PWM_CHN);
+	__tcu_start_counter(LCD_PWM_CHN);
+
+	return;
+}
+
+static inline void __lcd_pwm_start(void)
+{
+	__gpio_as_pwm(2);
+
+	__tcu_stop_counter(LCD_PWM_CHN);
+	
+	__tcu_select_extalclk(LCD_PWM_CHN);
+	__tcu_select_clk_div4(LCD_PWM_CHN);
+	__tcu_init_pwm_output_high(LCD_PWM_CHN);
+
+	__lcd_pwm_set_backlight_level(LCD_DEFAULT_BACKLIGHT);
+
+	return;
+}
+
+static inline void __lcd_pwm_stop(void)
+{
+	__tcu_stop_counter(LCD_PWM_CHN);
+
+	__tcu_set_pwm_output_shutdown_abrupt(LCD_PWM_CHN);
+	__tcu_disable_pwm_output(LCD_PWM_CHN);
+
+	return;
+}
+
+#define __lcd_set_backlight_level(n) __lcd_pwm_set_backlight_level(n)
+
+#else
+
+/* 100 level: 0,1,...,100 */
+#define __lcd_set_backlight_level(n)	\
+do {					\
+	__gpio_as_output(GPIO_LCD_PWM);	\
+	__gpio_set_pin(GPIO_LCD_PWM);	\
+} while (0)
+
+#endif
+
+#define __lcd_close_backlight()		\
+do {					\
+	__gpio_as_output(GPIO_LCD_PWM);	\
+	__gpio_clear_pin(GPIO_LCD_PWM);	\
+} while (0)
+
+//20091118
+/*====================================================================
+ * GPIO KEYS and ADKEYS
+ */
+#define GPIO_HOME		(32*5+12) // SW4-GPF12 SSI_DR
+#define GPIO_MENU		(32*2+31) // SW2-GPC31 boot_sel1
+#define GPIO_BACK		(32*5+11) // SW3-GPF11 SSI_DT
+#define GPIO_CALL		(32*5+10) // SW5-GPF10 SSI_CLK
+#define GPIO_ENDCALL		(32*4+7)  // SW6-GPE7  CIM_D7
+#define GPIO_SW10		(32*4+25) // SW10-GPE25 UART1_TXD
+#define GPIO_ADKEY_INT		(32*4+11) // KEY_INT-GPE11  CIM_HSYNC
+
+/*====================================================================
+ *  ADKEYS LEVEL
+ */
+
+#define DPAD_LEFT_LEVEL		869	//0.7V, 225=0.18105/3.3*4096
+#define DPAD_DOWN_LEVEL		1986	//1.6V
+#define DPAD_UP_LEVEL		2482	//2.0V
+#define DPAD_CENTER_LEVEL	1489	//1.2V
+#define DPAD_RIGHT_LEVEL	186	//0.15V
+
+/*====================================================================== 
+ * Analog input for VBAT is the battery voltage divided by CFG_PBAT_DIV.
+ */
+#define CFG_PBAT_DIV            1
+
+/*
+ * The GPIO interrupt pin is low voltage or fall edge acitve
+ */
+#define ACTIVE_LOW_HOME		1
+#define ACTIVE_LOW_MENU		1
+#define ACTIVE_LOW_BACK		1
+#define ACTIVE_LOW_CALL		1
+#define ACTIVE_LOW_ENDCALL	1
+#define ACTIVE_LOW_SW10		1
+#define ACTIVE_LOW_ADKEY	1
+#define ACTIVE_LOW_MSC0_CD	1 /* work when GPIO_SD0_CD_N = 0 */
+#define ACTIVE_LOW_MSC1_CD	1 /* work when GPIO_SD1_CD_N = 0 */
+#define ACTIVE_WAKE_UP 		1
+
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC0_WP_PIN		GPIO_SD0_WP
+#define MSC0_HOTPLUG_PIN	GPIO_SD0_CD_N
+#define MSC0_HOTPLUG_IRQ	(IRQ_GPIO_0 + GPIO_SD0_CD_N)
+
+#define MSC1_WP_PIN		GPIO_SD1_WP
+#define MSC1_HOTPLUG_PIN	GPIO_SD1_CD_N
+#define MSC1_HOTPLUG_IRQ	(IRQ_GPIO_0 + GPIO_SD1_CD_N)
+
+#define __msc0_init_io()			\
+do {						\
+	__gpio_as_output(GPIO_SD0_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD0_CD_N);		\
+} while (0)
+
+#define __msc0_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD0_VCC_EN_N);	\
+} while (0)
+
+#define __msc0_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD0_VCC_EN_N);	\
+} while (0)
+
+/*
+#define __msc0_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD0_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+*/
+
+#if ACTIVE_LOW_MSC0_CD == 1 /* work when cd is low */
+#define __msc0_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD0_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+#else
+#define __msc0_card_detected(s)			\
+({						\
+	int detected = 0;			\
+	if (__gpio_get_pin(GPIO_SD0_CD_N))	\
+		detected = 1;			\
+	detected;				\
+})
+#endif /*ACTIVE_LOW_MSC0_CD*/
+
+#define __msc1_init_io()			\
+do {						\
+	__gpio_as_output(GPIO_SD1_VCC_EN_N);	\
+	/*	__gpio_as_input(GPIO_SD1_CD_N);*/	\
+} while (0)
+
+#define __msc1_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD1_VCC_EN_N);	\
+} while (0)
+
+#define __msc1_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD1_VCC_EN_N);	\
+} while (0)
+
+/*
+#define __msc1_card_detected(s)			\
+({						\
+	int detected = 0;			\
+	if (!(__gpio_get_pin(GPIO_SD1_CD_N)))	\
+		detected = 1;			\
+	detected;				\
+})
+*/
+
+#if ACTIVE_LOW_MSC1_CD == 1 /* work when cd is low */
+#define __msc1_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD1_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+#else
+#define __msc1_card_detected(s)			\
+({						\
+	int detected = 0;			\
+	if (__gpio_get_pin(GPIO_SD1_CD_N))	\
+		detected = 1;			\
+	detected;				\
+})
+#endif /*ACTIVE_LOW_MSC1_CD*/
+
+
+
+/*======================================================================
+ * SPI 
+ */
+#define GPIO_SSI0_CE0	(32*1+29)
+#define GPIO_SSI0_CE1	(32*1+31)
+#define SSI0_GPC_PIN	(32*1+30)
+#define GPI1_SSI0_CE0	(32*1+29)		/* same as SSI0, for avoiding compilation error and ... */
+#define GPI1_SSI0_CE1	(32*1+31)
+
+#define	 SPI_CHIPSELECT_NUM_A		GPIO_SSI0_CE0
+#define	 SPI_CHIPSELECT_NUM_B		GPIO_SSI0_CE1
+#define	 SPI_CHIPSELECT_NUM_C		GPIO_SSI1_CE0
+
+#define  SPI0_BUS		0
+#define  SPI1_BUS		1
+
+#endif /* __ASM_JZ4750d_CETUS_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/clock.h b/arch/mips/include/asm/mach-jz4750d/clock.h
new file mode 100644
index 0000000..a2832d6
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/clock.h
@@ -0,0 +1,230 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/clock.h
+ *
+ *  JZ4750D clocks definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750D_CLOCK_H__
+#define __ASM_JZ4750D_CLOCK_H__
+
+#ifndef JZ_EXTAL
+#define JZ_EXTAL		12000000   /* 3.6864 MHz */
+#endif
+#ifndef JZ_EXTAL2
+#define JZ_EXTAL2		32768     /* 32.768 KHz */
+#endif
+
+/*
+ * JZ4750D clocks structure
+ */
+typedef struct {
+	unsigned int cclk;      /* CPU clock */
+	unsigned int hclk;      /* System bus clock */
+	unsigned int pclk;      /* Peripheral bus clock */
+	unsigned int mclk;      /* Flash/SRAM/SDRAM clock */
+	unsigned int h1clk;     /*  AHB1 clock */
+	unsigned int pixclk;    /* LCD pixel clock */
+	unsigned int i2sclk;    /* AIC module clock */
+	unsigned int usbclk;    /* USB module clock */
+	unsigned int mscclk;    /* MSC module clock */
+	unsigned int extalclk;  /* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+	unsigned int rtcclk;    /* RTC clock for CPM,INTC,RTC,TCU,WDT */
+} jz_clocks_t;
+
+extern jz_clocks_t jz_clocks;
+
+
+/* PLL output frequency */
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	unsigned long m, n, no, pllout;
+	unsigned long cppcr = REG_CPM_CPPCR;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if ((cppcr & CPM_CPPCR_PLLEN) && !(cppcr & CPM_CPPCR_PLLBP)) {
+		m = __cpm_get_pllm() + 2;
+		n = __cpm_get_plln() + 2;
+		no = od[__cpm_get_pllod()];
+		pllout = ((JZ_EXTAL) / (n * no)) * m;
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+#endif
+}
+
+/* PLL output frequency for MSC/I2S/LCD/USB */
+static __inline__ unsigned int __cpm_get_pllout2(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	if (REG_CPM_CPCCR & CPM_CPCCR_PCS)
+		return __cpm_get_pllout();
+	else
+		return __cpm_get_pllout()/2;
+#endif
+}
+
+/* CPU core clock */
+static __inline__ unsigned int __cpm_get_cclk(void)
+{
+
+#if defined(CONFIG_FGPA)
+	return JZ_EXTAL;
+#else
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	return __cpm_get_pllout() / div[__cpm_get_cdiv()];
+#endif
+}
+
+/* AHB system bus clock */
+static __inline__ unsigned int __cpm_get_hclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_hdiv()];
+#endif
+
+}
+
+/* Memory bus clock */
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_mdiv()];
+#endif
+}
+
+/* APB peripheral bus clock */
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_pdiv()];
+#endif
+}
+
+/* LCDC module clock */
+static __inline__ unsigned int __cpm_get_h1clk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_h1div() + 1);
+}
+
+/* LCD pixel clock */
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_pixdiv() + 1);
+}
+
+/* I2S clock */
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_I2CS) {
+		return __cpm_get_pllout2() / (__cpm_get_i2sdiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* USB clock */
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_UCS) {
+		return __cpm_get_pllout2() / (__cpm_get_udiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* 
+ * MSC clock
+ * @n: the index of MMC/SD controller 
+ */
+static __inline__ unsigned int __cpm_get_mscclk(int n)
+{
+	return __cpm_get_pllout2() / (__cpm_get_mscdiv(n) + 1);
+}
+
+/* EXTAL clock */
+static __inline__ unsigned int __cpm_get_extalclk0(void)
+{
+	return JZ_EXTAL;
+}
+
+/* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+static __inline__ unsigned int __cpm_get_extalclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return __cpm_get_pllout();
+#else
+	if (REG_CPM_CPCCR & CPM_CPCCR_ECS)
+		return __cpm_get_extalclk0()/2;
+	else
+		return __cpm_get_extalclk0();
+#endif
+
+}
+
+/* RTC clock for CPM,INTC,RTC,TCU,WDT */
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+/*
+ * Output 24MHz for SD and 16MHz for MMC.
+ * @n: the index of MMC/SD controller
+ */
+static inline void __cpm_select_msc_clk(int n, int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	if (sd) {
+		div = pllout2 / 24000000;
+	}
+	else {
+		div = pllout2 / 16000000;
+	}
+
+	REG_CPM_MSCCDR(n) = div - 1;
+	REG_CPM_CPCCR |= CPM_CPCCR_CE;
+}
+
+/*
+ * Output 48MHz for high speed card.
+ */
+static inline void __cpm_select_msc_clk_high(int n, int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	div = pllout2 / 48000000;
+
+	REG_CPM_MSCCDR(n) = div - 1;
+	REG_CPM_CPCCR |= CPM_CPCCR_CE;
+}
+
+#endif /* __ASM_JZ4750D_CLOCK_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/dma.h b/arch/mips/include/asm/mach-jz4750d/dma.h
new file mode 100644
index 0000000..3cca844
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/dma.h
@@ -0,0 +1,307 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/dma.h
+ *
+ *  JZ4750D DMA definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750D_DMA_H__
+#define __ASM_JZ4750D_DMA_H__
+
+#include <linux/interrupt.h>
+#include <asm/io.h>			/* need byte IO */
+#include <linux/spinlock.h>		/* And spinlocks */
+#include <linux/delay.h>
+#include <asm/system.h>
+
+/*
+ * Descriptor structure for JZ4750D DMA engine
+ * Note: this structure must always be aligned to a 16-bytes boundary.
+ */
+
+/* old descriptor 4-word */
+typedef struct {
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+	volatile u32 dsadr;	/* DSAR value for the current transfer */
+	volatile u32 dtadr;	/* DTAR value for the current transfer */
+	volatile u32 ddadr;	/* Points to the next descriptor + transfer count */
+} jz_dma_desc;
+
+/* new descriptor 8-word */
+typedef struct {
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+	volatile u32 dsadr;	/* DSAR value for the current transfer */
+	volatile u32 dtadr;	/* DTAR value for the current transfer */
+	volatile u32 ddadr;	/* Points to the next descriptor + transfer count */
+	volatile u32 dstrd;     /* DMA source and target stride address */
+	volatile u32 dreqt;     /* DMA request type for current transfer */
+	volatile u32 reserved0;	/* Reserved */
+	volatile u32 reserved1;	/* Reserved */
+} jz_dma_desc_8word;
+
+/* DMA Device ID's follow */
+enum {
+	DMA_ID_EXT = 0,		/* External request with DREQn */
+	DMA_ID_NAND,		/* NAND DMA request */
+	DMA_ID_BCH_ENC,		/* BCH Encoding DMA request */
+	DMA_ID_BCH_DEC,		/* BCH Decoding DMA request */
+	DMA_ID_AUTO,		/* Auto-request */
+//	DMA_ID_TSSI_RX,		/* TSSI receive fifo full request */
+	DMA_ID_UART3_TX,	/* UART3 transmit-fifo-empty request */
+	DMA_ID_UART3_RX,	/* UART3 receve-fifo-full request */
+	DMA_ID_UART2_TX,	/* UART2 transmit-fifo-empty request */
+	DMA_ID_UART2_RX,	/* UART2 receve-fifo-full request */
+	DMA_ID_UART1_TX,	/* UART1 transmit-fifo-empty request */
+	DMA_ID_UART1_RX,	/* UART1 receve-fifo-full request */
+	DMA_ID_UART0_TX,	/* UART0 transmit-fifo-empty request */
+	DMA_ID_UART0_RX,	/* UART0 receve-fifo-full request */
+	DMA_ID_SSI0_TX,		/* SSI0 transmit-fifo-full request */
+	DMA_ID_SSI0_RX,		/* SSI0 receive-fifo-empty request */
+	DMA_ID_AIC_TX,		/* AIC transmit-fifo-full request */
+	DMA_ID_AIC_RX,		/* AIC receive-fifo-empty request */
+	DMA_ID_MSC0_TX,		/* MSC0 transmit-fifo-full request */
+	DMA_ID_MSC0_RX,		/* MSC0 receive-fifo-empty request */
+	DMA_ID_TCU_OVERFLOW,	/* TCU channel n overflow interrupt */
+	DMA_ID_SADC,		/* SADC transfer request */
+	DMA_ID_MSC1_TX,		/* MSC1 transmit-fifo-full request */
+	DMA_ID_MSC1_RX,		/* MSC1 receive-fifo-empty request */
+	DMA_ID_SSI1_TX,		/* SSI1 transmit-fifo-full request */
+	DMA_ID_SSI1_RX,		/* SSI1 receive-fifo-empty request */
+	DMA_ID_PCM_TX,		/* PM transmit-fifo-full request */
+	DMA_ID_PCM_RX,		/* PM receive-fifo-empty request */
+	DMA_ID_RAW_SET,
+	DMA_ID_MAX
+};
+
+/* DMA modes, simulated by sw */
+#define DMA_MODE_READ	0x0  /* I/O to memory, no autoinit, increment, single mode */
+#define DMA_MODE_WRITE	0x1  /* memory to I/O, no autoinit, increment, single mode */
+#define DMA_AUTOINIT	0x2
+#define DMA_MODE_MASK	0x3
+
+struct jz_dma_chan {
+	int dev_id;	/* DMA ID: this channel is allocated if >=0, free otherwise */ 
+	unsigned int io;        /* DMA channel number */
+	const char *dev_str;    /* string describes the DMA channel */
+	int irq;                /* DMA irq number */
+	void *irq_dev;          /* DMA private device structure */
+	unsigned int fifo_addr; /* physical fifo address of the requested device */
+	unsigned int cntl;	/* DMA controll */
+	unsigned int mode;      /* DMA configuration */
+	unsigned int source;    /* DMA request source */
+};
+
+extern struct jz_dma_chan jz_dma_table[];
+
+
+#define DMA_8BIT_RX_CMD					\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_8BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_8BIT_TX_CMD					\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_8BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_32_32BYTE_TX_CMD		       	\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+#define DMA_AIC_32_16BYTE_TX_CMD		       	\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_32_16BYTE_RX_CMD			\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_TX_CMD_UC			\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+extern int jz_request_dma(int dev_id,
+			  const char *dev_str,
+			  irqreturn_t (*irqhandler)(int, void *),
+			  unsigned long irqflags,
+			  void *irq_dev_id);
+extern void jz_free_dma(unsigned int dmanr);
+
+extern int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			      int length, int *eof, void *data);
+extern void dump_jz_dma_channel(unsigned int dmanr);
+
+extern void enable_dma(unsigned int dmanr);
+extern void disable_dma(unsigned int dmanr);
+extern void set_dma_addr(unsigned int dmanr, unsigned int phyaddr);
+extern void set_dma_count(unsigned int dmanr, unsigned int bytecnt);
+extern void set_dma_mode(unsigned int dmanr, unsigned int mode);
+extern void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern void jz_set_dma_src_width(int dmanr, int nbit);
+extern void jz_set_dma_dest_width(int dmanr, int nbit);
+extern void jz_set_dma_block_size(int dmanr, int nbyte);
+extern unsigned int get_dma_residue(unsigned int dmanr);
+
+extern spinlock_t  dma_spin_lock;
+
+static __inline__ unsigned long claim_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_spin_lock, flags);
+	return flags;
+}
+
+static __inline__ void release_dma_lock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&dma_spin_lock, flags);
+}
+
+/* Clear the 'DMA Pointer Flip Flop'.
+ * Write 0 for LSB/MSB, 1 for MSB/LSB access.
+ */
+#define clear_dma_ff(channel)
+
+static __inline__ struct jz_dma_chan *get_dma_chan(unsigned int dmanr)
+{
+	if (dmanr > MAX_DMA_NUM
+	    || jz_dma_table[dmanr].dev_id < 0)
+		return NULL;
+	return &jz_dma_table[dmanr];
+}
+
+static __inline__ int dma_halted(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 1;
+	return  __dmac_channel_transmit_halt_detected(dmanr) ? 1 : 0;
+}
+
+static __inline__ unsigned int get_dma_mode(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	return chan->mode;
+}
+
+static __inline__ void clear_dma_done(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+}
+
+static __inline__ void clear_dma_halt(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT);
+	REG_DMAC_DMACR((chan->io)/HALF_DMA_NUM) &= ~(DMAC_DMACR_HLT);
+}
+
+static __inline__ void clear_dma_flag(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+	REG_DMAC_DMACR((chan->io)/HALF_DMA_NUM) &= ~(DMAC_DMACR_HLT | DMAC_DMACR_AR);
+}
+
+static __inline__ void set_dma_page(unsigned int dmanr, char pagenr)
+{
+}
+
+static __inline__ unsigned int get_dma_done_status(unsigned int dmanr)
+{
+	unsigned long dccsr;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	dccsr = REG_DMAC_DCCSR(chan->io);
+	return dccsr & (DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+}
+
+static __inline__ int get_dma_done_irq(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return -1;
+	return chan->irq;
+}
+
+#endif  /* __ASM_JZ4750D_DMA_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/i2c.h b/arch/mips/include/asm/mach-jz4750d/i2c.h
new file mode 100644
index 0000000..ccd1c97
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/i2c.h
@@ -0,0 +1,70 @@
+/*
+ * linux/arch/mips/jz4750/i2c.c
+ *
+ * JZ4750 I2C Simple Driver.
+ *
+ * Copyright (c) 2005-2010  Ingenic Semiconductor Inc.
+ * Author: River <zwang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef __I_I2C_H__
+#define __I_I2C_H__
+
+enum {
+	I_I2C_IO_DIR_READ = 0,
+	I_I2C_IO_DIR_WRITE,	
+};
+
+enum {
+	I_I2C_CAP_SEQ_READ = (1 << 0),
+	I_I2C_CAP_SEQ_WRITE = (1 << 1),
+	I_I2C_CAP_16BIT_OFFSET_MSB = (1 << 2),
+	I_I2C_CAP_16BIT_OFFSET_LSB = (1 << 3),
+};
+
+enum {
+	I_I2C_FLAG_STOP_BEFORE_RESTART = (1 << 0),
+};
+
+struct i_i2c_timing {
+	int id;
+
+	unsigned long clk;
+	unsigned long timeout;
+
+	unsigned long t_wr;
+};
+
+struct i_i2c_dev {
+	int id;
+	
+	char *name;
+	
+	unsigned int address;
+
+	spinlock_t lock;
+
+	unsigned long cap;
+	unsigned long flags;
+
+	unsigned long size;
+
+	unsigned int read_size;
+	unsigned int write_size;
+	
+	int timing_id;
+	struct i_i2c_timing *timing;
+};
+
+int i_i2c_read_dev(struct i_i2c_dev *dev, off_t off, void *buf, size_t count);
+
+int i_i2c_write_dev(struct i_i2c_dev *dev, off_t off, void *buf, size_t count);
+
+int i_i2c_init_dev(struct i_i2c_dev *dev);
+
+#endif
diff --git a/arch/mips/include/asm/mach-jz4750d/jz4750d.h b/arch/mips/include/asm/mach-jz4750d/jz4750d.h
new file mode 100644
index 0000000..4d117ac
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/jz4750d.h
@@ -0,0 +1,44 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/jz4750d.h
+ *
+ *  JZ4750 common definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750_H__
+#define __ASM_JZ4750_H__
+
+#include <asm/mach-jz4750d/regs.h>
+#include <asm/mach-jz4750d/ops.h>
+#include <asm/mach-jz4750d/dma.h>
+#include <asm/mach-jz4750d/misc.h>
+#include <asm/mach-jz4750d/platform.h>
+
+/*------------------------------------------------------------------
+ * Platform definitions
+ */
+#define JZ_SOC_NAME "JZ4750D"
+
+#ifdef CONFIG_JZ4750D_CETUS
+#include <asm/mach-jz4750d/board-cetus.h>
+#endif
+/* Add other platform definition here ... */
+
+
+/*------------------------------------------------------------------
+ * Follows are related to platform definitions
+ */
+
+#include <asm/mach-jz4750d/clock.h>
+#include <asm/mach-jz4750d/serial.h>
+#include <asm/mach-jz4750d/i2c.h>
+#include <asm/mach-jz4750d/spi.h>
+
+#endif /* __ASM_JZ4750_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/misc.h b/arch/mips/include/asm/mach-jz4750d/misc.h
new file mode 100644
index 0000000..cd0b13c
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/misc.h
@@ -0,0 +1,44 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/misc.h
+ *
+ *  Ingenic's JZ4750D common include.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750D_MISC_H__
+#define __ASM_JZ4750D_MISC_H__
+
+/*==========================================================
+ * I2C
+ *===========================================================*/
+
+#define I2C_EEPROM_DEV	0xA	/* b'1010 */
+#define I2C_RTC_DEV	0xD	/* b'1101 */
+#define DIMM0_SPD_ADDR	0
+#define DIMM1_SPD_ADDR	1
+#define DIMM2_SPD_ADDR	2
+#define DIMM3_SPD_ADDR	3
+#define JZ_HCI_ADDR	7
+
+#define DIMM_SPD_LEN	128
+#define JZ_HCI_LEN	512    /* 4K bits E2PROM */
+#define I2C_RTC_LEN	16
+#define HCI_MAC_OFFSET	64
+
+extern void i2c_open(void);
+extern void i2c_close(void);
+extern void i2c_setclk(unsigned int i2cclk);
+
+extern int i2c_read(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+extern int i2c_write(unsigned char device, unsigned char *buf,
+		     unsigned char address, int count);
+
+#endif /* __ASM_JZ4750D_MISC_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/ops.h b/arch/mips/include/asm/mach-jz4750d/ops.h
new file mode 100644
index 0000000..406da65
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/ops.h
@@ -0,0 +1,3452 @@
+
+/*
+ * linux/include/asm-mips/mach-jz4750d/ops.h
+ *
+ * JZ4750D register definition.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __JZ4750D_OPS_H__
+#define __JZ4750D_OPS_H__
+
+/*
+ * Definition of Module Operations
+ */
+
+/***************************************************************************
+ * EMC
+ ***************************************************************************/
+#define is_share_mode() (1)
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+//------------------------------------------------------
+// GPIO Pins Description
+//
+// PORT 0:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		D0		-
+//	1		D1		-
+//	2		D2		-
+//	3		D3		-
+//	4		D4		-
+//	5		D5		-
+//	6		D6		-
+//	7		D7		-
+//	8		D8		-
+//	9		D9		-
+//	10		D10		-
+//	11		D11		-
+//	12		D12		-
+//	13		D13		-
+//	14		D14		-
+//	15		D15		-
+//	16		D16		-
+//	17		D17		-
+//	18		D18		-
+//	19		D19		-
+//	20		D20		-
+//	21		D21		-
+//	22		D22		-
+//	23		D23		-
+//	24		D24		-
+//	25		D25		-
+//	26		D26		-
+//	27		D27		-
+//	28		D28		-
+//	29		D29		-
+//	30		D30		-
+//	31		D31		-
+//
+//------------------------------------------------------
+// PORT 1:
+//
+// PIN/BIT N		FUNC0		FUNC1	       FUNC2         NOTE
+//	0		A0		-              -
+//	1		A1		-              -
+//	2		A2		-              -
+//	3		A3		-              -
+//	4		A4		-              -
+//	5		A5		-              -
+//	6		A6		-              -
+//	7		A7		-              -
+//	8		A8		-              -
+//	9		A9		-              -
+//	10		A10		-              -
+//	11		A11		-              -
+//	12		A12		-              -
+//	13		A13		-              -
+//	14		A14		-              -
+//	15		A15/CLE		CL(unshare)    MSC0_CLK
+//	16		DCS0#		-              -
+//	17		RAS#		-              -
+//	18		CAS#		-              -
+//	19		SDWE#/BUFD#	-              -
+//	20		WE0#		-              -
+//	21		WE1#		-              -
+//	22		WE2#		-              -
+//	23		WE3#		-              -
+//	24		CKO		-	       -              Note1
+//	25		CKE		-              -
+//	26		SSI_CLK	        MSC1_CLK       -
+//	27		SSI_DT		MSC1_D1        -
+//	28		SSI_DR		MSC1_D0        -
+//	29		SSI_CE0#	MSC1_CMD       -
+//	30		SSI_GPC	        MSC1_D2        -
+//	31		SSI_CE1#	MSC1_D3        -
+//
+// Note1: BIT24: it is CKO when chip is reset
+//
+//------------------------------------------------------
+// PORT 2:
+//
+// PIN/BIT N		FUNC0		FUNC1		FUNC2         NOTE
+//	0		SD0		A20             -
+//	1		SD1		A21             -
+//	2		SD2		A22             -
+//	3		SD3		A23             -
+//	4		SD4		A24             -
+//	5		SD5		A25             -
+//	6		SD6		-               -
+//	7		SD7		-               -
+//	8		SD8		TSDI0           -
+//	9		SD9		TSDI1           -
+//	10		SD10		TSDI2           -
+//	11		SD11		TSDI3           -
+//	12		SD12		TSDI4           -
+//	13		SD13		TSDI5           -
+//	14		SD14		TSDI6           -
+//	15		SD15		TSDI7           -
+//	16		A16/ALE		AL(unshare)     MSC0_CMD
+//	17		A17             MSC0_D3         -
+//	18		A18             DREQ            -
+//	19		A19             DACK            -
+//	20		WAIT#		-		-             Note2
+//	21		CS1#		-               - 
+//	22		CS2#		-               -
+//	23		CS3#		-               -
+//	24		CS4#		-               -
+//	25		RD#		-               -
+//	26		WR#		-               -
+//	27		FRB#		-		-             Note3
+//	28		FRE#		MSC0_D0         -
+//	29		FWE#		MSC0_D1         -
+//	30		-       	-		-             Note4
+//	31		-       	-		-             Note5
+//
+// Note2: BIT20: it is WIAT# pin when chip is reset
+//
+// Note3: BIT27: when NAND is used, it should connect to NANF FRB#.
+//
+// Note4: BIT30: it is BOOT_SEL0 which would be set as input without pulling when chip is reset.
+//
+// Note5: BIT31: it is BOOT_SEL1 which would be set as input without pulling when chip is reset.
+//
+//------------------------------------------------------
+// PORT 3:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		LCD_B2		-
+//	1		LCD_B3		-
+//	2		LCD_B4		-
+//	3		LCD_B5		-
+//	4		LCD_B6		-
+//	5		LCD_B7		-
+//	6		LCD_G2		-
+//	7		LCD_G3		-
+//	8		LCD_G4		-
+//	9		LCD_G5		-
+//	10		LCD_G6		-
+//	11		LCD_G7		-
+//	12		LCD_R2		-
+//	13		LCD_R3		-
+//	14		LCD_R4		-
+//	15		LCD_R5		-
+//	16		LCD_R6		-
+//	17		LCD_R7		-
+//	18		LCD_PCLK	-
+//	19		LCD_HSYNC	-
+//	20		LCD_VSYNC	-
+//	21		LCD_DE		-
+//	22		LCD_CLS		LCD_R1
+//	23		LCD_SPL		LCD_G0
+//	24		LCD_PS		LCD_G1
+//	25		LCD_REV		LCD_B1
+//	26		LCD_B0   	-
+//	27		LCD_R0		-
+//	28		UART0_RXD	TSCLK
+//	29		UART0_TXD	TSSTR
+//	30		UART0_CTS	TSFRM
+//	31		UART0_RTS	TSFAIL
+//
+//------------------------------------------------------
+// PORT 4:
+//
+// PIN/BIT N		FUNC0		FUNC1	       FUNC2         NOTE
+//	0		CIM_D0		TSDI0          -
+//	1		CIM_D1		TSDI1          -
+//	2		CIM_D2		TSDI2          -
+//	3		CIM_D3		TSDI3          -
+//	4		CIM_D4		TSDI4          -
+//	5		CIM_D5		TSDI5          -
+//	6		CIM_D6		TSDI6          -
+//	7		CIM_D7		TSDI7          -
+//	8		CIM_MCLK	TSFAIL         -
+//	9		CIM_PCLK	TSCLK          -
+//	10		CIM_VSYNC	TSSTR          -
+//	11		CIM_HSYNC	TSFRM          -
+//	12		I2C_SDA		-              -
+//	13		I2C_SCK		-              -
+//	18		SDATO           -              -
+//	19		SDATI           -              -
+//	20		PWM0		-              -
+//	22		PWM2		SYNC           -
+//	23		PWM3		UART1_RxD      BCLK
+//	24		PWM4		-              -
+//	25		PWM5		UART1_TxD      SCLK_RSTN
+//	28		DCS1#		-              -
+//	29		-        	-              -              Note6
+//	30		WKUP		-	       -              Note7
+//	31		-		-	       -              Note8
+//
+// Note6: BIT29: it is BOOT_SEL2 which would be set as input without pulling when chip is reset.
+// Note7: BIT30: it is only used as input and interrupt, and with no pull-up and pull-down
+// Note8: BIT31: it is used to select the function of UART or JTAG set by PESEL[31]
+//        PESEL[31] = 0, select JTAG function
+//        PESEL[31] = 1, select UART function
+//
+//------------------------------------------------------
+// PORT 5:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	10		SSI_CLK		-
+//	11	        SSI_DT		PWM1
+//	12		SSI_DR		-
+//	13		SSI_CE0#	-
+//	14		SSI_GPC 	-
+//	15		SSI_CE2#	-
+//
+//////////////////////////////////////////////////////////
+
+/*----------------------------------------------------------------
+ * p is the port number (0,1,2,3,4,5)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-127), regardless of the port
+ */
+
+//-------------------------------------------
+// Function Pins Mode
+
+#define __gpio_as_func0(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func1(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func2(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_32bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+} while (0)
+
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ * !!!!DCS1#
+ */
+#define __gpio_as_sdram_x2_32bit()		\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+	REG_GPIO_PXFUNS(4) = 0x10000000;	\
+	REG_GPIO_PXSELC(4) = 0x10000000;	\
+	REG_GPIO_PXPES(4) = 0x10000000;		\
+} while (0)
+
+/*
+ * D0 ~ D15, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_16bit()						\
+do {								        \
+		/* 32/16-bit data normal order */			\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;				\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;				\
+	REG_GPIO_PXPES(0) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;				\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;				\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;					\
+} while (0)
+
+/*
+ * D0 ~ D7, CS1#, CLE, ALE, FRE#, FWE#, FRB#, RDWE#/BUFD#
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nand_8bit(n)						\
+do {		              						\
+	/* 32/16-bit data bus */					\
+	REG_GPIO_PXFUNS(0) = 0x000000ff; /* D0~D7 */			\
+	REG_GPIO_PXSELC(0) = 0x000000ff;				\
+	REG_GPIO_PXPES(0) = 0x000000ff;					\
+	REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(A15) */			\
+	REG_GPIO_PXSELC(1) = 0x00008000;				\
+	REG_GPIO_PXPES(1) = 0x00008000;					\
+	REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(A16) */			\
+	REG_GPIO_PXSELC(2) = 0x00010000;				\
+	REG_GPIO_PXPES(2) = 0x00010000;					\
+									\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+        REG_GPIO_PXFUNS(1) = 0x00080000; /* RDWE#/BUFD# */		\
+        REG_GPIO_PXSELC(1) = 0x00080000;				\
+	REG_GPIO_PXPES(1) = 0x00080000;					\
+	REG_GPIO_PXFUNS(2) = 0x30000000; /* FRE#, FWE# */		\
+	REG_GPIO_PXSELC(2) = 0x30000000;				\
+	REG_GPIO_PXPES(2) = 0x30000000;					\
+	REG_GPIO_PXFUNC(2) = 0x08000000; /* FRB#(input) */		\
+	REG_GPIO_PXSELC(2) = 0x08000000;				\
+	REG_GPIO_PXDIRC(2) = 0x08000000;				\
+	REG_GPIO_PXPES(2) = 0x08000000;					\
+} while (0)
+
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D7
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nor_8bit(n)						\
+do {								        \
+	/* 32/16-bit data bus */					\
+	REG_GPIO_PXFUNS(0) = 0x000000ff;				\
+	REG_GPIO_PXSELC(0) = 0x000000ff;				\
+	REG_GPIO_PXPES(0) = 0x000000ff;					\
+									\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff; /* A0~A15 */			\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;				\
+	REG_GPIO_PXPES(1) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(2) = 0x06110007; /* RD#, WR#, WAIT#, A20~A22 */	\
+	REG_GPIO_PXSELC(2) = 0x06110007;				\
+	REG_GPIO_PXPES(2) = 0x06110007;					\
+	REG_GPIO_PXFUNS(2) = 0x000e0000; /* A17~A19 */	        	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;				\
+	REG_GPIO_PXPES(2) = 0x000e0000;					\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D15
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nor_16bit(n)						\
+do {	               							\
+	/* 32/16-bit data normal order */				\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;				\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;				\
+	REG_GPIO_PXPES(0) = 0x0000ffff;					\
+									\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff; /* A0~A15 */			\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;				\
+	REG_GPIO_PXPES(1) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(2) = 0x06110007; /* RD#, WR#, WAIT#, A20~A22 */	\
+	REG_GPIO_PXSELC(2) = 0x06110007;				\
+	REG_GPIO_PXPES(2) = 0x06110007;					\
+	REG_GPIO_PXFUNS(2) = 0x000e0000; /* A17~A19 */	        	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;				\
+	REG_GPIO_PXPES(2) = 0x000e0000;					\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD
+ */
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x30000000;	\
+	REG_GPIO_PXSELC(3) = 0x30000000;	\
+	REG_GPIO_PXPES(3) = 0x30000000;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD, UART0_CTS, UART0_RTS
+ */
+#define __gpio_as_uart0_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xf0000000;	\
+	REG_GPIO_PXSELC(3) = 0xf0000000;	\
+	REG_GPIO_PXPES(3) = 0xf0000000;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD
+ */
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_PXTRGC(4) = 0x02800000;	\
+	REG_GPIO_PXFUNS(4) = 0x02800000;	\
+	REG_GPIO_PXSELS(4) = 0x02800000;	\
+	REG_GPIO_PXPES(4) = 0x02800000;		\
+} while (0)
+
+/*
+ * TSCLK, TSSTR, TSFRM, TSFAIL, TSDI0~7
+ */
+#define __gpio_as_tssi()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x0000ff00;	\
+	REG_GPIO_PXSELS(2) = 0x0000ff00;	\
+	REG_GPIO_PXPES(2) = 0x0000ff00;		\
+	REG_GPIO_PXFUNS(3) = 0xf0000000;	\
+	REG_GPIO_PXSELS(3) = 0xf0000000;	\
+	REG_GPIO_PXPES(3) = 0xf0000000;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D7, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003c00ff;	\
+	REG_GPIO_PXTRGC(3) = 0x003c00ff;	\
+	REG_GPIO_PXSELC(3) = 0x003c00ff;	\
+	REG_GPIO_PXPES(3) = 0x003c00ff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D15, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003cffff;	\
+	REG_GPIO_PXTRGC(3) = 0x003cffff;	\
+	REG_GPIO_PXSELC(3) = 0x003cffff;	\
+	REG_GPIO_PXPES(3) = 0x003cffff;		\
+} while (0)
+
+/*
+ * LCD_R2~LCD_R7, LCD_G2~LCD_G7, LCD_B2~LCD_B7,
+ * LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003fffff;	\
+	REG_GPIO_PXTRGC(3) = 0x003fffff;	\
+	REG_GPIO_PXSELC(3) = 0x003fffff;	\
+	REG_GPIO_PXPES(3) = 0x003fffff;		\
+} while (0)
+
+/*
+ * LCD_R0~LCD_R7, LCD_G0~LCD_G7, LCD_B0~LCD_B7,
+ * LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_24bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x0fffffff;	\
+	REG_GPIO_PXTRGC(3) = 0x0fffffff;	\
+	REG_GPIO_PXSELC(3) = 0x0c3fffff;	\
+	REG_GPIO_PXSELS(3) = 0x03c00000;	\
+	REG_GPIO_PXPES(3) = 0x0fffffff;		\
+} while (0)
+
+/*
+ *  LCD_CLS, LCD_SPL, LCD_PS, LCD_REV
+ */
+#define __gpio_as_lcd_special()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x03C00000;	\
+	REG_GPIO_PXSELC(3) = 0x03C00000;	\
+	REG_GPIO_PXPES(3)  = 0x03C00000;	\
+} while (0)
+
+/*
+ * CIM_D0~CIM_D7, CIM_MCLK, CIM_PCLK, CIM_VSYNC, CIM_HSYNC
+ */
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00000fff;	\
+	REG_GPIO_PXSELC(4) = 0x00000fff;	\
+	REG_GPIO_PXPES(4)  = 0x00000fff;	\
+} while (0)
+
+/* 
+ * SDATO, SDATI, BCLK, SYNC, SCLK_RSTN(gpio sepc) or
+ * SDATA_OUT, SDATA_IN, BIT_CLK, SYNC, SCLK_RESET(aic spec)
+ */
+#define __gpio_as_aic()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x16c00000;	\
+	REG_GPIO_PXTRGC(4) = 0x02c00000;	\
+	REG_GPIO_PXTRGS(4) = 0x14000000;	\
+	REG_GPIO_PXSELC(4) = 0x14c00000;	\
+	REG_GPIO_PXSELS(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4)  = 0x16c00000;	\
+} while (0)
+
+/*
+ * MSC0_CMD, MSC0_CLK, MSC0_D0 ~ MSC0_D3
+ */
+#define __gpio_as_msc0_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0x00008000;	\
+	REG_GPIO_PXTRGS(1) = 0x00008000;	\
+	REG_GPIO_PXSELC(1) = 0x00008000;	\
+	REG_GPIO_PXPES(1)  = 0x00008000;	\
+	REG_GPIO_PXFUNS(2) = 0x38030000;	\
+	REG_GPIO_PXTRGS(2) = 0x00010000;	\
+	REG_GPIO_PXTRGC(2) = 0x38020000;	\
+	REG_GPIO_PXSELC(2) = 0x08010000;	\
+	REG_GPIO_PXSELS(2) = 0x30020000;	\
+	REG_GPIO_PXPES(2)  = 0x38030000;	\
+} while (0)
+
+
+/*
+ * MSC1_CMD, MSC1_CLK, MSC1_D0 ~ MSC1_D3
+ */
+#define __gpio_as_msc1_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0xfc000000;	\
+	REG_GPIO_PXTRGC(1) = 0xfc000000;	\
+	REG_GPIO_PXSELS(1) = 0xfc000000;	\
+	REG_GPIO_PXPES(1)  = 0xfc000000;	\
+} while (0)
+
+#define __gpio_as_msc 	__gpio_as_msc0_4bit /* default as msc0 4bit */
+#define __gpio_as_msc0 	__gpio_as_msc0_4bit /* msc0 default as 4bit */
+#define __gpio_as_msc1 	__gpio_as_msc1_4bit /* msc1 only support 4bit */
+
+/*
+ * SSI_CE0, SSI_CE1, SSI_GPC, SSI_CLK, SSI_DT, SSI_DR
+ */
+#define __gpio_as_ssi()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0xfc000000;	\
+	REG_GPIO_PXTRGC(1) = 0xfc000000;	\
+	REG_GPIO_PXSELC(1) = 0xfc000000;	\
+	REG_GPIO_PXPES(1)  = 0xfc000000;	\
+} while (0)
+
+#define __gpio_as_ssi_x()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0x1c000000;	\
+	REG_GPIO_PXTRGC(1) = 0x1c000000;	\
+	REG_GPIO_PXSELC(1) = 0x1c000000;	\
+	REG_GPIO_PXPES(1)  = 0x1c000000;	\
+} while (0)
+/*
+ * SSI_CE0, SSI_CE2, SSI_GPC, SSI_CLK, SSI_DT, SSI1_DR
+ */
+#define __gpio_as_ssi_1()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x0000fc00;	\
+	REG_GPIO_PXTRGC(5) = 0x0000fc00;	\
+	REG_GPIO_PXSELC(5) = 0x0000fc00;	\
+	REG_GPIO_PXPES(5)  = 0x0000fc00;	\
+} while (0)
+
+/*
+ * I2C_SCK, I2C_SDA
+ */
+#define __gpio_as_i2c()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00003000;	\
+	REG_GPIO_PXSELC(4) = 0x00003000;	\
+	REG_GPIO_PXPES(4)  = 0x00003000;	\
+} while (0)
+
+/*
+ * PWM0
+ */
+#define __gpio_as_pwm0()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00100000;	\
+	REG_GPIO_PXSELC(4) = 0x00100000;	\
+	REG_GPIO_PXPES(4) = 0x00100000;		\
+} while (0)
+
+/*
+ * PWM1
+ */
+#define __gpio_as_pwm1()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000800;	\
+	REG_GPIO_PXSELC(5) = 0x00000800;	\
+	REG_GPIO_PXPES(5) = 0x00000800;		\
+} while (0)
+
+/*
+ * PWM2
+ */
+#define __gpio_as_pwm2()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00400000;	\
+	REG_GPIO_PXSELC(4) = 0x00400000;	\
+	REG_GPIO_PXPES(4) = 0x00400000;		\
+} while (0)
+
+/*
+ * PWM3
+ */
+#define __gpio_as_pwm3()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00800000;	\
+	REG_GPIO_PXSELC(4) = 0x00800000;	\
+	REG_GPIO_PXPES(4) = 0x00800000;		\
+} while (0)
+
+/*
+ * PWM4
+ */
+#define __gpio_as_pwm4()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x01000000;	\
+	REG_GPIO_PXSELC(4) = 0x01000000;	\
+	REG_GPIO_PXPES(4) = 0x01000000;		\
+} while (0)
+
+/*
+ * PWM5
+ */
+#define __gpio_as_pwm5()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x02000000;	\
+	REG_GPIO_PXSELC(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4) = 0x02000000;		\
+} while (0)
+
+/*
+ * n = 0 ~ 5
+ */
+#define __gpio_as_pwm(n)	__gpio_as_pwm##n()
+
+/*
+ * DREQ
+ */
+#define __gpio_as_dreq()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x00040000;	\
+	REG_GPIO_PXSELS(2) = 0x00040000;	\
+	REG_GPIO_PXPES(2) = 0x00040000;		\
+} while (0)
+
+/*
+ * DACK
+ */
+#define __gpio_as_dack()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x00080000;	\
+	REG_GPIO_PXSELS(2) = 0x00080000;	\
+	REG_GPIO_PXPES(2) = 0x00080000;		\
+} while (0)
+
+/*
+ * GPIO or Interrupt Mode
+ */
+#define __gpio_get_port(p)	(REG_GPIO_PXPIN(p))
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRS(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRC(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_pin(n)			\
+({						\
+	unsigned int p, o, v;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (__gpio_get_port(p) & (1 << o))	\
+		v = 1;				\
+	else					\
+		v = 0;				\
+	v;					\
+})
+
+#define __gpio_as_irq_high_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_low_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_rise_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_fall_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_irq()			\
+({						\
+	unsigned int p, i, tmp, v = 0;		\
+	for (p = 3; p >= 0; p--) {		\
+		tmp = REG_GPIO_PXFLG(p);	\
+		for (i = 0; i < 32; i++)	\
+			if (tmp & (1 << i))	\
+				v = (32*p + i);	\
+	}					\
+	v;					\
+})
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_PXFLG((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPEC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPES(p) = (1 << o);		\
+} while (0)
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_get_pllm() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLM_MASK) >> CPM_CPPCR_PLLM_BIT)
+#define __cpm_get_plln() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLN_MASK) >> CPM_CPPCR_PLLN_BIT)
+#define __cpm_get_pllod() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLOD_MASK) >> CPM_CPPCR_PLLOD_BIT)
+
+#define __cpm_get_cdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_CDIV_MASK) >> CPM_CPCCR_CDIV_BIT)
+#define __cpm_get_hdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_HDIV_MASK) >> CPM_CPCCR_HDIV_BIT)
+#define __cpm_get_pdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_PDIV_MASK) >> CPM_CPCCR_PDIV_BIT)
+#define __cpm_get_mdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT)
+#define __cpm_get_h1div() \
+	((REG_CPM_CPCCR & CPM_CPCCR_H1DIV_MASK) >> CPM_CPCCR_H1DIV_BIT)
+#define __cpm_get_udiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_UDIV_MASK) >> CPM_CPCCR_UDIV_BIT)
+#define __cpm_get_i2sdiv() \
+	((REG_CPM_I2SCDR & CPM_I2SCDR_I2SDIV_MASK) >> CPM_I2SCDR_I2SDIV_BIT)
+#define __cpm_get_pixdiv() \
+	((REG_CPM_LPCDR & CPM_LPCDR_PIXDIV_MASK) >> CPM_LPCDR_PIXDIV_BIT)
+#define __cpm_get_mscdiv(n) \
+	((REG_CPM_MSCCDR(n) & CPM_MSCCDR_MSCDIV_MASK) >> CPM_MSCCDR_MSCDIV_BIT)
+#define __cpm_get_uhcdiv() \
+	((REG_CPM_UHCCDR & CPM_UHCCDR_UHCDIV_MASK) >> CPM_UHCCDR_UHCDIV_BIT)
+#define __cpm_get_ssidiv() \
+	((REG_CPM_SSICDR & CPM_SSICDR_SSIDIV_MASK) >> CPM_SSICDR_SSIDIV_BIT)
+#define __cpm_get_pcmdiv(v) \
+	((REG_CPM_PCMCDR & CPM_PCMCDR_PCMCD_MASK) >> CPM_PCMCDR_PCMCD_BIT)
+
+#define __cpm_set_cdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_CDIV_MASK) | ((v) << (CPM_CPCCR_CDIV_BIT)))
+#define __cpm_set_hdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_HDIV_MASK) | ((v) << (CPM_CPCCR_HDIV_BIT)))
+#define __cpm_set_pdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_PDIV_MASK) | ((v) << (CPM_CPCCR_PDIV_BIT)))
+#define __cpm_set_mdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_MDIV_MASK) | ((v) << (CPM_CPCCR_MDIV_BIT)))
+#define __cpm_set_h1div(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_H1DIV_MASK) | ((v) << (CPM_CPCCR_H1DIV_BIT)))
+#define __cpm_set_udiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_UDIV_MASK) | ((v) << (CPM_CPCCR_UDIV_BIT)))
+#define __cpm_set_i2sdiv(v) \
+	(REG_CPM_I2SCDR = (REG_CPM_I2SCDR & ~CPM_I2SCDR_I2SDIV_MASK) | ((v) << (CPM_I2SCDR_I2SDIV_BIT)))
+#define __cpm_set_pixdiv(v) \
+	(REG_CPM_LPCDR = (REG_CPM_LPCDR & ~CPM_LPCDR_PIXDIV_MASK) | ((v) << (CPM_LPCDR_PIXDIV_BIT)))
+#define __cpm_set_mscdiv(n, v) \
+	(REG_CPM_MSCCDR(n) = (REG_CPM_MSCCDR(n) & ~CPM_MSCCDR_MSCDIV_MASK) | ((v) << (CPM_MSCCDR_MSCDIV_BIT)))
+#define __cpm_set_uhcdiv(v) \
+	(REG_CPM_UHCCDR = (REG_CPM_UHCCDR & ~CPM_UHCCDR_UHCDIV_MASK) | ((v) << (CPM_UHCCDR_UHCDIV_BIT)))
+#define __cpm_set_ssidiv(v) \
+	(REG_CPM_SSICDR = (REG_CPM_SSICDR & ~CPM_SSICDR_SSIDIV_MASK) | ((v) << (CPM_SSICDR_SSIDIV_BIT)))
+#define __cpm_set_pcmdiv(v) \
+	(REG_CPM_PCMCDR = (REG_CPM_PCMCDR & ~CPM_PCMCDR_PCMCD_MASK) | ((v) << (CPM_PCMCDR_PCMCD_BIT)))
+
+#define __cpm_select_pcmclk_pll() 	(REG_CPM_PCMCDR |= CPM_PCMCDR_PCMS)
+#define __cpm_select_pcmclk_exclk() 	(REG_CPM_PCMCDR &= ~CPM_PCMCDR_PCMS)
+#define __cpm_select_tveclk_exclk()	(REG_CPM_LPCDR |= CPM_CPCCR_LSCS)
+#define __cpm_select_tveclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LSCS)
+#define __cpm_select_pixclk_lcd()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LTCS)
+#define __cpm_select_pixclk_tve()	(REG_CPM_LPCDR |= CPM_LPCDR_LTCS)
+#define __cpm_select_i2sclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_I2CS)
+#define __cpm_select_i2sclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_I2CS)
+#define __cpm_select_usbclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_UCS)
+#define __cpm_select_usbclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_UCS)
+
+#define __cpm_enable_cko()
+#define __cpm_exclk_direct()		(REG_CPM_CPCCR &= ~CPM_CPCCR_ECS)
+#define __cpm_exclk_div2()             	(REG_CPM_CPCCR |= CPM_CPCCR_ECS)
+#define __cpm_enable_pll_change()	(REG_CPM_CPCCR |= CPM_CPCCR_CE)
+#define __cpm_pllout_direct()		(REG_CPM_CPCCR |= CPM_CPCCR_PCS)
+#define __cpm_pllout_div2()		(REG_CPM_CPCCR &= ~CPM_CPCCR_PCS)
+#define __cpm_pll_enable()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLEN)
+
+#define __cpm_pll_is_off()		(REG_CPM_CPPSR & CPM_CPPSR_PLLOFF)
+#define __cpm_pll_is_on()		(REG_CPM_CPPSR & CPM_CPPSR_PLLON)
+#define __cpm_pll_bypass()		(REG_CPM_CPPSR |= CPM_CPPSR_PLLBP)
+
+#define __cpm_get_cclk_doze_duty() \
+	((REG_CPM_LCR & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT)
+#define __cpm_set_cclk_doze_duty(v) \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_DOZE_DUTY_MASK) | ((v) << (CPM_LCR_DOZE_DUTY_BIT)))
+
+#define __cpm_doze_mode()		(REG_CPM_LCR |= CPM_LCR_DOZE_ON)
+#define __cpm_idle_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_IDLE)
+#define __cpm_sleep_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_SLEEP)
+
+#define __cpm_stop_all() 	(REG_CPM_CLKGR = 0x1fffffff)
+#define __cpm_stop_cimram()	(REG_CPM_CLKGR |= CPM_CLKGR_CIMRAM)
+#define __cpm_stop_idct()	(REG_CPM_CLKGR |= CPM_CLKGR_IDCT)
+#define __cpm_stop_db()	        (REG_CPM_CLKGR |= CPM_CLKGR_DB)
+#define __cpm_stop_me()	        (REG_CPM_CLKGR |= CPM_CLKGR_ME)
+#define __cpm_stop_mc()	        (REG_CPM_CLKGR |= CPM_CLKGR_MC)
+#define __cpm_stop_tve()        (REG_CPM_CLKGR |= CPM_CLKGR_TVE)
+#define __cpm_stop_tssi()       (REG_CPM_CLKGR |= CPM_CLKGR_TSSI)
+#define __cpm_stop_owi()        (REG_CPM_CLKGR |= CPM_CLKGR_OWI)
+#define __cpm_stop_pcm()        (REG_CPM_CLKGR |= CPM_CLKGR_PCM)
+#define __cpm_stop_uart3()	(REG_CPM_CLKGR |= CPM_CLKGR_UART3)
+#define __cpm_stop_uart2()	(REG_CPM_CLKGR |= CPM_CLKGR_UART2)
+#define __cpm_stop_uart1()	(REG_CPM_CLKGR |= CPM_CLKGR_UART1)
+#define __cpm_stop_uhc()	(REG_CPM_CLKGR |= CPM_CLKGR_UHC)
+#define __cpm_stop_ipu()	(REG_CPM_CLKGR |= CPM_CLKGR_IPU)
+#define __cpm_stop_dmac()	(REG_CPM_CLKGR |= CPM_CLKGR_DMAC)
+#define __cpm_stop_udc()	(REG_CPM_CLKGR |= CPM_CLKGR_UDC)
+#define __cpm_stop_lcd()	(REG_CPM_CLKGR |= CPM_CLKGR_LCD)
+#define __cpm_stop_cim()	(REG_CPM_CLKGR |= CPM_CLKGR_CIM)
+#define __cpm_stop_sadc()	(REG_CPM_CLKGR |= CPM_CLKGR_SADC)
+#define __cpm_stop_msc(n)	(REG_CPM_CLKGR |= CPM_CLKGR_MSC##n)
+#define __cpm_stop_aic1()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC1)
+#define __cpm_stop_aic2()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC2)
+#define __cpm_stop_ssi(n)	(REG_CPM_CLKGR |= CPM_CLKGR_SSI)
+#define __cpm_stop_i2c()	(REG_CPM_CLKGR |= CPM_CLKGR_I2C)
+#define __cpm_stop_rtc()	(REG_CPM_CLKGR |= CPM_CLKGR_RTC)
+#define __cpm_stop_tcu()	(REG_CPM_CLKGR |= CPM_CLKGR_TCU)
+#define __cpm_stop_uart0()	(REG_CPM_CLKGR |= CPM_CLKGR_UART0)
+
+#define __cpm_start_all() 	(REG_CPM_CLKGR = 0x0)
+#define __cpm_start_cimram()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIMRAM)
+#define __cpm_start_idct()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IDCT)
+#define __cpm_start_db()        (REG_CPM_CLKGR &= ~CPM_CLKGR_DB)
+#define __cpm_start_me()        (REG_CPM_CLKGR &= ~CPM_CLKGR_ME)
+#define __cpm_start_mc()        (REG_CPM_CLKGR &= ~CPM_CLKGR_MC)
+#define __cpm_start_tve()        (REG_CPM_CLKGR &= ~CPM_CLKGR_TVE)
+#define __cpm_start_tssi()       (REG_CPM_CLKGR &= ~CPM_CLKGR_TSSI)
+#define __cpm_start_owi()        (REG_CPM_CLKGR &= ~CPM_CLKGR_OWI)
+#define __cpm_start_pcm()        (REG_CPM_CLKGR &= ~CPM_CLKGR_PCM)
+#define __cpm_start_uart3()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART3)
+#define __cpm_start_uart2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART2)
+#define __cpm_start_uart1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART1)
+#define __cpm_start_uhc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UHC)
+#define __cpm_start_ipu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IPU)
+#define __cpm_start_dmac()	(REG_CPM_CLKGR &= ~CPM_CLKGR_DMAC)
+#define __cpm_start_udc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UDC)
+#define __cpm_start_lcd()	(REG_CPM_CLKGR &= ~CPM_CLKGR_LCD)
+#define __cpm_start_cim()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIM)
+#define __cpm_start_sadc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SADC)
+#define __cpm_start_msc(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_MSC##n)
+#define __cpm_start_aic1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC1)
+#define __cpm_start_aic2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC2)
+#define __cpm_start_ssi(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_SSI)
+#define __cpm_start_i2c()	(REG_CPM_CLKGR &= ~CPM_CLKGR_I2C)
+#define __cpm_start_rtc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_RTC)
+#define __cpm_start_tcu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_TCU)
+#define __cpm_start_uart0()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART0)
+
+#define __cpm_get_o1st() \
+	((REG_CPM_OPCR & CPM_OPCR_O1ST_MASK) >> CPM_OPCR_O1ST_BIT)
+#define __cpm_set_o1st(v) \
+	(REG_CPM_OPCR = (REG_CPM_OPCR & ~CPM_OPCR_O1ST_MASK) | ((v) << (CPM_OPCR_O1ST_BIT)))
+#define __cpm_enable_uhcphy()		(REG_CPM_OPCR &= ~CPM_OPCR_UHCPHY_DISABLE)
+#define __cpm_suspend_uhcphy()		(REG_CPM_OPCR |= CPM_OPCR_UHCPHY_DISABLE)
+#define __cpm_enable_udcphy()		(REG_CPM_OPCR |= CPM_OPCR_UDCPHY_ENABLE)
+#define __cpm_suspend_udcphy()		(REG_CPM_OPCR &= ~CPM_OPCR_UDCPHY_ENABLE)
+#define __cpm_enable_osc_in_sleep()	(REG_CPM_OPCR |= CPM_OPCR_OSC_ENABLE)
+#define __cpm_disable_osc_in_sleep()	(REG_CPM_OPCR &= ~CPM_OPCR_OSC_ENABLE)
+#define __cpm_select_rtcclk_rtc()	(REG_CPM_OPCR |= CPM_OPCR_ERCS)
+#define __cpm_select_rtcclk_exclk()	(REG_CPM_OPCR &= ~CPM_OPCR_ERCS)
+
+
+/***************************************************************************
+ * TCU
+ ***************************************************************************/
+// where 'n' is the TCU channel
+#define __tcu_select_extalclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_EXT_EN)
+#define __tcu_select_rtcclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_RTC_EN)
+#define __tcu_select_pclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_PCK_EN)
+#define __tcu_disable_pclk(n) \
+	REG_TCU_TCSR(n) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PCK_EN);
+#define __tcu_select_clk_div1(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1)
+#define __tcu_select_clk_div4(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE4)
+#define __tcu_select_clk_div16(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE16)
+#define __tcu_select_clk_div64(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE64)
+#define __tcu_select_clk_div256(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE256)
+#define __tcu_select_clk_div1024(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1024)
+
+#define __tcu_enable_pwm_output(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_EN)
+#define __tcu_disable_pwm_output(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_EN)
+
+#define __tcu_init_pwm_output_high(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_INITL_HIGH)
+#define __tcu_init_pwm_output_low(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_INITL_HIGH)
+
+#define __tcu_set_pwm_output_shutdown_graceful(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_SD)
+#define __tcu_set_pwm_output_shutdown_abrupt(n)		(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_SD)
+
+#define __tcu_clear_counter_to_zero(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_CNT_CLRZ)
+
+#define __tcu_ost_enabled()		(REG_TCU_TER & TCU_TER_OSTEN)
+#define __tcu_enable_ost()		(REG_TCU_TESR = TCU_TESR_OSTST)
+#define __tcu_disable_ost()		(REG_TCU_TECR = TCU_TECR_OSTCL)
+
+#define __tcu_counter_enabled(n)	(REG_TCU_TER & (1 << (n)))
+#define __tcu_start_counter(n)		(REG_TCU_TESR |= (1 << (n)))
+#define __tcu_stop_counter(n)		(REG_TCU_TECR |= (1 << (n)))
+
+#define __tcu_half_match_flag(n)	(REG_TCU_TFR & (1 << ((n) + 16)))
+#define __tcu_full_match_flag(n)	(REG_TCU_TFR & (1 << (n)))
+#define __tcu_set_half_match_flag(n)	(REG_TCU_TFSR = (1 << ((n) + 16)))
+#define __tcu_set_full_match_flag(n)	(REG_TCU_TFSR = (1 << (n)))
+#define __tcu_clear_half_match_flag(n)	(REG_TCU_TFCR = (1 << ((n) + 16)))
+#define __tcu_clear_full_match_flag(n)	(REG_TCU_TFCR = (1 << (n)))
+#define __tcu_mask_half_match_irq(n)	(REG_TCU_TMSR = (1 << ((n) + 16)))
+#define __tcu_mask_full_match_irq(n)	(REG_TCU_TMSR = (1 << (n)))
+#define __tcu_unmask_half_match_irq(n)	(REG_TCU_TMCR = (1 << ((n) + 16)))
+#define __tcu_unmask_full_match_irq(n)	(REG_TCU_TMCR = (1 << (n)))
+
+#define __tcu_ost_match_flag()		(REG_TCU_TFR & TCU_TFR_OSTFLAG)
+#define __tcu_set_ost_match_flag()	(REG_TCU_TFSR = TCU_TFSR_OSTFST)
+#define __tcu_clear_ost_match_flag()	(REG_TCU_TFCR = TCU_TFCR_OSTFCL)
+#define __tcu_ost_match_irq_masked()	(REG_TCU_TMR & TCU_TMR_OSTMASK)
+#define __tcu_mask_ost_match_irq()	(REG_TCU_TMSR = TCU_TMSR_OSTMST)
+#define __tcu_unmask_ost_match_irq()	(REG_TCU_TMCR = TCU_TMCR_OSTMCL)
+
+#define __tcu_wdt_clock_stopped()	(REG_TCU_TSR & TCU_TSSR_WDTSC)
+#define __tcu_ost_clock_stopped()	(REG_TCU_TSR & TCU_TSR_OST)
+#define __tcu_timer_clock_stopped(n)	(REG_TCU_TSR & (1 << (n)))
+
+#define __tcu_start_wdt_clock()		(REG_TCU_TSCR = TCU_TSSR_WDTSC)
+#define __tcu_start_ost_clock()		(REG_TCU_TSCR = TCU_TSCR_OSTSC)
+#define __tcu_start_timer_clock(n)	(REG_TCU_TSCR = (1 << (n)))
+
+#define __tcu_stop_wdt_clock()		(REG_TCU_TSSR = TCU_TSSR_WDTSC)
+#define __tcu_stop_ost_clock()		(REG_TCU_TSSR = TCU_TSSR_OSTSS)
+#define __tcu_stop_timer_clock(n)	(REG_TCU_TSSR = (1 << (n)))
+
+#define __tcu_get_count(n)		(REG_TCU_TCNT((n)))
+#define __tcu_set_count(n,v)		(REG_TCU_TCNT((n)) = (v))
+#define __tcu_set_full_data(n,v)	(REG_TCU_TDFR((n)) = (v))
+#define __tcu_set_half_data(n,v)	(REG_TCU_TDHR((n)) = (v))
+
+/* TCU2, counter 1, 2*/
+#define __tcu_read_real_value(n)	(REG_TCU_TSTR & (1 << ((n) + 16)))
+#define __tcu_read_false_value(n)	(REG_TCU_TSTR & (1 << ((n) + 16)))
+#define __tcu_counter_busy(n)		(REG_TCU_TSTR & (1 << (n)))
+#define __tcu_counter_ready(n)		(REG_TCU_TSTR & (1 << (n)))
+
+#define __tcu_set_read_real_value(n)	(REG_TCU_TSTSR = (1 << ((n) + 16)))
+#define __tcu_set_read_false_value(n)	(REG_TCU_TSTCR = (1 << ((n) + 16)))
+#define __tcu_set_counter_busy(n)	(REG_TCU_TSTSR = (1 << (n)))
+#define __tcu_set_counter_ready(n)	(REG_TCU_TSTCR = (1 << (n)))
+
+/* ost counter */
+#define __ostcu_set_pwm_output_shutdown_graceful()	(REG_TCU_OSTCSR &= ~TCU_TCSR_PWM_SD)
+#define __ostcu_set_ost_output_shutdown_abrupt()	(REG_TCU_OSTCSR |= TCU_TCSR_PWM_SD)
+#define __ostcu_select_clk_div1() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE1)
+#define __ostcu_select_clk_div4() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE4)
+#define __ostcu_select_clk_div16() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE16)
+#define __ostcu_select_clk_div64() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE64)
+#define __ostcu_select_clk_div256() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE256)
+#define __ostcu_select_clk_div1024() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE1024)
+#define __ostcu_select_rtcclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_RTC_EN)
+#define __ostcu_select_extalclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_EXT_EN)
+#define __ostcu_select_pclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_PCK_EN)
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+#define __wdt_start()			( REG_WDT_TCER |= WDT_TCER_TCEN )
+#define __wdt_stop()			( REG_WDT_TCER &= ~WDT_TCER_TCEN )
+#define __wdt_set_count(v)		( REG_WDT_TCNT = (v) )
+#define __wdt_set_data(v)		( REG_WDT_TDR = (v) )
+
+#define __wdt_select_extalclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_EXT_EN)
+#define __wdt_select_rtcclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_RTC_EN)
+#define __wdt_select_pclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_PCK_EN)
+
+#define __wdt_select_clk_div1() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1)
+#define __wdt_select_clk_div4() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE4)
+#define __wdt_select_clk_div16() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE16)
+#define __wdt_select_clk_div64() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE64)
+#define __wdt_select_clk_div256() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE256)
+#define __wdt_select_clk_div1024() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1024)
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(n, devclk, baud)						\
+  do {											\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLLR) = (devclk / 16 / baud) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_PER) != 0 )
+
+#define __uart_clear_errors(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TDRQ) != 0 )
+
+#define __uart_transmit_end(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TEMT) != 0 )
+
+#define __uart_transmit_char(n, ch) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_TDR) = (ch)
+
+#define __uart_receive_fifo_full(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_ready(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_char(n) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_RDR)
+
+#define __uart_disable_irda() \
+  ( REG8(IRDA_BASE + OFF_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(IRDA_BASE + OFF_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define __dmac_enable_module(m) \
+	( REG_DMAC_DMACR(m) |= DMAC_DMACR_DMAE | DMAC_DMACR_PR_012345 )
+#define __dmac_disable_module(m) \
+	( REG_DMAC_DMACR(m) &= ~DMAC_DMACR_DMAE )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(m,p)			\
+do {							\
+	REG_DMAC_DMACR(m) &= ~DMAC_DMACR_PR_MASK;	\
+	REG_DMAC_DMACR(m) |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_HLT )
+#define __dmac_test_addr_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_AR )
+
+#define __dmac_channel_enable_clk(n) \
+	REG_DMAC_DMACKE((n)/HALF_DMA_NUM) |= 1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM);
+
+#define __dmac_enable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_NDES )
+#define __dmac_disable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_NDES )
+
+#define __dmac_enable_channel(n)                 \
+do {                                             \
+	REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_EN;    \
+} while (0)
+#define __dmac_disable_channel(n)                \
+do {                                             \
+	REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_EN;   \
+} while (0)
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR((n)) & DMAC_DCCSR_EN )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCMD((n)) |= DMAC_DCMD_TIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_TT )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_AR )
+#define __dmac_channel_count_terminated_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_CT )
+#define __dmac_channel_descriptor_invalid_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_INV )
+
+#define __dmac_channel_clear_transmit_halt(n)				\
+	do {								\
+		/* clear both channel halt error and globle halt error */ \
+		REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT;			\
+		REG_DMAC_DMACR(n/HALF_DMA_NUM) &= ~DMAC_DMACR_HLT;	\
+	} while (0)
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TT )
+#define __dmac_channel_clear_address_error(n)				\
+	do {								\
+		REG_DMAC_DDA(n) = 0; /* clear descriptor address register */ \
+		REG_DMAC_DSAR(n) = 0; /* clear source address register */ \
+		REG_DMAC_DTAR(n) = 0; /* clear target address register */ \
+		/* clear both channel addr error and globle address error */ \
+		REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR;			\
+		REG_DMAC_DMACR(n/HALF_DMA_NUM) &= ~DMAC_DMACR_AR;	\
+	} while (0)
+#define __dmac_channel_clear_count_terminated(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_CT )
+#define __dmac_channel_clear_descriptor_invalid(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_INV )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_8BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BYTE;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BYTE;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_RDIL_MASK;		\
+	REG_DMAC_DCMD((n) |= ((v) << DMAC_DCMD_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DAI )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_DAI )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SAI )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_SAI )
+
+#define __dmac_channel_set_doorbell(n)	\
+	(  REG_DMAC_DMADBSR((n)/HALF_DMA_NUM) = (1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+
+#define __dmac_channel_irq_detected(n)  ( REG_DMAC_DMAIPR((n)/HALF_DMA_NUM) & (1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+#define __dmac_channel_ack_irq(n)       ( REG_DMAC_DMAIPR((n)/HALF_DMA_NUM) &= ~(1 <<((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i = 0; i < MAX_DMA_NUM; i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __aic_play_zero()	( REG_AIC_FR &= ~AIC_FR_LSMP )
+#define __aic_play_lastsample()	( REG_AIC_FR |= AIC_FR_LSMP )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+#define __aic_reset_status()          ( REG_AIC_FR & AIC_FR_RST )
+
+#define __aic_reset()                                   \
+do {                                                    \
+        REG_AIC_FR |= AIC_FR_RST;                       \
+} while(0)
+
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo_rx()	( REG_AIC_CR |= AIC_CR_FLUSH_RX )
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH_TX )
+#define __aic_unflush_fifo_rx()	( REG_AIC_CR &= ~AIC_CR_FLUSH_RX )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH_TX )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()   ( REG_AIC_CR |= AIC_CR_M2S )
+#define __aic_disable_mono2stereo()  ( REG_AIC_CR &= ~AIC_CR_M2S )
+#define __aic_enable_byteswap()      ( REG_AIC_CR |= AIC_CR_ENDSW )
+#define __aic_disable_byteswap()     ( REG_AIC_CR &= ~AIC_CR_ENDSW )
+#define __aic_enable_unsignadj()     ( REG_AIC_CR |= AIC_CR_AVSTSU )
+#define __aic_disable_unsignadj()    ( REG_AIC_CR &= ~AIC_CR_AVSTSU )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+ } while (0)
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_msbjustified()   ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+/*#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )*/
+
+#define __i2s_set_oss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+#define __i2s_set_iss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+
+#define __i2s_stop_bitclk()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_bitclk()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+#define __ac97_slot_error_detected()     ( REG_AIC_ACSR & AIC_ACSR_SLTERR )
+#define __ac97_clear_slot_error()        ( REG_AIC_ACSR &= ~AIC_ACSR_SLTERR )
+
+#define __i2s_is_busy()         ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+#define __aic_internal_codec()  ( REG_AIC_FR |= AIC_FR_ICDC ) 
+#define __aic_external_codec()  ( REG_AIC_FR &= ~AIC_FR_ICDC )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+ } while (0)
+
+/*************************************************************************
+ * PCM Controller operation
+ *************************************************************************/
+
+#define __pcm_enable()          ( REG_PCM_CTL |= PCM_CTL_PCMEN )
+#define __pcm_disable()         ( REG_PCM_CTL &= ~PCM_CTL_PCMEN )
+
+#define __pcm_clk_enable()      ( REG_PCM_CTL |= PCM_CTL_CLKEN )
+#define __pcm_clk_disable()     ( REG_PCM_CTL &= ~PCM_CTL_CLKEN )
+
+#define __pcm_reset()           ( REG_PCM_CTL |= PCM_CTL_RST )
+#define __pcm_flush_fifo()	( REG_PCM_CTL |= PCM_CTL_FLUSH )
+
+#define __pcm_enable_record()		( REG_PCM_CTL |= PCM_CTL_EREC )
+#define __pcm_disable_record()		( REG_PCM_CTL &= ~PCM_CTL_EREC )
+#define __pcm_enable_playback()		( REG_PCM_CTL |= PCM_CTL_ERPL )
+#define __pcm_disable_playback()	( REG_PCM_CTL &= ~PCM_CTL_ERPL )
+
+#define __pcm_enable_rxfifo()           __pcm_enable_record()
+#define __pcm_disable_rxfifo()          __pcm_disable_record()
+#define __pcm_enable_txfifo()           __pcm_enable_playback()
+#define __pcm_disable_txfifo()          __pcm_disable_playback()
+
+#define __pcm_last_sample()     ( REG_PCM_CTL |= PCM_CTL_LSMP )
+#define __pcm_zero_sample()     ( REG_PCM_CTL &= ~PCM_CTL_LSMP )
+
+#define __pcm_enable_transmit_dma()    ( REG_PCM_CTL |= PCM_CTL_ETDMA )
+#define __pcm_disable_transmit_dma()   ( REG_PCM_CTL &= ~PCM_CTL_ETDMA )
+#define __pcm_enable_receive_dma()     ( REG_PCM_CTL |= PCM_CTL_ERDMA )
+#define __pcm_disable_receive_dma()    ( REG_PCM_CTL &= ~PCM_CTL_ERDMA )
+
+#define __pcm_as_master()     ( REG_PCM_CFG &= PCM_CFG_MODE )
+#define __pcm_as_slave()      ( REG_PCM_CFG |= ~PCM_CFG_MODE )
+
+#define __pcm_set_transmit_trigger(n) 			\
+do {							\
+	REG_PCM_CFG &= ~PCM_CFG_TFTH_MASK;		\
+	REG_PCM_CFG |= ((n) << PCM_CFG_TFTH_BIT);	\
+} while(0)
+
+#define __pcm_set_receive_trigger(n) 			\
+do {							\
+	REG_PCM_CFG &= ~PCM_CFG_RFTH_MASK;		\
+	REG_PCM_CFG |= ((n) << PCM_CFG_RFTH_BIT);	\
+} while(0)
+
+#define __pcm_omsb_same_sync()   ( REG_PCM_CFG &= ~PCM_CFG_OMSBPOS )
+#define __pcm_omsb_next_sync()   ( REG_PCM_CFG |= PCM_CFG_OMSBPOS )
+
+#define __pcm_imsb_same_sync()   ( REG_PCM_CFG &= ~PCM_CFG_IMSBPOS )
+#define __pcm_imsb_next_sync()   ( REG_PCM_CFG |= PCM_CFG_IMSBPOS )
+
+/* set input sample size 8 or 16*/
+#define __pcm_set_iss(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_ISS_MASK) | PCM_CFG_ISS_##n )
+/* set output sample size 8 or 16*/
+#define __pcm_set_oss(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_OSS_MASK) | PCM_CFG_OSS_##n )
+
+#define __pcm_set_valid_slot(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_SLOT_MASK) | PCM_CFG_SLOT_##n )
+
+#define __pcm_write_data(v)           ( REG_PCM_DP = (v) )
+#define __pcm_read_data()             ( REG_PCM_DP )
+
+#define __pcm_enable_tfs_intr()       ( REG_PCM_INTC |= PCM_INTC_ETFS )
+#define __pcm_disable_tfs_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ETFS )
+
+#define __pcm_enable_tur_intr()       ( REG_PCM_INTC |= PCM_INTC_ETUR )
+#define __pcm_disable_tur_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ETUR )
+
+#define __pcm_enable_rfs_intr()       ( REG_PCM_INTC |= PCM_INTC_ERFS )
+#define __pcm_disable_rfs_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ERFS )
+
+#define __pcm_enable_ror_intr()       ( REG_PCM_INTC |= PCM_INTC_EROR )
+#define __pcm_disable_ror_intr()      ( REG_PCM_INTC &= ~PCM_INTC_EROR )
+
+#define __pcm_ints_valid_tx() \
+( ((REG_PCM_INTS & PCM_INTS_TFL_MASK) >> PCM_INTS_TFL_BIT) )
+#define __pcm_ints_valid_rx() \
+( ((REG_PCM_INTS & PCM_INTS_RFL_MASK) >> PCM_INTS_RFL_BIT) )
+
+#define __pcm_set_clk_div(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_CLKDIV_MASK) | ((n) << PCM_DIV_CLKDIV_BIT) )
+
+/* sysclk(cpm_pcm_sysclk) Hz is created by cpm logic, and pcmclk Hz is the pcm in/out clock wanted */
+#define __pcm_set_clk_rate(sysclk, pcmclk) \
+__pcm_set_clk_div(((sysclk) / (pcmclk) - 1)) 
+
+#define __pcm_set_sync_div(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_SYNDIV_MASK) | ((n) << PCM_DIV_SYNDIV_BIT) )
+
+/* pcmclk is source clock Hz, and sync is the frame sync clock Hz wanted */
+#define __pcm_set_sync_rate(pcmclk, sync) \
+__pcm_set_sync_div(((pcmclk) / (8 * (sync)) - 1))
+
+ /* set sync length in pcmclk n = 0 ... 63 */
+#define __pcm_set_sync_len(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_SYNL_MASK) | (n << PCM_DIV_SYNL_BIT) )
+
+
+/***************************************************************************
+ * ICDC
+ ***************************************************************************/
+#define __i2s_internal_codec()         __aic_internal_codec()
+#define __i2s_external_codec()         __aic_external_codec()
+
+#define __icdc_clk_ready()             ( REG_ICDC_CKCFG & ICDC_CKCFG_CKRDY )
+#define __icdc_sel_adc()               ( REG_ICDC_CKCFG |= ICDC_CKCFG_SELAD )
+#define __icdc_sel_dac()               ( REG_ICDC_CKCFG &= ~ICDC_CKCFG_SELAD )
+
+#define __icdc_set_rgwr()              ( REG_ICDC_RGADW |= ICDC_RGADW_RGWR )
+#define __icdc_clear_rgwr()            ( REG_ICDC_RGADW &= ~ICDC_RGADW_RGWR )
+#define __icdc_rgwr_ready()            ( REG_ICDC_RGADW & ICDC_RGADW_RGWR )
+
+#define __icdc_set_addr(n)				\
+do {          						\
+	REG_ICDC_RGADW &= ~ICDC_RGADW_RGADDR_MASK;	\
+	REG_ICDC_RGADW |= (n) << ICDC_RGADW_RGADDR_BIT;	\
+} while(0)
+
+#define __icdc_set_cmd(n)				\
+do {          						\
+	REG_ICDC_RGADW &= ~ICDC_RGADW_RGDIN_MASK;	\
+	REG_ICDC_RGADW |= (n) << ICDC_RGADW_RGDIN_BIT;	\
+} while(0)
+
+#define __icdc_irq_pending()            ( REG_ICDC_RGDATA & ICDC_RGDATA_IRQ )
+#define __icdc_get_value()              ( REG_ICDC_RGDATA & ICDC_RGDATA_RGDOUT_MASK )
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) ) /* A dummy ack, as the Pending Register is Read Only. Should we remove __intc_ack_irq() */
+
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+/* n = 0, 1 (MSC0, MSC1) */
+
+#define __msc_start_op(n) \
+	( REG_MSC_STRPCL(n) = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(n, to)  	( REG_MSC_RESTO(n) = to )
+#define __msc_set_rdto(n, to)   	( REG_MSC_RDTO(n) = to )
+#define __msc_set_cmd(n, cmd)   	( REG_MSC_CMD(n) = cmd )
+#define __msc_set_arg(n, arg)   	( REG_MSC_ARG(n) = arg )
+#define __msc_set_nob(n, nob)      	( REG_MSC_NOB(n) = nob )
+#define __msc_get_nob(n)        	( REG_MSC_NOB(n) )
+#define __msc_set_blklen(n, len)        ( REG_MSC_BLKLEN(n) = len )
+#define __msc_set_cmdat(n, cmdat)   	( REG_MSC_CMDAT(n) = cmdat )
+#define __msc_set_cmdat_ioabort(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort(n) 	( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1(n) 			\
+do { 							\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT(n) |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4(n) 			\
+do { 							\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT(n) |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en(n)       ( REG_MSC_CMDAT(n) |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream(n)       ( REG_MSC_CMDAT(n) |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block(n)        ( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read(n) 	( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write(n)        ( REG_MSC_CMDAT(n) |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en(n)      ( REG_MSC_CMDAT(n) |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(n, r)				\
+do { 								\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT(n) |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat(n) \
+  REG_MSC_CMDAT(n) &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask(n) 		( REG_MSC_IMASK(n) )
+#define __msc_mask_all_intrs(n) 	( REG_MSC_IMASK(n) = 0xff )
+#define __msc_unmask_all_intrs(n) 	( REG_MSC_IMASK(n) = 0x00 )
+#define __msc_mask_rd(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd(n) 		( REG_MSC_IMASK(n) &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr(n) 		( REG_MSC_IMASK(n) &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres(n) 	( REG_MSC_IMASK(n) |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone(n) 	( REG_MSC_IMASK(n) |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_PRG_DONE )
+
+/* m=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n, m) 	\
+do { 				\
+	REG_MSC_CLKRT(n) = m;	\
+} while(0)
+
+#define __msc_get_ireg(n) 	        	( REG_MSC_IREG(n) )
+#define __msc_ireg_rd(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res(n)       	( REG_MSC_IREG(n) & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done(n)     	( REG_MSC_IREG(n) & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res(n)         ( REG_MSC_IREG(n) = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done(n)      ( REG_MSC_IREG(n) = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done(n)     	( REG_MSC_IREG(n) = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat(n) 		( REG_MSC_STAT(n) )
+#define __msc_stat_not_end_cmd_res(n) 	( (REG_MSC_STAT(n) & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err(n) \
+  ( REG_MSC_STAT(n) & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err(n) 		( REG_MSC_STAT(n) & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo(n) 		( REG_MSC_RES(n) )
+#define __msc_rd_rxfifo(n)  		( REG_MSC_RXFIFO(n) )
+#define __msc_wr_txfifo(n, v)  		( REG_MSC_TXFIFO(n) = v )
+
+#define __msc_reset(n) 						\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT(n) & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk(n) 					\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk(n) 					\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+
+/***************************************************************************
+ * SSI (Synchronous Serial Interface)
+ ***************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define __ssi_enable(n) 	( REG_SSI_CR0(n) |= SSI_CR0_SSIE )
+#define __ssi_disable(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode(n) ( REG_SSI_ITR(n) &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2(n) 		\
+do { 					\
+	REG_SSI_CR0(n) |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1(n) &= ~SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_select_gpc(n) 			\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_FSEL;	\
+	REG_SSI_CR1(n) |= SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_underrun_auto_clear(n) 		\
+do { 						\
+	REG_SSI_CR0(n) |= SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_underrun_clear_manually(n) 	\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_txfifo_half_empty_intr(n)  \
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE )
+#define __ssi_disable_txfifo_half_empty_intr(n)	\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TIE )
+#define __ssi_enable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_TEIE )
+#define __ssi_disable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TEIE )
+#define __ssi_enable_rxfifo_half_full_intr(n)	\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE )
+#define __ssi_disable_rxfifo_half_full_intr(n)  \
+	( REG_SSI_CR0(n) &= ~SSI_CR0_RIE )
+#define __ssi_enable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_REIE )
+#define __ssi_disable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_REIE )
+
+#define __ssi_enable_loopback(n)  ( REG_SSI_CR0(n) |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback(n) ( REG_SSI_CR0(n) &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive(n)   ( REG_SSI_CR0(n) &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive(n)  ( REG_SSI_CR0(n) |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive(n)					\
+	( REG_SSI_CR0(n) |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit(n) 	( REG_SSI_CR1(n) &= ~SSI_CR1_UNFIN )
+#define __ssi_wait_transmit(n) 		( REG_SSI_CR1(n) |= SSI_CR1_UNFIN )
+#define __ssi_use_busy_wait_mode(n) 	__ssi_wait_transmit(n)
+#define __ssi_unset_busy_wait_mode(n) 	__ssi_finish_transmit(n)
+
+#define __ssi_spi_format(n)						\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SPI;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+	} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format(n)						\
+	do { 								\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN);	\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SSP;			\
+	} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format(n)					\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_MW1;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+		REG_SSI_CR0(n) &= ~SSI_CR0_RFINE;			\
+	} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+/* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	  | SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	
+
+#define __ssi_spi_set_misc(n,frmhl,endian,flen,mcom,pha,pol)		\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSICR1_MISC_MASK;			\
+		REG_SSI_CR1(n) |= ((frmhl) << 30) | ((endian) << 25) | 	\
+			(((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+			((pha) << 1) | (pol); 				\
+	} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb(n) ( REG_SSI_CR1(n) &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb(n) ( REG_SSI_CR1(n) |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n, m)					\
+	REG_SSI_CR1(n) = (REG_SSI_CR1(n) & ~SSI_CR1_FLEN_MASK) | (((m) - 2) << 4) 
+
+/* m = 1 - 16 */
+#define __ssi_set_microwire_command_length(n,m)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##m##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n, m)					\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_PHA) | (((m)&0x1)<< 1)))
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n, p)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_POL) | ((p)&0x1)) )
+
+/* SSI tx trigger, m = i x 8 */
+#define __ssi_set_tx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_TTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_TTRG_BIT;	\
+	} while (0)
+
+/* SSI rx trigger, m = i x 8 */
+#define __ssi_set_rx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_RTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_RTRG_BIT;	\
+	} while (0)
+
+#define __ssi_get_txfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_transfer_end(n)		( REG_SSI_SR(n) & SSI_SR_END )
+#define __ssi_is_busy(n)		( REG_SSI_SR(n) & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full(n)		( REG_SSI_SR(n) & SSI_SR_TFF )
+#define __ssi_rxfifo_empty(n)		( REG_SSI_SR(n) & SSI_SR_RFE )
+#define __ssi_rxfifo_half_full(n)	( REG_SSI_SR(n) & SSI_SR_RFHF )
+#define __ssi_txfifo_half_empty(n)	( REG_SSI_SR(n) & SSI_SR_TFHE )
+#define __ssi_underrun(n)		( REG_SSI_SR(n) & SSI_SR_UNDR )
+#define __ssi_overrun(n)		( REG_SSI_SR(n) & SSI_SR_OVER )
+#define __ssi_clear_underrun(n)		( REG_SSI_SR(n) = ~SSI_SR_UNDR )
+#define __ssi_clear_overrun(n)		( REG_SSI_SR(n) = ~SSI_SR_OVER )
+#define __ssi_clear_errors(n)		( REG_SSI_SR(n) &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_set_clk(n, dev_clk, ssi_clk)			\
+	( REG_SSI_GR(n) = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data(n) 		REG_SSI_DR(n)
+#define __ssi_transmit_data(n, v) 	(REG_SSI_DR(n) = (v))
+
+#define __ssi_set_grdiv(n,v)			(REG_SSI_GR(n) = v)
+#define __ssi_get_grdiv(n)				(REG_SSI_GR(n))
+
+#define __ssi_txfifo_half_empty_intr(n)  \
+	( REG_SSI_CR0(n) & SSI_CR0_TIE )
+#define __ssi_rxfifo_half_full_intr(n)	\
+	( REG_SSI_CR0(n) & SSI_CR0_RIE )
+	
+#define __ssi_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) & SSI_CR0_TEIE )
+#define __ssi_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) & SSI_CR0_REIE )	
+	
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+/* n = 0, 1, 2, 3 */
+#define __cim_set_input_data_stream_order(n)				\
+	do {								\
+		REG_CIM_CFG &= CIM_CFG_ORDER_MASK;			\
+		REG_CIM_CFG |= ((n)<<CIM_CFG_ORDER_BIT)&CIM_CFG_ORDER_MASK; \
+	} while (0)
+
+#define __cim_input_data_format_select_RGB()	\
+	do {					\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;	\
+		REG_CIM_CFG |= CIM_CFG_DF_RGB;	\
+	} while (0)
+
+#define __cim_input_data_format_select_YUV444()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_YUV444;	\
+	} while (0)
+
+#define __cim_input_data_format_select_YUV422()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_YUV422;	\
+	} while (0)
+
+#define __cim_input_data_format_select_ITU656()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_ITU656;	\
+	} while (0)
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+	( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+	( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_PACK_MASK;	\
+	REG_CIM_CFG |= (CIM_CFG_PACK_##n);	\
+} while (0)
+
+#define __cim_enable_bypass_func() 	(REG_CIM_CFG |= CIM_CFG_BYPASS)
+#define __cim_disable_bypass_func() 	(REG_CIM_CFG &= ~CIM_CFG_BYPASS_MASK)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_CPM;		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_CIM;		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_GCM;		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_NGCM;	\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+	REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;				\
+	REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+	REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+	REG_CIM_CTRL |= CIM_CTRL_FRC_##n;	\
+} while (0)
+
+#define __cim_enable_size_func() \
+	( REG_CIM_CTRL |= CIM_CTRL_SIZEEN )
+#define __cim_disable_size_func() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_SIZEEN_MASK )
+
+#define __cim_enable_vdd_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_VDDM )
+#define __cim_disable_vdd_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_VDDM )
+
+#define __cim_enable_sof_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_eeof_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_EEOFM )
+#define __cim_disable_eeof_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EEOFM )
+
+#define __cim_enable_stop_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr()	\
+	( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr()	\
+	( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+	REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+	REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n;		\
+} while (0)
+#define __cim_enable_fast_mode() 	( REG_CIM_CTRL |= CIM_CTRL_FAST_MODE )
+#define __cim_disable_fast_mode() 	( REG_CIM_CTRL &= ~CIM_CTRL_FAST_MODE )
+#define __cim_use_normal_mode() 	__cim_disable_fast_mode()
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_fid()   	     ( REG_CIM_FID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dma_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+#define __cim_set_line(a) 	( REG_CIM_SIZE = (REG_CIM_SIZE&(~CIM_SIZE_LPF_MASK))|((a)<<CIM_SIZE_LPF_BIT) )
+#define __cim_set_pixel(a) 	( REG_CIM_SIZE = (REG_CIM_SIZE&(~CIM_SIZE_PPL_MASK))|((a)<<CIM_SIZE_PPL_BIT) )
+#define __cim_get_line() 	((REG_CIM_SIZE&CIM_SIZE_LPF_MASK)>>CIM_SIZE_LPF_BIT)
+#define __cim_get_pixel() 	((REG_CIM_SIZE&CIM_SIZE_PPL_MASK)>>CIM_SIZE_PPL_BIT)
+
+#define __cim_set_v_offset(a) 	( REG_CIM_OFFSET = (REG_CIM_OFFSET&(~CIM_OFFSET_V_MASK)) | ((a)<<CIM_OFFSET_V_BIT) )
+#define __cim_set_h_offset(a) 	( REG_CIM_OFFSET = (REG_CIM_OFFSET&(~CIM_OFFSET_H_MASK)) | ((a)<<CIM_OFFSET_H_BIT) )
+#define __cim_get_v_offset() 	((REG_CIM_OFFSET&CIM_OFFSET_V_MASK)>>CIM_OFFSET_V_BIT)
+#define __cim_get_h_offset() 	((REG_CIM_OFFSET&CIM_OFFSET_H_MASK)>>CIM_OFFSET_H_BIT)
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+#define __slcd_set_data_18bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_18BIT )
+#define __slcd_set_data_16bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_16BIT )
+#define __slcd_set_data_8bit_x3() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x3 )
+#define __slcd_set_data_8bit_x2() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x2 )
+#define __slcd_set_data_8bit_x1() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x1 )
+#define __slcd_set_data_24bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_24BIT )
+#define __slcd_set_data_9bit_x2() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_9BIT_x2 )
+
+#define __slcd_set_cmd_16bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_16BIT )
+#define __slcd_set_cmd_8bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_8BIT )
+#define __slcd_set_cmd_18bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_18BIT )
+#define __slcd_set_cmd_24bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_24BIT )
+
+#define __slcd_set_cs_high()        ( REG_SLCD_CFG |= SLCD_CFG_CS_ACTIVE_HIGH )
+#define __slcd_set_cs_low()         ( REG_SLCD_CFG &= ~SLCD_CFG_CS_ACTIVE_HIGH )
+
+#define __slcd_set_rs_high()        ( REG_SLCD_CFG |= SLCD_CFG_RS_CMD_HIGH )
+#define __slcd_set_rs_low()         ( REG_SLCD_CFG &= ~SLCD_CFG_RS_CMD_HIGH )
+
+#define __slcd_set_clk_falling()    ( REG_SLCD_CFG &= ~SLCD_CFG_CLK_ACTIVE_RISING )
+#define __slcd_set_clk_rising()     ( REG_SLCD_CFG |= SLCD_CFG_CLK_ACTIVE_RISING )
+
+#define __slcd_set_parallel_type()  ( REG_SLCD_CFG &= ~SLCD_CFG_TYPE_SERIAL )
+#define __slcd_set_serial_type()    ( REG_SLCD_CFG |= SLCD_CFG_TYPE_SERIAL )
+
+/* SLCD Control Register */
+#define __slcd_enable_dma()         ( REG_SLCD_CTRL |= SLCD_CTRL_DMA_EN )
+#define __slcd_disable_dma()        ( REG_SLCD_CTRL &= ~SLCD_CTRL_DMA_EN )
+
+/* SLCD Status Register */
+#define __slcd_is_busy()            ( REG_SLCD_STATE & SLCD_STATE_BUSY )
+
+/* SLCD Data Register */
+#define __slcd_set_cmd_rs()         ( REG_SLCD_DATA |= SLCD_DATA_RS_COMMAND)
+#define __slcd_set_data_rs()        ( REG_SLCD_DATA &= ~SLCD_DATA_RS_COMMAND)
+
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+#define __lcd_as_smart_lcd() 		( REG_LCD_CFG |= ( LCD_CFG_LCDPIN_SLCD | LCD_CFG_MODE_SLCD))
+#define __lcd_as_general_lcd() 		( REG_LCD_CFG &= ~( LCD_CFG_LCDPIN_SLCD | LCD_CFG_MODE_SLCD))
+
+#define __lcd_enable_tvepeh() 		( REG_LCD_CFG |= LCD_CFG_TVEPEH )
+#define __lcd_disable_tvepeh() 		( REG_LCD_CFG &= ~LCD_CFG_TVEPEH )
+
+#define __lcd_enable_fuhold() 		( REG_LCD_CFG |= LCD_CFG_FUHOLD )
+#define __lcd_disable_fuhold() 		( REG_LCD_CFG &= ~LCD_CFG_FUHOLD )
+
+#define __lcd_des_8word() 		( REG_LCD_CFG |= LCD_CFG_NEWDES )
+#define __lcd_des_4word() 		( REG_LCD_CFG &= ~LCD_CFG_NEWDES )
+
+#define __lcd_enable_bypass_pal() 	( REG_LCD_CFG |= LCD_CFG_PALBP )
+#define __lcd_disable_bypass_pal() 	( REG_LCD_CFG &= ~LCD_CFG_PALBP )
+
+#define __lcd_set_lcdpnl_term()		( REG_LCD_CFG |= LCD_CFG_TVEN )
+#define __lcd_set_tv_term()		( REG_LCD_CFG &= ~LCD_CFG_TVEN )
+
+#define __lcd_enable_auto_recover() 	( REG_LCD_CFG |= LCD_CFG_RECOVER )
+#define __lcd_disable_auto_recover() 	( REG_LCD_CFG &= ~LCD_CFG_RECOVER )
+
+#define __lcd_enable_dither() 	        ( REG_LCD_CFG |= LCD_CFG_DITHER )
+#define __lcd_disable_dither() 	        ( REG_LCD_CFG &= ~LCD_CFG_DITHER )
+
+#define __lcd_disable_ps_mode()	        ( REG_LCD_CFG |= LCD_CFG_PSM )
+#define __lcd_enable_ps_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_PSM )
+
+#define __lcd_disable_cls_mode() 	( REG_LCD_CFG |= LCD_CFG_CLSM )
+#define __lcd_enable_cls_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_CLSM )
+
+#define __lcd_disable_spl_mode() 	( REG_LCD_CFG |= LCD_CFG_SPLM )
+#define __lcd_enable_spl_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_SPLM )
+
+#define __lcd_disable_rev_mode() 	( REG_LCD_CFG |= LCD_CFG_REVM )
+#define __lcd_enable_rev_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_REVM )
+
+#define __lcd_disable_hsync_mode() 	( REG_LCD_CFG |= LCD_CFG_HSYNM )
+#define __lcd_enable_hsync_mode()	( REG_LCD_CFG &= ~LCD_CFG_HSYNM )
+
+#define __lcd_disable_pclk_mode() 	( REG_LCD_CFG |= LCD_CFG_PCLKM )
+#define __lcd_enable_pclk_mode()	( REG_LCD_CFG &= ~LCD_CFG_PCLKM )
+
+#define __lcd_normal_outdata()          ( REG_LCD_CFG &= ~LCD_CFG_INVDAT )
+#define __lcd_inverse_outdata()         ( REG_LCD_CFG |= LCD_CFG_INVDAT )
+
+#define __lcd_sync_input()              ( REG_LCD_CFG |= LCD_CFG_SYNDIR_IN )
+#define __lcd_sync_output()             ( REG_LCD_CFG &= ~LCD_CFG_SYNDIR_IN )
+
+#define __lcd_hsync_active_high()       ( REG_LCD_CFG &= ~LCD_CFG_HSP )
+#define __lcd_hsync_active_low()        ( REG_LCD_CFG |= LCD_CFG_HSP )
+
+#define __lcd_pclk_rising()             ( REG_LCD_CFG &= ~LCD_CFG_PCP )
+#define __lcd_pclk_falling()            ( REG_LCD_CFG |= LCD_CFG_PCP )
+
+#define __lcd_de_active_high()          ( REG_LCD_CFG &= ~LCD_CFG_DEP )
+#define __lcd_de_active_low()           ( REG_LCD_CFG |= LCD_CFG_DEP )
+
+#define __lcd_vsync_rising()            ( REG_LCD_CFG &= ~LCD_CFG_VSP )
+#define __lcd_vsync_falling()           ( REG_LCD_CFG |= LCD_CFG_VSP )
+
+#define __lcd_set_16_tftpnl() \
+  ( REG_LCD_CFG = (REG_LCD_CFG & ~LCD_CFG_MODE_TFT_MASK) | LCD_CFG_MODE_TFT_16BIT )
+
+#define __lcd_set_18_tftpnl() \
+  ( REG_LCD_CFG = (REG_LCD_CFG & ~LCD_CFG_MODE_TFT_MASK) | LCD_CFG_MODE_TFT_18BIT )
+
+#define __lcd_set_24_tftpnl()		( REG_LCD_CFG |= LCD_CFG_MODE_TFT_24BIT )
+
+/* 
+ * n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_CFG &= ~LCD_CFG_PDW_MASK; 	\
+	REG_LCD_CFG |= LCD_CFG_PDW_n##;		\
+} while (0)
+
+/* m = LCD_CFG_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_CFG &= ~LCD_CFG_MODE_MASK;	\
+	REG_LCD_CFG |= (m);			\
+} while(0)
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+/* OSD functions */
+#define __lcd_enable_osd() 	(REG_LCD_OSDC |= LCD_OSDC_OSDEN)
+#define __lcd_enable_f0() 	(REG_LCD_OSDC |= LCD_OSDC_F0EN)
+#define __lcd_enable_f1()	(REG_LCD_OSDC |= LCD_OSDC_F1EN)
+#define __lcd_enable_alpha() 	(REG_LCD_OSDC |= LCD_OSDC_ALPHAEN)
+#define __lcd_enable_alphamd()	(REG_LCD_OSDC |= LCD_OSDC_ALPHAMD)
+
+#define __lcd_disable_osd()	(REG_LCD_OSDC &= ~LCD_OSDC_OSDEN)
+#define __lcd_disable_f0() 	(REG_LCD_OSDC &= ~LCD_OSDC_F0EN)
+#define __lcd_disable_f1() 	(REG_LCD_OSDC &= ~LCD_OSDC_F1EN)
+#define __lcd_disable_alpha()	(REG_LCD_OSDC &= ~LCD_OSDC_ALPHAEN)
+#define __lcd_disable_alphamd()	(REG_LCD_OSDC &= ~LCD_OSDC_ALPHAMD)
+
+/* OSD Controll Register */
+#define __lcd_fg1_use_ipu() 		(REG_LCD_OSDCTRL |= LCD_OSDCTRL_IPU)
+#define __lcd_fg1_use_dma_chan1() 	(REG_LCD_OSDCTRL &= ~LCD_OSDCTRL_IPU)
+#define __lcd_fg1_unuse_ipu() 		__lcd_fg1_use_dma_chan1()
+#define __lcd_osd_rgb555_mode()         ( REG_LCD_OSDCTRL |= LCD_OSDCTRL_RGB555 )
+#define __lcd_osd_rgb565_mode()         ( REG_LCD_OSDCTRL &= ~LCD_OSDCTRL_RGB555 )
+#define __lcd_osd_change_size()         ( REG_LCD_OSDCTRL |= LCD_OSDCTRL_CHANGES )
+#define __lcd_osd_bpp_15_16() \
+  ( REG_LCD_OSDCTRL = (REG_LCD_OSDCTRL & ~LCD_OSDCTRL_OSDBPP_MASK) | LCD_OSDCTRL_OSDBPP_15_16 )
+#define __lcd_osd_bpp_18_24() \
+  ( REG_LCD_OSDCTRL = (REG_LCD_OSDCTRL & ~LCD_OSDCTRL_OSDBPP_MASK) | LCD_OSDCTRL_OSDBPP_18_24 )
+
+/* OSD State Register */
+#define __lcd_start_of_fg1()		( REG_LCD_STATE & LCD_OSDS_SOF1 )
+#define __lcd_end_of_fg1()		( REG_LCD_STATE & LCD_OSDS_EOF1 )
+#define __lcd_start_of_fg0()		( REG_LCD_STATE & LCD_OSDS_SOF0 )
+#define __lcd_end_of_fg0()		( REG_LCD_STATE & LCD_OSDS_EOF0 )
+#define __lcd_change_is_rdy()		( REG_LCD_STATE & LCD_OSDS_READY )
+
+/* Foreground Color Key Register 0,1(foreground 0, foreground 1) */
+#define __lcd_enable_colorkey0()	(REG_LCD_KEY0 |= LCD_KEY_KEYEN)
+#define __lcd_enable_colorkey1()	(REG_LCD_KEY1 |= LCD_KEY_KEYEN)
+#define __lcd_enable_colorkey0_md() 	(REG_LCD_KEY0 |= LCD_KEY_KEYMD)
+#define __lcd_enable_colorkey1_md() 	(REG_LCD_KEY1 |= LCD_KEY_KEYMD)
+#define __lcd_set_colorkey0(key) 	(REG_LCD_KEY0 = (REG_LCD_KEY0&~0xFFFFFF)|(key))
+#define __lcd_set_colorkey1(key) 	(REG_LCD_KEY1 = (REG_LCD_KEY1&~0xFFFFFF)|(key))
+
+#define __lcd_disable_colorkey0() 	(REG_LCD_KEY0 &= ~LCD_KEY_KEYEN)
+#define __lcd_disable_colorkey1() 	(REG_LCD_KEY1 &= ~LCD_KEY_KEYEN)
+#define __lcd_disable_colorkey0_md() 	(REG_LCD_KEY0 &= ~LCD_KEY_KEYMD)
+#define __lcd_disable_colorkey1_md() 	(REG_LCD_KEY1 &= ~LCD_KEY_KEYMD)
+
+/* IPU Restart Register */
+#define __lcd_enable_ipu_restart() 	(REG_LCD_IPUR |= LCD_IPUR_IPUREN)
+#define __lcd_disable_ipu_restart() 	(REG_LCD_IPUR &= ~LCD_IPUR_IPUREN)
+#define __lcd_set_ipu_restart_triger(n)	(REG_LCD_IPUR = (REG_LCD_IPUR&(~0xFFFFFF))|(n))
+
+/* RGB Control Register */
+#define __lcd_enable_rgb_dummy() 	(REG_LCD_RGBC |= LCD_RGBC_RGBDM)
+#define __lcd_disable_rgb_dummy() 	(REG_LCD_RGBC &= ~LCD_RGBC_RGBDM)
+
+#define __lcd_dummy_rgb() 	(REG_LCD_RGBC |= LCD_RGBC_DMM)
+#define __lcd_rgb_dummy() 	(REG_LCD_RGBC &= ~LCD_RGBC_DMM)
+
+#define __lcd_rgb2ycc() 	(REG_LCD_RGBC |= LCD_RGBC_YCC)
+#define __lcd_notrgb2ycc() 	(REG_LCD_RGBC &= ~LCD_RGBC_YCC)
+
+#define __lcd_odd_mode_rgb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_RGB )
+#define __lcd_odd_mode_rbg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_RBG )
+#define __lcd_odd_mode_grb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_GRB)
+
+#define __lcd_odd_mode_gbr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_GBR)
+#define __lcd_odd_mode_brg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_BRG)
+#define __lcd_odd_mode_bgr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_BGR)
+
+#define __lcd_even_mode_rgb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_RGB )
+#define __lcd_even_mode_rbg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_RBG )
+#define __lcd_even_mode_grb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_GRB)
+
+#define __lcd_even_mode_gbr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_GBR)
+#define __lcd_even_mode_brg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_BRG)
+#define __lcd_even_mode_bgr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_BGR)
+
+/* Vertical Synchronize Register */
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+/* DMA Command Register */
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+/*************************************************************************
+ * TVE (TV Encoder Controller) ops
+ *************************************************************************/
+/* TV Encoder Control register ops */
+#define __tve_soft_reset()		(REG_TVE_CTRL |= TVE_CTRL_SWRST)
+
+#define __tve_output_colorbar()		(REG_TVE_CTRL |= TVE_CTRL_CLBAR)
+#define __tve_output_video()		(REG_TVE_CTRL &= ~TVE_CTRL_CLBAR)
+
+#define __tve_input_cr_first()		(REG_TVE_CTRL |= TVE_CTRL_CR1ST)
+#define __tve_input_cb_first()		(REG_TVE_CTRL &= ~TVE_CTRL_CR1ST)
+
+#define __tve_set_0_as_black()		(REG_TVE_CTRL |= TVE_CTRL_ZBLACK)
+#define __tve_set_16_as_black()		(REG_TVE_CTRL &= ~TVE_CTRL_ZBLACK)
+
+#define __tve_ena_invert_top_bottom()	(REG_TVE_CTRL |= TVE_CTRL_FINV)
+#define __tve_dis_invert_top_bottom()	(REG_TVE_CTRL &= ~TVE_CTRL_FINV)
+
+#define __tve_set_pal_mode()		(REG_TVE_CTRL |= TVE_CTRL_PAL)
+#define __tve_set_ntsc_mode()		(REG_TVE_CTRL &= ~TVE_CTRL_PAL)
+
+#define __tve_set_pal_dura()		(REG_TVE_CTRL |= TVE_CTRL_SYNCT)
+#define __tve_set_ntsc_dura()		(REG_TVE_CTRL &= ~TVE_CTRL_SYNCT)
+
+/* n = 0 ~ 3 */
+#define __tve_set_c_bandwidth(n) \
+do {\
+	REG_TVE_CTRL &= ~TVE_CTRL_CBW_MASK;\
+	REG_TVE_CTRL |= (n) << TVE_CTRL_CBW_BIT;	\
+}while(0)
+
+/* n = 0 ~ 3 */
+#define __tve_set_c_gain(n) \
+do {\
+	REG_TVE_CTRL &= ~TVE_CTRL_CGAIN_MASK;\
+	(REG_TVE_CTRL |= (n) << TVE_CTRL_CGAIN_BIT;	\
+}while(0)
+
+/* n = 0 ~ 7 */
+#define __tve_set_yc_delay(n)				\
+do {							\
+	REG_TVE_CTRL &= ~TVE_CTRL_YCDLY_MASK		\
+	REG_TVE_CTRL |= ((n) << TVE_CTRL_YCDLY_BIT);	\
+} while(0)
+
+#define __tve_disable_all_dacs()	(REG_TVE_CTRL |= TVE_CTRL_DAPD)
+#define __tve_disable_dac1()		(REG_TVE_CTRL |= TVE_CTRL_DAPD1)
+#define __tve_enable_dac1()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD1)
+#define __tve_disable_dac2()		(REG_TVE_CTRL |= TVE_CTRL_DAPD2)
+#define __tve_enable_dac2()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD2)
+#define __tve_disable_dac3()		(REG_TVE_CTRL |= TVE_CTRL_DAPD3)
+#define __tve_enable_dac3()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD3)
+
+#define __tve_enable_svideo_fmt()	(REG_TVE_CTRL |= TVE_CTRL_ECVBS)
+#define __tve_enable_cvbs_fmt()		(REG_TVE_CTRL &= ~TVE_CTRL_ECVBS)
+
+/* TV Encoder Frame Configure register ops */
+/* n = 0 ~ 255 */
+#define __tve_set_first_video_line(n)		\
+do {\
+		REG_TVE_FRCFG &= ~TVE_FRCFG_L1ST_MASK;\
+		REG_TVE_FRCFG |= (n) << TVE_FRCFG_L1ST_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_line_num_per_frm(n)		\
+do {\
+		REG_TVE_FRCFG &= ~TVE_FRCFG_NLINE_MASK;\
+		REG_TVE_CFG |= (n) << TVE_FRCFG_NLINE_BIT;\
+} while(0)
+#define __tve_get_video_line_num()\
+	(((REG_TVE_FRCFG & TVE_FRCFG_NLINE_MASK) >> TVE_FRCFG_NLINE_BIT) - 1 - 2 * ((REG_TVE_FRCFG & TVE_FRCFG_L1ST_MASK) >> TVE_FRCFG_L1ST_BIT))
+
+/* TV Encoder Signal Level Configure register ops */
+/* n = 0 ~ 1023 */
+#define __tve_set_white_level(n)		\
+do {\
+		REG_TVE_SLCFG1 &= ~TVE_SLCFG1_WHITEL_MASK;\
+		REG_TVE_SLCFG1 |= (n) << TVE_SLCFG1_WHITEL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_black_level(n)		\
+do {\
+		REG_TVE_SLCFG1 &= ~TVE_SLCFG1_BLACKL_MASK;\
+		REG_TVE_SLCFG1 |= (n) << TVE_SLCFG1_BLACKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_blank_level(n)		\
+do {\
+		REG_TVE_SLCFG2 &= ~TVE_SLCFG2_BLANKL_MASK;\
+		REG_TVE_SLCFG2 |= (n) << TVE_SLCFG2_BLANKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_vbi_blank_level(n)		\
+do {\
+		REG_TVE_SLCFG2 &= ~TVE_SLCFG2_VBLANKL_MASK;\
+		REG_TVE_SLCFG2 |= (n) << TVE_SLCFG2_VBLANKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_sync_level(n)		\
+do {\
+		REG_TVE_SLCFG3 &= ~TVE_SLCFG3_SYNCL_MASK;\
+		REG_TVE_SLCFG3 |= (n) << TVE_SLCFG3_SYNCL_BIT;\
+} while(0)
+
+/* TV Encoder Signal Level Configure register ops */
+/* n = 0 ~ 31 */
+#define __tve_set_front_porch(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_FRONTP_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_FRONTP_BIT;	\
+} while(0)
+/* n = 0 ~ 127 */
+#define __tve_set_hsync_width(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_HSYNCW_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_HSYNCW_BIT;	\
+} while(0)
+/* n = 0 ~ 127 */
+#define __tve_set_back_porch(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_BACKP_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_BACKP_BIT;	\
+} while(0)
+/* n = 0 ~ 2047 */
+#define __tve_set_active_linec(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_ACTLIN_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_ACTLIN_BIT;	\
+} while(0)
+/* n = 0 ~ 31 */
+#define __tve_set_breezy_way(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_PREBW_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_PREBW_BIT;	\
+} while(0)
+
+/* n = 0 ~ 127 */
+#define __tve_set_burst_width(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_BURSTW_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_BURSTW_BIT;	\
+} while(0)
+
+/* TV Encoder Chrominance filter and Modulation register ops */
+/* n = 0 ~ (2^32-1) */
+#define __tve_set_c_sub_carrier_freq(n)  REG_TVE_CFREQ = (n)
+/* n = 0 ~ 255 */
+#define __tve_set_c_sub_carrier_init_phase(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_INITPH_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_INITPH_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_c_sub_carrier_act_phase(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_ACTPH_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_ACTPH_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_c_phase_rst_period(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_CCRSTP_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_CCRSTP_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cb_burst_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CBBA_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CBBA_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cr_burst_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CRBA_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CRBA_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cb_gain_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CBGAIN_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CBGAIN_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cr_gain_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CRGAIN_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CRGAIN_BIT;	\
+} while(0)
+
+/* TV Encoder Wide Screen Signal Control register ops */
+/* n = 0 ~ 7 */
+#define __tve_set_notch_freq(n) \
+do {   \
+	REG_TVE_WSSCR &= ~TVE_WSSCR_NCHFREQ_MASK;	\
+	REG_TVE_WSSCR |= (n) << TVE_WSSCR_NCHFREQ_BIT;	\
+} while(0)
+/* n = 0 ~ 7 */
+#define __tve_set_notch_width()	(REG_TVE_WSSCR |= TVE_WSSCR_NCHW_BIT)
+#define __tve_clear_notch_width()	(REG_TVE_WSSCR &= ~TVE_WSSCR_NCHW_BIT)
+#define __tve_enable_notch()		(REG_TVE_WSSCR |= TVE_WSSCR_ENCH_BIT)
+#define __tve_disable_notch()		(REG_TVE_WSSCR &= ~TVE_WSSCR_ENCH_BIT)
+/* n = 0 ~ 7 */
+#define __tve_set_wss_edge(n) \
+do {   \
+	REG_TVE_WSSCR &= ~TVE_WSSCR_WSSEDGE_MASK;	\
+	REG_TVE_WSSCR |= (n) << TVE_WSSCR_WSSEDGE_BIT;	\
+} while(0)
+#define __tve_set_wss_clkbyp()		(REG_TVE_WSSCR |= TVE_WSSCR_WSSCKBP_BIT)
+#define __tve_set_wss_type()		(REG_TVE_WSSCR |= TVE_WSSCR_WSSTP_BIT)
+#define __tve_enable_wssf1()		(REG_TVE_WSSCR |= TVE_WSSCR_EWSS1_BIT)
+#define __tve_enable_wssf0()		(REG_TVE_WSSCR |= TVE_WSSCR_EWSS0_BIT)
+
+/* TV Encoder Wide Screen Signal Configure register 1, 2 and 3 ops */
+/* n = 0 ~ 1023 */
+#define __tve_set_wss_level(n) \
+do {   \
+	REG_TVE_WSSCFG1 &= ~TVE_WSSCFG1_WSSL_MASK;	\
+	REG_TVE_WSSCFG1 |= (n) << TVE_WSSCFG1_WSSL_BIT;	\
+} while(0)
+/* n = 0 ~ 4095 */
+#define __tve_set_wss_freq(n) \
+do {   \
+	REG_TVE_WSSCFG1 &= ~TVE_WSSCFG1_WSSFREQ_MASK;	\
+	REG_TVE_WSSCFG1 |= (n) << TVE_WSSCFG1_WSSFREQ_BIT;	\
+} while(0)
+/* n = 0, 1; l = 0 ~ 255 */
+#define __tve_set_wss_line(n,v)			\
+do {   \
+	REG_TVE_WSSCFG##n &= ~TVE_WSSCFG_WSSLINE_MASK;	\
+	REG_TVE_WSSCFG##n |= (v) << TVE_WSSCFG_WSSLINE_BIT;	\
+} while(0)
+/* n = 0, 1; d = 0 ~ (2^20-1) */
+#define __tve_set_wss_data(n, v)			\
+do {   \
+	REG_TVE_WSSCFG##n &= ~TVE_WSSCFG_WSSLINE_MASK;	\
+	REG_TVE_WSSCFG##n |= (v) << TVE_WSSCFG_WSSLINE_BIT;	\
+} while(0)
+
+/***************************************************************************
+ * RTC ops
+ ***************************************************************************/
+
+#define __rtc_write_ready()  ( (REG_RTC_RCR & RTC_RCR_WRDY) >> RTC_RCR_WRDY_BIT )
+#define __rtc_enabled()        ( REG_RTC_RCR |= RTC_RCR_RTCE )
+#define __rtc_disabled()         ( REG_RTC_RCR &= ~RTC_RCR_RTCE )
+#define __rtc_enable_alarm()         ( REG_RTC_RCR |= RTC_RCR_AE )
+#define __rtc_disable_alarm()         ( REG_RTC_RCR &= ~RTC_RCR_AE )
+#define __rtc_enable_alarm_irq()         ( REG_RTC_RCR |= RTC_RCR_AIE )
+#define __rtc_disable_alarm_irq()         ( REG_RTC_RCR &= ~RTC_RCR_AIE )
+#define __rtc_enable_1Hz_irq()         ( REG_RTC_RCR |= RTC_RCR_1HZIE )
+#define __rtc_disable_1Hz_irq()         ( REG_RTC_RCR &= ~RTC_RCR_1HZIE )
+
+#define __rtc_get_1Hz_flag()           ( (REG_RTC_RCR >> RTC_RCR_1HZ_BIT) & 0x1 )
+#define __rtc_clear_1Hz_flag()           ( REG_RTC_RCR &= ~RTC_RCR_1HZ )
+#define __rtc_get_alarm_flag()           ( (REG_RTC_RCR >> RTC_RCR_AF_BIT) & 0x1 )
+#define __rtc_clear_alarm_flag()           ( REG_RTC_RCR &= ~RTC_RCR_AF )
+
+#define __rtc_get_second()   ( REG_RTC_RSR )
+#define __rtc_set_second(v)   ( REG_RTC_RSR = v )
+
+#define __rtc_get_alarm_second()   ( REG_RTC_RSAR )
+#define __rtc_set_alarm_second(v)   ( REG_RTC_RSAR = v )
+
+#define __rtc_RGR_is_locked()       ( (REG_RTC_RGR >> RTC_RGR_LOCK) )
+#define __rtc_lock_RGR()       ( REG_RTC_RGR |= RTC_RGR_LOCK )
+#define __rtc_unlock_RGR()       ( REG_RTC_RGR &= ~RTC_RGR_LOCK )
+#define __rtc_get_adjc_val()       ( (REG_RTC_RGR & RTC_RGR_ADJC_MASK) >> RTC_RGR_ADJC_BIT )
+#define __rtc_set_adjc_val(v)      \
+       ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_ADJC_MASK) | (v << RTC_RGR_ADJC_BIT) ))
+#define __rtc_get_nc1Hz_val()       ( (REG_RTC_RGR & RTC_RGR_NC1HZ_MASK) >> RTC_RGR_NC1HZ_BIT )
+#define __rtc_set_nc1Hz_val(v)      \
+       ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_NC1HZ_MASK) | (v << RTC_RGR_NC1HZ_BIT) ))
+
+#define __rtc_power_down()            ( REG_RTC_HCR |= RTC_HCR_PD )
+
+#define __rtc_get_hwfcr_val()         ( REG_RTC_HWFCR & RTC_HWFCR_MASK )
+#define __rtc_set_hwfcr_val(v)         ( REG_RTC_HWFCR = (v) & RTC_HWFCR_MASK )
+#define __rtc_get_hrcr_val()         ( REG_RTC_HRCR & RTC_HRCR_MASK )
+#define __rtc_set_hrcr_val(v)         ( REG_RTC_HRCR = (v) & RTC_HRCR_MASK )
+
+#define __rtc_enable_alarm_wakeup()        ( REG_RTC_HWCR |= RTC_HWCR_EALM )
+#define __rtc_disable_alarm_wakeup()        ( REG_RTC_HWCR &= ~RTC_HWCR_EALM )
+
+#define __rtc_status_hib_reset_occur()        ( REG_RTC_HWRSR & RTC_HWRSR_HR )
+#define __rtc_status_ppr_reset_occur()        ( REG_RTC_HWRSR & RTC_HWRSR_PPR )
+#define __rtc_status_wakeup_pin_waken_up()    ( REG_RTC_HWRSR & RTC_HWRSR_PIN )
+#define __rtc_status_alarm_waken_up()        ( REG_RTC_HWRSR & RTC_HWRSR_ALM )
+#define __rtc_clear_hib_stat_all()               ( REG_RTC_HWRSR = 0 )
+
+#define __rtc_get_scratch_pattern() 		(REG_RTC_HSPR)
+#define __rtc_set_scratch_pattern(n) 		(REG_RTC_HSPR = n )
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define __ecc_encoding_4bit()                                   \
+do {				   		        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BCHE;  \
+	REG_BCH_CRC = BCH_CR_BSEL8;				\
+} while(0)
+#define __ecc_decoding_4bit()                           \
+do {                                                    \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BCHE;	\
+	REG_BCH_CRC = BCH_CR_ENCE | BCH_CR_BSEL8;	\
+} while(0)
+#define __ecc_encoding_8bit()                                                   \
+do {				   		                        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;   \
+} while(0)
+#define __ecc_decoding_8bit()                                        \
+do {                                                                 \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;	     \
+	REG_BCH_CRC = BCH_CR_ENCE;	                             \
+} while(0)
+#define __ecc_dma_enable()        ( REG_BCH_CRS = BCH_CR_DMAE )
+#define __ecc_dma_disable()       ( REG_BCH_CRC = BCH_CR_DMAE )
+#define __ecc_disable()           ( REG_BCH_CRC = BCH_CR_BCHE )
+#define __ecc_encode_sync()       while (!(REG_BCH_INTS & BCH_INTS_ENCF))
+#define __ecc_decode_sync()       while (!(REG_BCH_INTS & BCH_INTS_DECF))
+#define __ecc_cnt_dec(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_DEC_MASK << BCH_CNT_DEC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_DEC_BIT;                        \
+} while(0)
+#define __ecc_cnt_enc(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_ENC_MASK << BCH_CNT_ENC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_ENC_BIT;                        \
+} while(0)
+
+/***************************************************************************
+ * OWI (one-wire bus)  ops
+ ***************************************************************************/
+
+/* OW control register ops */
+#define __owi_enable_all_interrupts()      ( REG_OWI_CTL = (OWI_CTL_EBYTE | OWI_CTL_EBIT | OWI_CTL_ERST) )
+#define __owi_disable_all_interrupts()     ( REG_OWI_CTL = 0 )
+
+#define __owi_enable_byte_interrupt()      ( REG_OWI_CTL |= OWI_CTL_EBYTE )
+#define __owi_disable_byte_interrupt()     ( REG_OWI_CTL &= ~OWI_CTL_EBYTE )
+#define __owi_enable_bit_interrupt()       ( REG_OWI_CTL |= OWI_CTL_EBIT )
+#define __owi_disable_bit_interrupt()      ( REG_OWI_CTL &= ~OWI_CTL_EBIT )
+#define __owi_enable_rst_interrupt()       ( REG_OWI_CTL |= OWI_CTL_ERST ) 
+#define __owi_disable_rst_interrupt()      ( REG_OWI_CTL &=~OWI_CTL_ERST )
+
+/* OW configure register ops */
+#define __owi_select_regular_mode()        ( REG_OWI_CFG &= ~OWI_CFG_MODE )
+#define __owi_select_overdrive_mode()      ( REG_OWI_CFG |= OWI_CFG_MODE )
+
+#define __owi_set_rddata()  ( REG_OWI_CFG |= OWI_CFG_RDDATA )
+#define __owi_clr_rddata()  ( REG_OWI_CFG &= ~OWI_CFG_RDDATA )
+#define __owi_get_rddata()  ( REG_OWI_CFG & OWI_CFG_RDDATA )
+
+#define __owi_set_wrdata()  ( REG_OWI_CFG |= OWI_CFG_WRDATA )
+#define __owi_clr_wrdata()  ( REG_OWI_CFG &= ~OWI_CFG_WRDATA )
+#define __owi_get_wrdata()  ( REG_OWI_CFG & OWI_CFG_WRDATA )
+
+#define __owi_get_rdst()    ( REG_OWI_CFG & OWI_CFG_RDST )
+
+#define __owi_set_wr1rd()   ( REG_OWI_CFG |= OWI_CFG_WR1RD )
+#define __owi_clr_wr1rd()   ( REG_OWI_CFG &= ~OWI_CFG_WR1RD )
+#define __owi_get_wr1rd()   ( REG_OWI_CFG & OWI_CFG_WR1RD )
+
+#define __owi_set_wr0()     ( REG_OWI_CFG |= OWI_CFG_WR0 )
+#define __owi_clr_wr0()     ( REG_OWI_CFG &= ~OWI_CFG_WR0 )
+#define __owi_get_wr0()     ( REG_OWI_CFG & OWI_CFG_WR0 )
+
+#define __owi_set_rst()     ( REG_OWI_CFG |= OWI_CFG_RST )
+#define __owi_clr_rst()     ( REG_OWI_CFG &= ~OWI_CFG_RST )
+#define __owi_get_rst()     ( REG_OWI_CFG & OWI_CFG_RST )
+
+#define __owi_enable_ow_ops()  ( REG_OWI_CFG |= OWI_CFG_ENA )
+#define __owi_disable_ow_ops() ( REG_OWI_CFG &= ~OWI_CFG_ENA )
+#define __owi_get_enable()     ( REG_OWI_CFG & OWI_CFG_ENA )
+
+#define __owi_wait_ops_rdy()                \
+	do {				    \
+		while(__owi_get_enable());  \
+		udelay(1);		    \
+	} while(0);
+
+/* OW status register ops */
+#define __owi_clr_sts()           ( REG_OWI_STS = 0 )
+#define __owi_get_sts_pst()       ( REG_OWI_STS & OWI_STS_PST )
+#define __owi_get_sts_byte_rdy()  ( REG_OWI_STS & OWI_STS_BYTE_RDY )
+#define __owi_get_sts_bit_rdy()   ( REG_OWI_STS & OWI_STS_BIT_RDY )
+#define __owi_get_sts_pst_rdy()   ( REG_OWI_STS & OWI_STS_PST_RDY )
+
+/*************************************************************************
+ * TSSI MPEG 2-TS slave interface operation
+ *************************************************************************/
+#define __tssi_enable()                       ( REG_TSSI_ENA |= TSSI_ENA_ENA )
+#define __tssi_disable()                      ( REG_TSSI_ENA &= ~TSSI_ENA_ENA )
+#define __tssi_soft_reset()                   ( REG_TSSI_ENA |= TSSI_ENA_SFT_RST )
+#define __tssi_dma_enable()                   ( REG_TSSI_ENA |= TSSI_ENA_DMA_EN )
+#define __tssi_dma_disable()                  ( REG_TSSI_ENA &= ~TSSI_ENA_DMA_EN )
+#define __tssi_filter_enable()                ( REG_TSSI_ENA |= TSSI_ENA_PID_EN )
+#define __tssi_filter_disable()               ( REG_TSSI_ENA &= ~TSSI_ENA_PID_EN )
+
+/* n = 4, 8, 16 */
+#define __tssi_set_tigger_num(n)			\
+	do {						\
+		REG_TSSI_CFG &= ~TSSI_CFG_TRIG_MASK;	\
+		REG_TSSI_CFG |= TSSI_CFG_TRIG_##n;	\
+	} while (0)
+
+#define __tssi_set_wd_1()                     ( REG_TSSI_CFG |= TSSI_CFG_END_WD )
+#define __tssi_set_wd_0()                     ( REG_TSSI_CFG &= ~TSSI_CFG_END_WD )
+
+#define __tssi_set_bt_1()                     ( REG_TSSI_CFG |= TSSI_CFG_END_BD )
+#define __tssi_set_bt_0()                     ( REG_TSSI_CFG &= ~TSSI_CFG_END_BD )
+
+#define __tssi_set_data_pola_high()           ( REG_TSSI_CFG |= TSSI_CFG_TSDI_H )
+#define __tssi_set_data_pola_low()            ( REG_TSSI_CFG &= ~TSSI_CFG_TSDI_H )
+
+#define __tssi_set_data_use_data0()           ( REG_TSSI_CFG |= TSSI_CFG_USE_0 )
+#define __tssi_set_data_use_data7()           ( REG_TSSI_CFG &= ~TSSI_CFG_USE_0 )
+
+#define __tssi_select_clk_fast()              ( REG_TSSI_CFG &= ~TSSI_CFG_TSCLK_CH )
+#define __tssi_select_clk_slow()              ( REG_TSSI_CFG |= TSSI_CFG_TSCLK_CH )
+
+#define __tssi_select_serail_mode()           ( REG_TSSI_CFG &= ~TSSI_CFG_PARAL )
+#define __tssi_select_paral_mode()            ( REG_TSSI_CFG |= TSSI_CFG_PARAL )
+
+#define __tssi_select_clk_nega_edge()         ( REG_TSSI_CFG &= ~TSSI_CFG_TSCLK_P )
+#define __tssi_select_clk_posi_edge()         ( REG_TSSI_CFG |= TSSI_CFG_TSCLK_P )
+
+#define __tssi_select_frm_act_high()          ( REG_TSSI_CFG |= TSSI_CFG_TSFRM_H )
+#define __tssi_select_frm_act_low()           ( REG_TSSI_CFG &= ~TSSI_CFG_TSFRM_H )
+
+#define __tssi_select_str_act_high()          ( REG_TSSI_CFG |= TSSI_CFG_TSSTR_H )
+#define __tssi_select_str_act_low()           ( REG_TSSI_CFG &= ~TSSI_CFG_TSSTR_H )
+
+#define __tssi_select_fail_act_high()         ( REG_TSSI_CFG |= TSSI_CFG_TSFAIL_H )
+#define __tssi_select_fail_act_low()          ( REG_TSSI_CFG &= ~TSSI_CFG_TSFAIL_H )
+
+#define __tssi_enable_ovrn_irq()              ( REG_TSSI_CTRL &= ~TSSI_CTRL_OVRNM )
+#define __tssi_disable_ovrn_irq()             ( REG_TSSI_CTRL |= TSSI_CTRL_OVRNM )
+
+#define __tssi_enable_trig_irq()              ( REG_TSSI_CTRL &= ~TSSI_CTRL_TRIGM )
+#define __tssi_disable_trig_irq()             ( REG_TSSI_CTRL |= TSSI_CTRL_TRIGM ) 
+
+#define __tssi_state_is_overrun()             ( REG_TSSI_STAT & TSSI_STAT_OVRN )
+#define __tssi_state_trigger_meet()           ( REG_TSSI_STAT & TSSI_STAT_TRIG )
+#define __tssi_clear_state()                  ( REG_TSSI_STAT = 0 ) /* write 0??? */
+#define __tssi_state_clear_overrun()          ( REG_TSSI_STAT = TSSI_STAT_OVRN )
+
+#define __tssi_enable_filte_pid0()            ( REG_TSSI_PEN |= TSSI_PEN_PID0 )
+#define __tssi_disable_filte_pid0()           ( REG_TSSI_PEN &= ~TSSI_PEN_PID0 )
+
+/* m = 0, ..., 15 */
+#define __tssi_enable_pid_filter(m)				\
+	do {							\
+		int n = (m);					\
+		if ( n>=0 && n <(TSSI_PID_MAX*2) ) {		\
+			if ( n >= TSSI_PID_MAX ) n += 8;	\
+			REG_TSSI_PEN |= ( 1 << n );		\
+		}						\
+	} while (0)
+
+/* m = 0, ..., 15 */
+#define __tssi_disable_pid_filter(m)				       \
+	do {							       \
+		int n = (m);					       \
+		if ( n>=0 && n <(TSSI_PID_MAX*2) ) {		       \
+			if ( n >= TSSI_PID_MAX ) n += 8;	       \
+			REG_TSSI_PEN &= ~( 1 << n );		       \
+		}						       \
+	} while (0)
+
+/* n = 0, ..., 7 */
+#define __tssi_set_pid0(n, pid0)					\
+	do {								\
+		REG_TSSI_PID(n) &= ~TSSI_PID_PID0_MASK;			\
+		REG_TSSI_PID(n) |= ((pid0)<<TSSI_PID_PID0_BIT)&TSSI_PID_PID0_MASK; \
+	}while (0)
+/* n = 0, ..., 7 */
+#define __tssi_set_pid1(n, pid1)					\
+	do {								\
+		REG_TSSI_PID(n) &= ~TSSI_PID_PID1_MASK;			\
+		REG_TSSI_PID(n) |= ((pid1)<<TSSI_PID_PID1_BIT)&TSSI_PID_PID1_MASK; \
+	}while (0)
+
+/* n = 0, ..., 15 */
+#define __tssi_set_pid(n, pid)						\
+	do {								\
+		if ( n>=0 && n < TSSI_PID_MAX*2) {			\
+			if ( n < TSSI_PID_MAX )				\
+				__tssi_set_pid0(n, pid);		\
+			else						\
+				__tssi_set_pid1(n-TSSI_PID_MAX, pid);	\
+		}							\
+	}while (0)
+
+
+#if 0
+/*************************************************************************
+ * IPU (Image Processing Unit)
+ *************************************************************************/
+#define u32 volatile unsigned long
+
+#define write_reg(reg, val)	\
+do {				\
+	*(u32 *)(reg) = (val);	\
+} while(0)
+
+#define read_reg(reg, off)	(*(u32 *)((reg)+(off)))
+
+
+#define set_ipu_fmt(rgb_888_out_fmt, rgb_out_oft, out_fmt, yuv_pkg_out, in_oft, in_fmt ) \
+({ write_reg( (IPU_V_BASE + REG_D_FMT), ((in_fmt) & IN_FMT_MSK)<<IN_FMT_SFT \
+| ((in_oft) & IN_OFT_MSK)<< IN_OFT_SFT \
+| ((out_fmt) & OUT_FMT_MSK)<<OUT_FMT_SFT \
+| ((yuv_pkg_out) & YUV_PKG_OUT_MSK ) << YUV_PKG_OUT_SFT \
+| ((rgb_888_out_fmt) & RGB888_FMT_MSK ) << RGB888_FMT_SFT \
+| ((rgb_out_oft) & RGB_OUT_OFT_MSK ) << RGB_OUT_OFT_SFT); \
+})
+#define set_y_addr(y_addr) \
+({ write_reg( (IPU_V_BASE + REG_Y_ADDR), y_addr); \
+})
+#define set_u_addr(u_addr) \
+({ write_reg( (IPU_V_BASE + REG_U_ADDR), u_addr); \
+})
+
+#define set_v_addr(v_addr) \
+({ write_reg( (IPU_V_BASE + REG_V_ADDR), v_addr); \
+})
+
+#define set_y_phy_t_addr(y_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_Y_PHY_T_ADDR), y_phy_t_addr); \
+})
+
+#define set_u_phy_t_addr(u_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_U_PHY_T_ADDR), u_phy_t_addr); \
+})
+
+#define set_v_phy_t_addr(v_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_V_PHY_T_ADDR), v_phy_t_addr); \
+})
+
+#define set_out_phy_t_addr(out_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_OUT_PHY_T_ADDR), out_phy_t_addr); \
+})
+
+#define set_inframe_gsize(width, height, y_stride, u_stride, v_stride) \
+({ write_reg( (IPU_V_BASE + REG_IN_FM_GS), ((width) & IN_FM_W_MSK)<<IN_FM_W_SFT \
+| ((height) & IN_FM_H_MSK)<<IN_FM_H_SFT); \
+ write_reg( (IPU_V_BASE + REG_Y_STRIDE), ((y_stride) & Y_S_MSK)<<Y_S_SFT); \
+ write_reg( (IPU_V_BASE + REG_UV_STRIDE), ((u_stride) & U_S_MSK)<<U_S_SFT \
+| ((v_stride) & V_S_MSK)<<V_S_SFT); \
+})
+#define set_out_addr(out_addr) \
+({ write_reg( (IPU_V_BASE + REG_OUT_ADDR), out_addr); \
+})
+#define set_outframe_gsize(width, height, o_stride) \
+({ write_reg( (IPU_V_BASE + REG_OUT_GS), ((width) & OUT_FM_W_MSK)<<OUT_FM_W_SFT \
+| ((height) & OUT_FM_H_MSK)<<OUT_FM_H_SFT); \
+ write_reg( (IPU_V_BASE + REG_OUT_STRIDE), ((o_stride) & OUT_S_MSK)<<OUT_S_SFT); \
+})
+#define set_rsz_lut_end(h_end, v_end) \
+({ write_reg( (IPU_V_BASE + REG_RSZ_COEF_INDEX), ((h_end) & HE_IDX_MSK)<<HE_IDX_SFT \
+| ((v_end) & VE_IDX_MSK)<<VE_IDX_SFT); \
+})
+#define set_csc_c0(c0_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_CO_COEF), ((c0_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c1(c1_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C1_COEF), ((c1_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c2(c2_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C2_COEF), ((c2_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c3(c3_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C3_COEF), ((c3_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c4(c4_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C4_COEF), ((c4_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_hrsz_lut_coef(coef, in_n, out_n) \
+({ write_reg( (IPU_V_BASE + HRSZ_LUT_BASE ), ((coef) & W_COEF_MSK)<<W_COEF_SFT \
+| ((in_n) & IN_N_MSK)<<IN_N_SFT | ((out_n) & OUT_N_MSK)<<OUT_N_SFT); \
+})
+#define set_vrsz_lut_coef(coef, in_n, out_n) \
+({ write_reg( (IPU_V_BASE + VRSZ_LUT_BASE), ((coef) & W_COEF_MSK)<<W_COEF_SFT \
+| ((in_n) & IN_N_MSK)<<IN_N_SFT | ((out_n) & OUT_N_MSK)<<OUT_N_SFT); \
+})
+
+#define set_primary_ctrl(vrsz_en, hrsz_en,csc_en, irq_en) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((irq_en) & FM_IRQ_EN_MSK)<<FM_IRQ_EN_SFT \
+| ((vrsz_en) & VRSZ_EN_MSK)<<VRSZ_EN_SFT \
+| ((hrsz_en) & HRSZ_EN_MSK)<<HRSZ_EN_SFT \
+| ((csc_en) & CSC_EN_MSK)<<CSC_EN_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(CSC_EN_MSK<<CSC_EN_SFT | FM_IRQ_EN_MSK<<FM_IRQ_EN_SFT | VRSZ_EN_MSK<<VRSZ_EN_SFT | HRSZ_EN_MSK<<HRSZ_EN_SFT ) ); \
+})
+
+#define set_source_ctrl(pkg_sel, spage_sel) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((pkg_sel) & PKG_SEL_MSK  )<< PKG_SEL_SFT \
+| ((spage_sel) & SPAGE_MAP_MSK )<< SPAGE_MAP_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(SPAGE_MAP_MSK << SPAGE_MAP_SFT | PKG_SEL_MSK << PKG_SEL_SFT ) ) ; \
+})
+
+#define set_out_ctrl(lcdc_sel, dpage_sel, disp_sel) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((lcdc_sel) & LCDC_SEL_MSK  )<< LCDC_SEL_SFT \
+| ((dpage_sel) & DPAGE_SEL_MSK )<< DPAGE_SEL_SFT \
+| ((disp_sel) & DISP_SEL_MSK )<< DISP_SEL_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(LCDC_SEL_MSK<< LCDC_SEL_SFT | DPAGE_SEL_MSK << DPAGE_SEL_SFT | DISP_SEL_MSK << DISP_SEL_SFT ) ); \
+})
+
+#define set_scale_ctrl(v_scal, h_scal) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((v_scal) & V_SCALE_MSK)<<V_SCALE_SFT \
+| ((h_scal) & H_SCALE_MSK)<<H_SCALE_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) & ~(V_SCALE_MSK<<V_SCALE_SFT | H_SCALE_MSK<<H_SCALE_SFT ) ); \
+})
+
+
+#define set_csc_ofset_para(chrom_oft, luma_oft) \
+({ write_reg( (IPU_V_BASE + REG_CSC_OFSET_PARA ), ((chrom_oft) & CHROM_OF_MSK ) << CHROM_OF_SFT \
+| ((luma_oft) & LUMA_OF_MSK ) << LUMA_OF_SFT ) ; \
+})
+
+#define sw_reset_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) \
+| IPU_RST_MSK<<IPU_RST_SFT); \
+})
+#define enable_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) | 0x1); \
+})
+#define disable_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) & ~0x1); \
+})
+#define run_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) | 0x2); \
+})
+#define stop_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) & ~0x2); \
+})
+
+#define polling_end_flag() \
+({ (read_reg(IPU_V_BASE, REG_STATUS)) & 0x01; \
+})
+
+#define start_vlut_coef_write() \
+({ write_reg( (IPU_V_BASE + VRSZ_LUT_BASE), ( 0x1<<12 ) ); \
+})
+
+#define start_hlut_coef_write() \
+({ write_reg( (IPU_V_BASE + HRSZ_LUT_BASE), ( 0x01<<12 ) ); \
+})
+
+#define clear_end_flag() \
+({ write_reg( (IPU_V_BASE + REG_STATUS), 0); \
+})
+#endif /* #if 0 */
+
+
+#endif /* __JZ4750D_OPS_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/platform.h b/arch/mips/include/asm/mach-jz4750d/platform.h
new file mode 100644
index 0000000..6f5861a
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/platform.h
@@ -0,0 +1,32 @@
+#ifndef __JZ4750D_PLATFORM_H__
+#define __JZ4750D_PLATFORM_H__
+
+/* msc */
+#define CARD_INSERTED 1
+#define CARD_REMOVED 0
+
+struct jz_mmc_platform_data {
+	unsigned int ocr_mask;			/* available voltages */
+	unsigned long detect_delay;		/* delay in jiffies before detecting cards after interrupt */
+	unsigned char status_irq;
+	unsigned char support_sdio;
+	unsigned char bus_width;
+	unsigned int max_bus_width;
+	unsigned int detect_pin;
+
+	unsigned char msc_irq;
+	unsigned char dma_rxid;
+	unsigned char dma_txid;
+
+	void *driver_data;
+
+	void (*init) (struct device *);
+	void (*power_on) (struct device *);
+	void (*power_off) (struct device *);
+	void (*cpm_start) (struct device *);
+	unsigned int (*status) (struct device *);
+	unsigned int (*write_protect) (struct device *);
+	void (*plug_change) (int);
+};
+
+#endif /* __JZ4750D_PLATFORM_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/regs.h b/arch/mips/include/asm/mach-jz4750d/regs.h
new file mode 100644
index 0000000..2e020e8
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/regs.h
@@ -0,0 +1,3458 @@
+/*
+ * linux/include/asm-mips/mach-jz4750d/regs.h
+ *
+ * JZ4750D register definition.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __JZ4750D_REGS_H__
+#define __JZ4750D_REGS_H__
+
+#if defined(__ASSEMBLY__) || defined(__LANGUAGE_ASSEMBLY)
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+#else
+#define REG8(addr)	*((volatile unsigned char *)(addr))
+#define REG16(addr)	*((volatile unsigned short *)(addr))
+#define REG32(addr)	*((volatile unsigned int *)(addr))
+#endif
+
+/*
+ * Define the module base addresses
+ */
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	TCU_BASE	0xB0002000
+#define	WDT_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	ICDC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	UART2_BASE	0xB0032000
+#define	UART3_BASE	0xB0033000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SADC_BASE	0xB0070000
+#define PCM_BASE        0xB0071000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	SLCD_BASE	0xB3050000
+#define	TVE_BASE	0xB3050100
+#define	CIM_BASE	0xB3060000
+#define IPU_BASE	0xB3080000
+#define ME_BASE		0xB3090000
+#define MC_BASE		0xB30A0000
+#define BCH_BASE	0xB30D0000
+#define	ETH_BASE	0xB3100000
+#define	TCSM_BASE	0xF4000000
+#define OWI_BASE	0XB0072000
+#define OTP_BASE	0xB3012000
+#define TSSI_BASE	0xB0073000
+
+/*************************************************************************
+ * INTC (Interrupt Controller)
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+#define INTC_ISSR	(INTC_BASE + 0x18)  /* Interrupt Controller Source Set Register */
+#define INTC_ISCR	(INTC_BASE + 0x1c)  /* Interrupt Controller Source Clear Register */
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+#define REG_INTC_ISSR   REG32(INTC_ISSR)
+#define REG_INTC_ISCR   REG32(INTC_ISCR)
+
+// 1st-level interrupts
+#define IRQ_ETH		0
+#define IRQ_SFT		4
+#define IRQ_I2C		5
+#define IRQ_RTC		6
+#define IRQ_UART2	7
+#define IRQ_UART1	8
+#define IRQ_UART0	9
+#define IRQ_AIC 	10
+#define IRQ_GPIO5	11
+#define IRQ_GPIO4	12
+#define IRQ_GPIO3	13
+#define IRQ_GPIO2	14
+#define IRQ_GPIO1	15
+#define IRQ_GPIO0	16
+#define IRQ_BCH		17
+#define IRQ_SADC	18
+#define IRQ_CIM		19
+#define IRQ_TSSI	20
+#define IRQ_TCU2	21
+#define IRQ_TCU1	22
+#define IRQ_TCU0	23
+#define IRQ_MSC1	24
+#define IRQ_MSC0	25
+#define IRQ_SSI   	26
+#define IRQ_UDC		27
+#define IRQ_DMAC1	28
+#define IRQ_DMAC0	29
+#define IRQ_IPU		30
+#define IRQ_LCD		31
+
+// 2nd-level interrupts
+#define IRQ_DMA_0	32  /* 32 to 43 for DMAC0's 0-5  and DMAC1's 0-5 */
+#define IRQ_GPIO_0	48  /* 48 to 240 for GPIO pin 0 to 192 */
+
+#define NUM_DMA         MAX_DMA_NUM	/* 12 */
+#define NUM_GPIO        MAX_GPIO_NUM	/* GPIO NUM: 192, Jz4750D real num GPIO 178 */
+
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00) /* RTC Control Register */
+#define RTC_RSR		(RTC_BASE + 0x04) /* RTC Second Register */
+#define RTC_RSAR	(RTC_BASE + 0x08) /* RTC Second Alarm Register */
+#define RTC_RGR		(RTC_BASE + 0x0c) /* RTC Regulator Register */
+
+#define RTC_HCR		(RTC_BASE + 0x20) /* Hibernate Control Register */
+#define RTC_HWFCR	(RTC_BASE + 0x24) /* Hibernate Wakeup Filter Counter Reg */
+#define RTC_HRCR	(RTC_BASE + 0x28) /* Hibernate Reset Counter Register */
+#define RTC_HWCR	(RTC_BASE + 0x2c) /* Hibernate Wakeup Control Register */
+#define RTC_HWRSR	(RTC_BASE + 0x30) /* Hibernate Wakeup Status Register */
+#define RTC_HSPR	(RTC_BASE + 0x34) /* Hibernate Scratch Pattern Register */
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+#define REG_RTC_HCR	REG32(RTC_HCR)
+#define REG_RTC_HWFCR	REG32(RTC_HWFCR)
+#define REG_RTC_HRCR	REG32(RTC_HRCR)
+#define REG_RTC_HWCR	REG32(RTC_HWCR)
+#define REG_RTC_HWRSR	REG32(RTC_HWRSR)
+#define REG_RTC_HSPR	REG32(RTC_HSPR)
+
+/* RTC Control Register */
+#define RTC_RCR_WRDY_BIT 7
+#define RTC_RCR_WRDY	(1 << 7)  /* Write Ready Flag */
+#define RTC_RCR_1HZ_BIT	6
+#define RTC_RCR_1HZ	(1 << RTC_RCR_1HZ_BIT)  /* 1Hz Flag */
+#define RTC_RCR_1HZIE	(1 << 5)  /* 1Hz Interrupt Enable */
+#define RTC_RCR_AF_BIT	4
+#define RTC_RCR_AF	(1 << RTC_RCR_AF_BIT)  /* Alarm Flag */
+#define RTC_RCR_AIE	(1 << 3)  /* Alarm Interrupt Enable */
+#define RTC_RCR_AE	(1 << 2)  /* Alarm Enable */
+#define RTC_RCR_RTCE	(1 << 0)  /* RTC Enable */
+
+/* RTC Regulator Register */
+#define RTC_RGR_LOCK		(1 << 31) /* Lock Bit */
+#define RTC_RGR_ADJC_BIT	16
+#define RTC_RGR_ADJC_MASK	(0x3ff << RTC_RGR_ADJC_BIT)
+#define RTC_RGR_NC1HZ_BIT	0
+#define RTC_RGR_NC1HZ_MASK	(0xffff << RTC_RGR_NC1HZ_BIT)
+
+/* Hibernate Control Register */
+#define RTC_HCR_PD		(1 << 0)  /* Power Down */
+
+/* Hibernate Wakeup Filter Counter Register */
+#define RTC_HWFCR_BIT		5
+#define RTC_HWFCR_MASK		(0x7ff << RTC_HWFCR_BIT)
+
+/* Hibernate Reset Counter Register */
+#define RTC_HRCR_BIT		5
+#define RTC_HRCR_MASK		(0x7f << RTC_HRCR_BIT)
+
+/* Hibernate Wakeup Control Register */
+#define RTC_HWCR_EALM		(1 << 0)  /* RTC alarm wakeup enable */
+
+/* Hibernate Wakeup Status Register */
+#define RTC_HWRSR_HR		(1 << 5)  /* Hibernate reset */
+#define RTC_HWRSR_PPR		(1 << 4)  /* PPR reset */
+#define RTC_HWRSR_PIN		(1 << 1)  /* Wakeup pin status bit */
+#define RTC_HWRSR_ALM		(1 << 0)  /* RTC alarm status bit */
+
+
+/*************************************************************************
+ * CPM (Clock reset and Power control Management)
+ *************************************************************************/
+#define CPM_CPCCR	(CPM_BASE+0x00)
+#define CPM_CPPCR	(CPM_BASE+0x10)
+#define CPM_CPPSR	(CPM_BASE+0x14) /* PLL Switch and Status Register */
+#define CPM_I2SCDR	(CPM_BASE+0x60)
+#define CPM_LPCDR	(CPM_BASE+0x64)
+#define CPM_MSCCDR(n)	(CPM_BASE+0x68) /* MSC0(n=0) or MSC1(n=1) device clock divider Register */
+#define CPM_UHCCDR	(CPM_BASE+0x6C)
+#define CPM_SSICDR	(CPM_BASE+0x74)
+#define CPM_PCMCDR	(CPM_BASE+0x7C) /* PCM device clock divider Register */
+
+#define CPM_LCR		(CPM_BASE+0x04)
+#define CPM_CLKGR	(CPM_BASE+0x20)
+#define CPM_OPCR	(CPM_BASE+0x24) /* Oscillator and Power Control Register */
+
+#define CPM_RSR		(CPM_BASE+0x08)
+
+#define REG_CPM_CPCCR   	REG32(CPM_CPCCR)
+#define REG_CPM_CPPCR    	REG32(CPM_CPPCR)
+#define REG_CPM_CPPSR	        REG32(CPM_CPPSR)
+#define REG_CPM_I2SCDR  	REG32(CPM_I2SCDR)
+#define REG_CPM_LPCDR   	REG32(CPM_LPCDR)
+#define REG_CPM_MSCCDR(n)	REG32(CPM_MSCCDR(n))
+#define REG_CPM_UHCCDR   	REG32(CPM_UHCCDR)
+#define REG_CPM_SSICDR  	REG32(CPM_SSICDR)
+#define REG_CPM_PCMCDR          REG32(CPM_PCMCDR)
+
+#define REG_CPM_LCR	REG32(CPM_LCR)
+#define REG_CPM_CLKGR	REG32(CPM_CLKGR)
+#define REG_CPM_OPCR	REG32(CPM_OPCR)
+
+#define REG_CPM_RSR	REG32(CPM_RSR)
+
+/* Clock Control Register */
+#define CPM_CPCCR_I2CS		(1 << 31)
+#define CPM_CPCCR_ECS   	(1 << 30) /* Select the between EXCLK and EXCLK/2 output */
+#define CPM_CPCCR_UCS		(1 << 29)
+#define CPM_CPCCR_UDIV_BIT	23
+#define CPM_CPCCR_UDIV_MASK	(0x3f << CPM_CPCCR_UDIV_BIT)
+#define CPM_CPCCR_CE		(1 << 22)
+#define CPM_CPCCR_PCS		(1 << 21)
+#define CPM_CPCCR_H1DIV_BIT	16
+#define CPM_CPCCR_H1DIV_MASK	(0x1f << CPM_CPCCR_H1DIV_BIT)
+#define CPM_CPCCR_MDIV_BIT	12
+#define CPM_CPCCR_MDIV_MASK	(0x0f << CPM_CPCCR_MDIV_BIT)
+#define CPM_CPCCR_PDIV_BIT	8
+#define CPM_CPCCR_PDIV_MASK	(0x0f << CPM_CPCCR_PDIV_BIT)
+#define CPM_CPCCR_HDIV_BIT	4
+#define CPM_CPCCR_HDIV_MASK	(0x0f << CPM_CPCCR_HDIV_BIT)
+#define CPM_CPCCR_CDIV_BIT	0
+#define CPM_CPCCR_CDIV_MASK	(0x0f << CPM_CPCCR_CDIV_BIT)
+
+/* PLL Switch and Status Register */
+#define CPM_CPPSR_PLLOFF        (1<<31)
+#define CPM_CPPSR_PLLBP         (1<<30)
+#define CPM_CPPSR_PLLON         (1<<29)
+#define CPM_CPPSR_PS            (1<<28) /* Indicate whether the PLL parameters' change has finished */
+#define CPM_CPPSR_FS            (1<<27) /* Indicate whether the main clock's change has finished */
+#define CPM_CPPSR_CS            (1<<26) /* Indicate whether the clock switch has finished */
+#define CPM_CPPSR_PM            (1<<1)  /* Clock switch mode */
+#define CPM_CPPSR_FM            (1<<0)  /* Clock frequency change mode */
+
+/* I2S Clock Divider Register */
+#define CPM_I2SCDR_I2SDIV_BIT	0
+#define CPM_I2SCDR_I2SDIV_MASK	(0x1ff << CPM_I2SCDR_I2SDIV_BIT)
+
+/* LCD Pixel Clock Divider Register */
+#define CPM_LPCDR_LSCS	        (1<<31) /* TV encoder Source Pixel Clock Selection */
+#define CPM_LPCDR_LTCS	        (1<<30) /* LCD TV Encoder or Panel pix clock Selection */
+#define CPM_LPCDR_PIXDIV_BIT	0
+#define CPM_LPCDR_PIXDIV_MASK	(0x7ff << CPM_LPCDR_PIXDIV_BIT)
+
+/* MSC Clock Divider Register */
+#define CPM_MSCCDR_MSCDIV_BIT	0
+#define CPM_MSCCDR_MSCDIV_MASK	(0x1f << CPM_MSCCDR_MSCDIV_BIT)
+
+/* UHC Clock Divider Register */
+#define CPM_UHCCDR_UHCDIV_BIT	0
+#define CPM_UHCCDR_UHCDIV_MASK	(0xf << CPM_UHCCDR_UHCDIV_BIT)
+
+/* SSI Clock Divider Register */
+#define CPM_SSICDR_SSIDIV_BIT	0
+#define CPM_SSICDR_SSIDIV_MASK	(0xf << CPM_SSICDR_SSIDIV_BIT)
+
+/* PCM device clock divider Register */
+#define CPM_PCMCDR_PCMS         31 /* PCM source clock Selection */
+#define CPM_PCMCDR_PCMCD_BIT    0
+#define CPM_PCMCDR_PCMCD_MASK   (0x1ff << CPM_PCMCDR_PCMCD_BIT)
+
+/* PLL Control Register */
+#define CPM_CPPCR_PLLM_BIT	23
+#define CPM_CPPCR_PLLM_MASK	(0x1ff << CPM_CPPCR_PLLM_BIT)
+#define CPM_CPPCR_PLLN_BIT	18
+#define CPM_CPPCR_PLLN_MASK	(0x1f << CPM_CPPCR_PLLN_BIT)
+#define CPM_CPPCR_PLLOD_BIT	16
+#define CPM_CPPCR_PLLOD_MASK	(0x03 << CPM_CPPCR_PLLOD_BIT)
+#define CPM_CPPCR_PLLS		(1 << 10) /* obsolete, replaced by CPM_CPPSR_PLLON */
+#define CPM_CPPCR_PLLBP		(1 << 9)
+#define CPM_CPPCR_PLLEN		(1 << 8)
+#define CPM_CPPCR_PLLST_BIT	0
+#define CPM_CPPCR_PLLST_MASK	(0xff << CPM_CPPCR_PLLST_BIT)
+
+/* Low Power Control Register */
+#define CPM_LCR_DOZE_DUTY_BIT 	3
+#define CPM_LCR_DOZE_DUTY_MASK 	(0x1f << CPM_LCR_DOZE_DUTY_BIT)
+#define CPM_LCR_DOZE_ON		(1 << 2)
+#define CPM_LCR_LPM_BIT		0
+#define CPM_LCR_LPM_MASK	(0x3 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_IDLE	(0x0 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_SLEEP	(0x1 << CPM_LCR_LPM_BIT)
+
+/* Clock Gate Register */
+#define CPM_CLKGR_AUX_CPU	(1 << 24)
+#define CPM_CLKGR_AHB1  	(1 << 23)
+#define CPM_CLKGR_IDCT  	(1 << 22)
+#define CPM_CLKGR_DB    	(1 << 21)
+#define CPM_CLKGR_ME    	(1 << 20)
+#define CPM_CLKGR_MC    	(1 << 19)
+#define CPM_CLKGR_TVE    	(1 << 18)
+#define CPM_CLKGR_TSSI    	(1 << 17)
+#define CPM_CLKGR_MSC1    	(1 << 16)
+#define CPM_CLKGR_UART2    	(1 << 15)
+#define CPM_CLKGR_UART1		(1 << 14)
+#define CPM_CLKGR_IPU		(1 << 13)
+#define CPM_CLKGR_DMAC		(1 << 12)
+#define CPM_CLKGR_BCH		(1 << 11)
+#define CPM_CLKGR_UDC		(1 << 10)
+#define CPM_CLKGR_LCD		(1 << 9)
+#define CPM_CLKGR_CIM		(1 << 8)
+#define CPM_CLKGR_SADC		(1 << 7)
+#define CPM_CLKGR_MSC0		(1 << 6)
+#define CPM_CLKGR_AIC		(1 << 5)
+#define CPM_CLKGR_SSI		(1 << 4)
+#define CPM_CLKGR_I2C		(1 << 3)
+#define CPM_CLKGR_RTC		(1 << 2)
+#define CPM_CLKGR_TCU		(1 << 1)
+#define CPM_CLKGR_UART0		(1 << 0)
+
+/* Oscillator and Power Control Register */
+#define CPM_OPCR_O1ST_BIT	8
+#define CPM_OPCR_O1ST_MASK	(0xff << CPM_SCR_O1ST_BIT)
+#define CPM_OPCR_UHCPHY_DISABLE	(1 << 7)
+#define CPM_OPCR_UDCPHY_ENABLE	(1 << 6)
+#define CPM_OPCR_OSC_ENABLE	(1 << 4)
+#define CPM_OPCR_ERCS           (1 << 2) /* EXCLK/512 clock and RTCLK clock selection */
+#define CPM_OPCR_MOSE           (1 << 1) /* Main Oscillator Enable */
+#define CPM_OPCR_MCS            (1 << 0) /* Main clock source select register */
+
+/* Reset Status Register */
+#define CPM_RSR_HR		(1 << 2)
+#define CPM_RSR_WR		(1 << 1)
+#define CPM_RSR_PR		(1 << 0)
+
+
+/*************************************************************************
+ * TCU (Timer Counter Unit)
+ *************************************************************************/
+#define TCU_TSTR	(TCU_BASE + 0xF0) /* Timer Status Register,Only Used In Tcu2 Mode */
+#define TCU_TSTSR	(TCU_BASE + 0xF4) /* Timer Status Set Register */
+#define TCU_TSTCR	(TCU_BASE + 0xF8) /* Timer Status Clear Register */
+#define TCU_TSR		(TCU_BASE + 0x1C) /* Timer Stop Register */
+#define TCU_TSSR	(TCU_BASE + 0x2C) /* Timer Stop Set Register */
+#define TCU_TSCR	(TCU_BASE + 0x3C) /* Timer Stop Clear Register */
+#define TCU_TER		(TCU_BASE + 0x10) /* Timer Counter Enable Register */
+#define TCU_TESR	(TCU_BASE + 0x14) /* Timer Counter Enable Set Register */
+#define TCU_TECR	(TCU_BASE + 0x18) /* Timer Counter Enable Clear Register */
+#define TCU_TFR		(TCU_BASE + 0x20) /* Timer Flag Register */
+#define TCU_TFSR	(TCU_BASE + 0x24) /* Timer Flag Set Register */
+#define TCU_TFCR	(TCU_BASE + 0x28) /* Timer Flag Clear Register */
+#define TCU_TMR		(TCU_BASE + 0x30) /* Timer Mask Register */
+#define TCU_TMSR	(TCU_BASE + 0x34) /* Timer Mask Set Register */
+#define TCU_TMCR	(TCU_BASE + 0x38) /* Timer Mask Clear Register */
+
+#define TCU_TDFR0	(TCU_BASE + 0x40) /* Timer Data Full Register */
+#define TCU_TDHR0	(TCU_BASE + 0x44) /* Timer Data Half Register */
+#define TCU_TCNT0	(TCU_BASE + 0x48) /* Timer Counter Register */
+#define TCU_TCSR0	(TCU_BASE + 0x4C) /* Timer Control Register */
+#define TCU_TDFR1	(TCU_BASE + 0x50)
+#define TCU_TDHR1	(TCU_BASE + 0x54)
+#define TCU_TCNT1	(TCU_BASE + 0x58)
+#define TCU_TCSR1	(TCU_BASE + 0x5C)
+#define TCU_TDFR2	(TCU_BASE + 0x60)
+#define TCU_TDHR2	(TCU_BASE + 0x64)
+#define TCU_TCNT2	(TCU_BASE + 0x68)
+#define TCU_TCSR2	(TCU_BASE + 0x6C)
+#define TCU_TDFR3	(TCU_BASE + 0x70)
+#define TCU_TDHR3	(TCU_BASE + 0x74)
+#define TCU_TCNT3	(TCU_BASE + 0x78)
+#define TCU_TCSR3	(TCU_BASE + 0x7C)
+#define TCU_TDFR4	(TCU_BASE + 0x80)
+#define TCU_TDHR4	(TCU_BASE + 0x84)
+#define TCU_TCNT4	(TCU_BASE + 0x88)
+#define TCU_TCSR4	(TCU_BASE + 0x8C)
+#define TCU_TDFR5	(TCU_BASE + 0x90)
+#define TCU_TDHR5	(TCU_BASE + 0x94)
+#define TCU_TCNT5	(TCU_BASE + 0x98)
+#define TCU_TCSR5	(TCU_BASE + 0x9C)
+
+#define REG_TCU_TSTR	REG32(TCU_TSTR)
+#define REG_TCU_TSTSR	REG32(TCU_TSTSR)
+#define REG_TCU_TSTCR	REG32(TCU_TSTCR)
+#define REG_TCU_TSR	REG32(TCU_TSR)
+#define REG_TCU_TSSR	REG32(TCU_TSSR)
+#define REG_TCU_TSCR	REG32(TCU_TSCR)
+#define REG_TCU_TER	REG16(TCU_TER)
+#define REG_TCU_TESR	REG32(TCU_TESR)
+#define REG_TCU_TECR	REG32(TCU_TECR)
+#define REG_TCU_TFR	REG32(TCU_TFR)
+#define REG_TCU_TFSR	REG32(TCU_TFSR)
+#define REG_TCU_TFCR	REG32(TCU_TFCR)
+#define REG_TCU_TMR	REG32(TCU_TMR)
+#define REG_TCU_TMSR	REG32(TCU_TMSR)
+#define REG_TCU_TMCR	REG32(TCU_TMCR)
+#define REG_TCU_TDFR0	REG16(TCU_TDFR0)
+#define REG_TCU_TDHR0	REG16(TCU_TDHR0)
+#define REG_TCU_TCNT0	REG16(TCU_TCNT0)
+#define REG_TCU_TCSR0	REG16(TCU_TCSR0)
+#define REG_TCU_TDFR1	REG16(TCU_TDFR1)
+#define REG_TCU_TDHR1	REG16(TCU_TDHR1)
+#define REG_TCU_TCNT1	REG16(TCU_TCNT1)
+#define REG_TCU_TCSR1	REG16(TCU_TCSR1)
+#define REG_TCU_TDFR2	REG16(TCU_TDFR2)
+#define REG_TCU_TDHR2	REG16(TCU_TDHR2)
+#define REG_TCU_TCNT2	REG16(TCU_TCNT2)
+#define REG_TCU_TCSR2	REG16(TCU_TCSR2)
+#define REG_TCU_TDFR3	REG16(TCU_TDFR3)
+#define REG_TCU_TDHR3	REG16(TCU_TDHR3)
+#define REG_TCU_TCNT3	REG16(TCU_TCNT3)
+#define REG_TCU_TCSR3	REG16(TCU_TCSR3)
+#define REG_TCU_TDFR4	REG16(TCU_TDFR4)
+#define REG_TCU_TDHR4	REG16(TCU_TDHR4)
+#define REG_TCU_TCNT4	REG16(TCU_TCNT4)
+#define REG_TCU_TCSR4	REG16(TCU_TCSR4)
+
+// n = 0,1,2,3,4,5
+#define TCU_TDFR(n)	(TCU_BASE + (0x40 + (n)*0x10)) /* Timer Data Full Reg */
+#define TCU_TDHR(n)	(TCU_BASE + (0x44 + (n)*0x10)) /* Timer Data Half Reg */
+#define TCU_TCNT(n)	(TCU_BASE + (0x48 + (n)*0x10)) /* Timer Counter Reg */
+#define TCU_TCSR(n)	(TCU_BASE + (0x4C + (n)*0x10)) /* Timer Control Reg */
+#define TCU_OSTDR	(TCU_BASE + 0xe0) /* Operating System Timer Data Reg */
+#define TCU_OSTCNT	(TCU_BASE + 0xe8) /* Operating System Timer Counter Reg */
+#define TCU_OSTCSR	(TCU_BASE + 0xeC) /* Operating System Timer Control Reg */
+
+#define REG_TCU_TDFR(n)	REG16(TCU_TDFR((n)))
+#define REG_TCU_TDHR(n)	REG16(TCU_TDHR((n)))
+#define REG_TCU_TCNT(n)	REG16(TCU_TCNT((n)))
+#define REG_TCU_TCSR(n)	REG16(TCU_TCSR((n)))
+#define REG_TCU_OSTDR   REG32(TCU_OSTDR)
+#define REG_TCU_OSTCNT  REG32(TCU_OSTCNT)
+#define REG_TCU_OSTCSR  REG32(TCU_OSTCSR)
+
+// Register definitions
+#define TCU_TSTR_REAL2		(1 << 18) /* only used in TCU2 mode */
+#define TCU_TSTR_REAL1		(1 << 17) /* only used in TCU2 mode */
+#define TCU_TSTR_BUSY2		(1 << 2)  /* only used in TCU2 mode */
+#define TCU_TSTR_BUSY1		(1 << 1)  /* only used in TCU2 mode */
+
+#define TCU_TSTSR_REAL2		(1 << 18)
+#define TCU_TSTSR_REAL1		(1 << 17)
+#define TCU_TSTSR_BUSY2		(1 << 2)
+#define TCU_TSTSR_BUSY1		(1 << 1)
+
+#define TCU_TSTCR_REAL2		(1 << 18)
+#define TCU_TSTCR_REAL1		(1 << 17)
+#define TCU_TSTCR_BUSY2		(1 << 2)
+#define TCU_TSTCR_BUSY1		(1 << 1)
+
+#define TCU_TSR_WDTS		(1 << 16) /*the clock supplies to wdt is stopped */
+#define TCU_TSR_OSTS		(1 << 15) /*the clock supplies to osts is stopped */
+#define TCU_TSR_STOP5		(1 << 5)  /*the clock supplies to timer5 is stopped */
+#define TCU_TSR_STOP4		(1 << 4)  /*the clock supplies to timer4 is stopped */
+#define TCU_TSR_STOP3		(1 << 3)  /*the clock supplies to timer3 is stopped */
+#define TCU_TSR_STOP2		(1 << 2)  /*the clock supplies to timer2 is stopped */
+#define TCU_TSR_STOP1		(1 << 1)  /*the clock supplies to timer1 is stopped */
+#define TCU_TSR_STOP0		(1 << 0)  /*the clock supplies to timer0 is stopped */
+
+#define TCU_TSSR_WDTSS		(1 << 16)
+#define TCU_TSSR_OSTSS		(1 << 15)
+#define TCU_TSSR_STPS5		(1 << 5)
+#define TCU_TSSR_STPS4		(1 << 4)
+#define TCU_TSSR_STPS3		(1 << 3)
+#define TCU_TSSR_STPS2		(1 << 2)
+#define TCU_TSSR_STPS1		(1 << 1)
+#define TCU_TSSR_STPS0		(1 << 0)
+
+#define TCU_TSCR_WDTSC		(1 << 16)
+#define TCU_TSCR_OSTSC		(1 << 15)
+#define TCU_TSCR_STPC5		(1 << 5)
+#define TCU_TSCR_STPC4		(1 << 4)
+#define TCU_TSCR_STPC3		(1 << 3)
+#define TCU_TSCR_STPC2		(1 << 2)
+#define TCU_TSCR_STPC1		(1 << 1)
+#define TCU_TSCR_STPC0		(1 << 0)
+
+#define TCU_TER_OSTEN		(1 << 15) /* enable the counter in ost */
+#define TCU_TER_TCEN5		(1 << 5)  /* enable the counter in timer5 */
+#define TCU_TER_TCEN4		(1 << 4)
+#define TCU_TER_TCEN3		(1 << 3)
+#define TCU_TER_TCEN2		(1 << 2)
+#define TCU_TER_TCEN1		(1 << 1)
+#define TCU_TER_TCEN0		(1 << 0)
+
+#define TCU_TESR_OSTST		(1 << 15)
+#define TCU_TESR_TCST5		(1 << 5)
+#define TCU_TESR_TCST4		(1 << 4)
+#define TCU_TESR_TCST3		(1 << 3)
+#define TCU_TESR_TCST2		(1 << 2)
+#define TCU_TESR_TCST1		(1 << 1)
+#define TCU_TESR_TCST0		(1 << 0)
+
+#define TCU_TECR_OSTCL		(1 << 15)
+#define TCU_TECR_TCCL5		(1 << 5)
+#define TCU_TECR_TCCL4		(1 << 4)
+#define TCU_TECR_TCCL3		(1 << 3)
+#define TCU_TECR_TCCL2		(1 << 2)
+#define TCU_TECR_TCCL1		(1 << 1)
+#define TCU_TECR_TCCL0		(1 << 0)
+
+#define TCU_TFR_HFLAG5		(1 << 21) /* half comparison match flag */
+#define TCU_TFR_HFLAG4		(1 << 20)
+#define TCU_TFR_HFLAG3		(1 << 19)
+#define TCU_TFR_HFLAG2		(1 << 18)
+#define TCU_TFR_HFLAG1		(1 << 17)
+#define TCU_TFR_HFLAG0		(1 << 16)
+#define TCU_TFR_OSTFLAG		(1 << 15) /* ost comparison match flag */
+#define TCU_TFR_FFLAG5		(1 << 5)  /* full comparison match flag */
+#define TCU_TFR_FFLAG4		(1 << 4)
+#define TCU_TFR_FFLAG3		(1 << 3)
+#define TCU_TFR_FFLAG2		(1 << 2)
+#define TCU_TFR_FFLAG1		(1 << 1)
+#define TCU_TFR_FFLAG0		(1 << 0)
+
+#define TCU_TFSR_HFST5		(1 << 21)
+#define TCU_TFSR_HFST4		(1 << 20)
+#define TCU_TFSR_HFST3		(1 << 19)
+#define TCU_TFSR_HFST2		(1 << 18)
+#define TCU_TFSR_HFST1		(1 << 17)
+#define TCU_TFSR_HFST0		(1 << 16)
+#define TCU_TFSR_OSTFST		(1 << 15)
+#define TCU_TFSR_FFST5		(1 << 5)
+#define TCU_TFSR_FFST4		(1 << 4)
+#define TCU_TFSR_FFST3		(1 << 3)
+#define TCU_TFSR_FFST2		(1 << 2)
+#define TCU_TFSR_FFST1		(1 << 1)
+#define TCU_TFSR_FFST0		(1 << 0)
+
+#define TCU_TFCR_HFCL5		(1 << 21)
+#define TCU_TFCR_HFCL4		(1 << 20)
+#define TCU_TFCR_HFCL3		(1 << 19)
+#define TCU_TFCR_HFCL2		(1 << 18)
+#define TCU_TFCR_HFCL1		(1 << 17)
+#define TCU_TFCR_HFCL0		(1 << 16)
+#define TCU_TFCR_OSTFCL		(1 << 15)
+#define TCU_TFCR_FFCL5		(1 << 5)
+#define TCU_TFCR_FFCL4		(1 << 4)
+#define TCU_TFCR_FFCL3		(1 << 3)
+#define TCU_TFCR_FFCL2		(1 << 2)
+#define TCU_TFCR_FFCL1		(1 << 1)
+#define TCU_TFCR_FFCL0		(1 << 0)
+
+#define TCU_TMR_HMASK5		(1 << 21) /* half comparison match interrupt mask */
+#define TCU_TMR_HMASK4		(1 << 20)
+#define TCU_TMR_HMASK3		(1 << 19)
+#define TCU_TMR_HMASK2		(1 << 18)
+#define TCU_TMR_HMASK1		(1 << 17)
+#define TCU_TMR_HMASK0		(1 << 16)
+#define TCU_TMR_OSTMASK		(1 << 15) /* ost comparison match interrupt mask */
+#define TCU_TMR_FMASK5		(1 << 5)  /* full comparison match interrupt mask */
+#define TCU_TMR_FMASK4		(1 << 4)
+#define TCU_TMR_FMASK3		(1 << 3)
+#define TCU_TMR_FMASK2		(1 << 2)
+#define TCU_TMR_FMASK1		(1 << 1)
+#define TCU_TMR_FMASK0		(1 << 0)
+
+#define TCU_TMSR_HMST5		(1 << 21)
+#define TCU_TMSR_HMST4		(1 << 20)
+#define TCU_TMSR_HMST3		(1 << 19)
+#define TCU_TMSR_HMST2		(1 << 18)
+#define TCU_TMSR_HMST1		(1 << 17)
+#define TCU_TMSR_HMST0		(1 << 16)
+#define TCU_TMSR_OSTMST		(1 << 15)
+#define TCU_TMSR_FMST5		(1 << 5)
+#define TCU_TMSR_FMST4		(1 << 4)
+#define TCU_TMSR_FMST3		(1 << 3)
+#define TCU_TMSR_FMST2		(1 << 2)
+#define TCU_TMSR_FMST1		(1 << 1)
+#define TCU_TMSR_FMST0		(1 << 0)
+
+#define TCU_TMCR_HMCL5		(1 << 21)
+#define TCU_TMCR_HMCL4		(1 << 20)
+#define TCU_TMCR_HMCL3		(1 << 19)
+#define TCU_TMCR_HMCL2		(1 << 18)
+#define TCU_TMCR_HMCL1		(1 << 17)
+#define TCU_TMCR_HMCL0		(1 << 16)
+#define TCU_TMCR_OSTMCL		(1 << 15)
+#define TCU_TMCR_FMCL5		(1 << 5)
+#define TCU_TMCR_FMCL4		(1 << 4)
+#define TCU_TMCR_FMCL3		(1 << 3)
+#define TCU_TMCR_FMCL2		(1 << 2)
+#define TCU_TMCR_FMCL1		(1 << 1)
+#define TCU_TMCR_FMCL0		(1 << 0)
+
+#define TCU_TCSR_CNT_CLRZ	(1 << 10) /* clear counter to 0, only used in TCU2 mode */
+#define TCU_TCSR_PWM_SD		(1 << 9)  /* shut down the pwm output only used in TCU1 mode */
+#define TCU_TCSR_PWM_INITL_HIGH	(1 << 8)  /* selects an initial output level for pwm output */
+#define TCU_TCSR_PWM_EN		(1 << 7)  /* pwm pin output enable */
+#define TCU_TCSR_PRESCALE_BIT	3         /* select the tcnt count clock frequency*/
+#define TCU_TCSR_PRESCALE_MASK	(0x7 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1	(0x0 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE4	(0x1 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE16	(0x2 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE64	(0x3 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE256	(0x4 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1024	(0x5 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_EXT_EN		(1 << 2)  /* select extal as the timer clock input */
+#define TCU_TCSR_RTC_EN		(1 << 1)  /* select rtcclk as the timer clock input */
+#define TCU_TCSR_PCK_EN		(1 << 0)  /* select pclk as the timer clock input */
+
+#define TCU_TSTR_REAL2		(1 << 18) /* the value read from counter 2 is a real value */
+#define TCU_TSTR_REAL1		(1 << 17)
+#define TCU_TSTR_BUSY2		(1 << 2)  /* the counter 2 is busy now */
+#define TCU_TSTR_BUSY1		(1 << 1)
+
+#define TCU_TSTSR_REALS2	(1 << 18)
+#define TCU_TSTSR_REALS1	(1 << 17)
+#define TCU_TSTSR_BUSYS2	(1 << 2)
+#define TCU_TSTSR_BUSYS1	(1 << 1)
+
+#define TCU_TSTCR_REALC2	(1 << 18)
+#define TCU_TSTCR_REALC1	(1 << 17)
+#define TCU_TSTCR_BUSYC2	(1 << 2)
+#define TCU_TSTCR_BUSYC1	(1 << 1)
+
+#define TCU_OSTCR_CNT_MD		(1 << 15) /* when the value counter is equal to compare value,the counter is go on increasing till overflow,and then icrease from 0 */
+#define TCU_OSTCR_PWM_SD		(1 << 9) /* shut down the pwm output, only used in TCU1 mode */
+#define TCU_OSTCSR_PRESCALE_BIT		3
+#define TCU_OSTCSR_PRESCALE_MASK	(0x7 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE1		(0x0 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE4		(0x1 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE16		(0x2 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE64		(0x3 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE256	(0x4 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE1024	(0x5 << TCU_OSTCSR_PRESCALE_BIT)
+#define TCU_OSTCSR_EXT_EN		(1 << 2) /* select extal as the timer clock input */
+#define TCU_OSTCSR_RTC_EN		(1 << 1) /* select rtcclk as the timer clock input */
+#define TCU_OSTCSR_PCK_EN		(1 << 0) /* select pclk as the timer clock input */
+
+/*************************************************************************
+ * WDT (WatchDog Timer)
+ *************************************************************************/
+#define WDT_TDR		(WDT_BASE + 0x00)
+#define WDT_TCER	(WDT_BASE + 0x04)
+#define WDT_TCNT	(WDT_BASE + 0x08)
+#define WDT_TCSR	(WDT_BASE + 0x0C)
+
+#define REG_WDT_TDR	REG16(WDT_TDR)
+#define REG_WDT_TCER	REG8(WDT_TCER)
+#define REG_WDT_TCNT	REG16(WDT_TCNT)
+#define REG_WDT_TCSR	REG16(WDT_TCSR)
+
+// Register definition
+#define WDT_TCSR_PRESCALE_BIT	3
+#define WDT_TCSR_PRESCALE_MASK	(0x7 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1	(0x0 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE4	(0x1 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE16	(0x2 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE64	(0x3 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE256	(0x4 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1024	(0x5 << WDT_TCSR_PRESCALE_BIT)
+#define WDT_TCSR_EXT_EN		(1 << 2)
+#define WDT_TCSR_RTC_EN		(1 << 1)
+#define WDT_TCSR_PCK_EN		(1 << 0)
+
+#define WDT_TCER_TCEN		(1 << 0)
+
+
+/*************************************************************************
+ * DMAC (DMA Controller)
+ *************************************************************************/
+
+#define MAX_DMA_NUM	8  /* max 8 channels */
+#define HALF_DMA_NUM	4   /* the number of one dma controller's channels */
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define DMAC_DSAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x00 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA source address */
+#define DMAC_DTAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x04 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA target address */
+#define DMAC_DTCR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x08 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA transfer count */
+#define DMAC_DRSR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x0c + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA request source */
+#define DMAC_DCCSR(n) (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x10 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA control/status */
+#define DMAC_DCMD(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x14 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA command */
+#define DMAC_DDA(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x18 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA descriptor address */
+#define DMAC_DSD(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0xc0 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x04)) /* DMA Stride Address */
+
+#define DMAC_DMACR(m)	(DMAC_BASE + 0x0300 + 0x100 * (m))              /* DMA control register */
+#define DMAC_DMAIPR(m)	(DMAC_BASE + 0x0304 + 0x100 * (m))              /* DMA interrupt pending */
+#define DMAC_DMADBR(m)	(DMAC_BASE + 0x0308 + 0x100 * (m))              /* DMA doorbell */
+#define DMAC_DMADBSR(m)	(DMAC_BASE + 0x030C + 0x100 * (m))              /* DMA doorbell set */
+#define DMAC_DMACKE(m)  (DMAC_BASE + 0x0310 + 0x100 * (m))
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DTAR(n)	REG32(DMAC_DTAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DCMD(n)	REG32(DMAC_DCMD((n)))
+#define REG_DMAC_DDA(n)		REG32(DMAC_DDA((n)))
+#define REG_DMAC_DSD(n)         REG32(DMAC_DSD(n))
+#define REG_DMAC_DMACR(m)	REG32(DMAC_DMACR(m))
+#define REG_DMAC_DMAIPR(m)	REG32(DMAC_DMAIPR(m))
+#define REG_DMAC_DMADBR(m)	REG32(DMAC_DMADBR(m))
+#define REG_DMAC_DMADBSR(m)	REG32(DMAC_DMADBSR(m))
+#define REG_DMAC_DMACKE(m)      REG32(DMAC_DMACKE(m))
+
+// DMA request source register
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x3f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_EXT	(0 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_NAND	(1 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_ENC	(2 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_DEC	(3 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO	(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TSSIIN	(9 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3OUT	(14 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3IN	(15 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2OUT	(16 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2IN	(17 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1OUT	(18 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1IN	(19 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT	(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN	(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0OUT	(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0IN	(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT	(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN	(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0OUT	(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0IN	(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TCU	(28 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SADC	(29 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1OUT	(30 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1IN	(31 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1OUT	(32 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1IN	(33 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMOUT	(34 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMIN	(35 << DMAC_DRSR_RS_BIT)
+
+// DMA channel control/status register
+#define DMAC_DCCSR_NDES		(1 << 31) /* descriptor (0) or not (1) ? */
+#define DMAC_DCCSR_DES8    	(1 << 30) /* Descriptor 8 Word */
+#define DMAC_DCCSR_DES4    	(0 << 30) /* Descriptor 4 Word */
+#define DMAC_DCCSR_CDOA_BIT	16        /* copy of DMA offset address */
+#define DMAC_DCCSR_CDOA_MASK	(0xff << DMAC_DCCSR_CDOA_BIT)
+#define DMAC_DCCSR_BERR		(1 << 7)  /* BCH error within this transfer, Only for channel 0 */
+#define DMAC_DCCSR_INV		(1 << 6)  /* descriptor invalid */
+#define DMAC_DCCSR_AR		(1 << 4)  /* address error */
+#define DMAC_DCCSR_TT		(1 << 3)  /* transfer terminated */
+#define DMAC_DCCSR_HLT		(1 << 2)  /* DMA halted */
+#define DMAC_DCCSR_CT		(1 << 1)  /* count terminated */
+#define DMAC_DCCSR_EN		(1 << 0)  /* channel enable bit */
+
+// DMA channel command register
+#define DMAC_DCMD_EACKS_LOW  	(1 << 31) /* External DACK Output Level Select, active low */
+#define DMAC_DCMD_EACKS_HIGH  	(0 << 31) /* External DACK Output Level Select, active high */
+#define DMAC_DCMD_EACKM_WRITE 	(1 << 30) /* External DACK Output Mode Select, output in write cycle */
+#define DMAC_DCMD_EACKM_READ 	(0 << 30) /* External DACK Output Mode Select, output in read cycle */
+#define DMAC_DCMD_ERDM_BIT      28        /* External DREQ Detection Mode Select */
+#define DMAC_DCMD_ERDM_MASK     (0x03 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_LOW    (0 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_FALL   (1 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_HIGH   (2 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_RISE   (3 << DMAC_DCMD_ERDM_BIT)
+#define DMAC_DCMD_BLAST		(1 << 25) /* BCH last */
+#define DMAC_DCMD_SAI		(1 << 23) /* source address increment */
+#define DMAC_DCMD_DAI		(1 << 22) /* dest address increment */
+#define DMAC_DCMD_RDIL_BIT	16        /* request detection interval length */
+#define DMAC_DCMD_RDIL_MASK	(0x0f << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_IGN	(0 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_2	(1 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_4	(2 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_8	(3 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_12	(4 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_16	(5 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_20	(6 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_24	(7 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_28	(8 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_32	(9 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_48	(10 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_60	(11 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_64	(12 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_124	(13 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_128	(14 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_200	(15 << DMAC_DCMD_RDIL_BIT)
+#define DMAC_DCMD_SWDH_BIT	14  /* source port width */
+#define DMAC_DCMD_SWDH_MASK	(0x03 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_32	(0 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_8	(1 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_16	(2 << DMAC_DCMD_SWDH_BIT)
+#define DMAC_DCMD_DWDH_BIT	12  /* dest port width */
+#define DMAC_DCMD_DWDH_MASK	(0x03 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_32	(0 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_8	(1 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_16	(2 << DMAC_DCMD_DWDH_BIT)
+#define DMAC_DCMD_DS_BIT	8  /* transfer data size of a data unit */
+#define DMAC_DCMD_DS_MASK	(0x07 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BIT	(0 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_8BIT	(1 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BIT	(2 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BYTE	(3 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BYTE	(4 << DMAC_DCMD_DS_BIT)
+#define DMAC_DCMD_STDE   	(1 << 5)  /* Stride Disable/Enable */
+#define DMAC_DCMD_DES_V		(1 << 4)  /* descriptor valid flag */
+#define DMAC_DCMD_DES_VM	(1 << 3)  /* descriptor valid mask: 1:support V-bit */
+#define DMAC_DCMD_DES_VIE	(1 << 2)  /* DMA valid error interrupt enable */
+#define DMAC_DCMD_TIE		(1 << 1)  /* DMA transfer interrupt enable */
+#define DMAC_DCMD_LINK		(1 << 0)  /* descriptor link enable */
+
+// DMA descriptor address register
+#define DMAC_DDA_BASE_BIT	12  /* descriptor base address */
+#define DMAC_DDA_BASE_MASK	(0x0fffff << DMAC_DDA_BASE_BIT)
+#define DMAC_DDA_OFFSET_BIT	4   /* descriptor offset address */
+#define DMAC_DDA_OFFSET_MASK	(0x0ff << DMAC_DDA_OFFSET_BIT)
+
+// DMA stride address register
+#define DMAC_DSD_TSD_BIT        16  /* target stride address */
+#define DMAC_DSD_TSD_MASK      	(0xffff << DMAC_DSD_TSD_BIT)
+#define DMAC_DSD_SSD_BIT        0  /* source stride address */
+#define DMAC_DSD_SSD_MASK      	(0xffff << DMAC_DSD_SSD_BIT)
+
+// DMA control register
+#define DMAC_DMACR_FMSC		(1 << 31)  /* MSC Fast DMA mode */
+#define DMAC_DMACR_FSSI		(1 << 30)  /* SSI Fast DMA mode */
+#define DMAC_DMACR_FTSSI	(1 << 29)  /* TSSI Fast DMA mode */
+#define DMAC_DMACR_FUART	(1 << 28)  /* UART Fast DMA mode */
+#define DMAC_DMACR_FAIC		(1 << 27)  /* AIC Fast DMA mode */
+#define DMAC_DMACR_PR_BIT	8  /* channel priority mode */
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_012345	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_120345	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_230145	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_340125	(3 << DMAC_DMACR_PR_BIT)
+#define DMAC_DMACR_HLT		(1 << 3)  /* DMA halt flag */
+#define DMAC_DMACR_AR		(1 << 2)  /* address error flag */
+#define DMAC_DMACR_DMAE		(1 << 0)  /* DMA enable bit */
+
+// DMA doorbell register
+#define DMAC_DMADBR_DB5		(1 << 5)  /* doorbell for channel 5 */
+#define DMAC_DMADBR_DB4		(1 << 4)  /* doorbell for channel 4 */
+#define DMAC_DMADBR_DB3		(1 << 3)  /* doorbell for channel 3 */
+#define DMAC_DMADBR_DB2		(1 << 2)  /* doorbell for channel 2 */
+#define DMAC_DMADBR_DB1		(1 << 1)  /* doorbell for channel 1 */
+#define DMAC_DMADBR_DB0		(1 << 0)  /* doorbell for channel 0 */
+
+// DMA doorbell set register
+#define DMAC_DMADBSR_DBS5	(1 << 5)  /* enable doorbell for channel 5 */
+#define DMAC_DMADBSR_DBS4	(1 << 4)  /* enable doorbell for channel 4 */
+#define DMAC_DMADBSR_DBS3	(1 << 3)  /* enable doorbell for channel 3 */
+#define DMAC_DMADBSR_DBS2	(1 << 2)  /* enable doorbell for channel 2 */
+#define DMAC_DMADBSR_DBS1	(1 << 1)  /* enable doorbell for channel 1 */
+#define DMAC_DMADBSR_DBS0	(1 << 0)  /* enable doorbell for channel 0 */
+
+// DMA interrupt pending register
+#define DMAC_DMAIPR_CIRQ5	(1 << 5)  /* irq pending status for channel 5 */
+#define DMAC_DMAIPR_CIRQ4	(1 << 4)  /* irq pending status for channel 4 */
+#define DMAC_DMAIPR_CIRQ3	(1 << 3)  /* irq pending status for channel 3 */
+#define DMAC_DMAIPR_CIRQ2	(1 << 2)  /* irq pending status for channel 2 */
+#define DMAC_DMAIPR_CIRQ1	(1 << 1)  /* irq pending status for channel 1 */
+#define DMAC_DMAIPR_CIRQ0	(1 << 0)  /* irq pending status for channel 0 */
+
+
+/*************************************************************************
+ * GPIO (General-Purpose I/O Ports)
+ *************************************************************************/
+#define MAX_GPIO_NUM	192
+#define GPIO_WAKEUP     (32 * 4 + 30)
+
+//n = 0,1,2,3,4,5 (PORTA, PORTB, PORTC, PORTD, PORTE, PORTF)
+#define GPIO_PXPIN(n)	(GPIO_BASE + (0x00 + (n)*0x100)) /* PIN Level Register */
+#define GPIO_PXDAT(n)	(GPIO_BASE + (0x10 + (n)*0x100)) /* Port Data Register */
+#define GPIO_PXDATS(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Data Set Register */
+#define GPIO_PXDATC(n)	(GPIO_BASE + (0x18 + (n)*0x100)) /* Port Data Clear Register */
+#define GPIO_PXIM(n)	(GPIO_BASE + (0x20 + (n)*0x100)) /* Interrupt Mask Register */
+#define GPIO_PXIMS(n)	(GPIO_BASE + (0x24 + (n)*0x100)) /* Interrupt Mask Set Reg */
+#define GPIO_PXIMC(n)	(GPIO_BASE + (0x28 + (n)*0x100)) /* Interrupt Mask Clear Reg */
+#define GPIO_PXPE(n)	(GPIO_BASE + (0x30 + (n)*0x100)) /* Pull Enable Register */
+#define GPIO_PXPES(n)	(GPIO_BASE + (0x34 + (n)*0x100)) /* Pull Enable Set Reg. */
+#define GPIO_PXPEC(n)	(GPIO_BASE + (0x38 + (n)*0x100)) /* Pull Enable Clear Reg. */
+#define GPIO_PXFUN(n)	(GPIO_BASE + (0x40 + (n)*0x100)) /* Function Register */
+#define GPIO_PXFUNS(n)	(GPIO_BASE + (0x44 + (n)*0x100)) /* Function Set Register */
+#define GPIO_PXFUNC(n)	(GPIO_BASE + (0x48 + (n)*0x100)) /* Function Clear Register */
+#define GPIO_PXSEL(n)	(GPIO_BASE + (0x50 + (n)*0x100)) /* Select Register */
+#define GPIO_PXSELS(n)	(GPIO_BASE + (0x54 + (n)*0x100)) /* Select Set Register */
+#define GPIO_PXSELC(n)	(GPIO_BASE + (0x58 + (n)*0x100)) /* Select Clear Register */
+#define GPIO_PXDIR(n)	(GPIO_BASE + (0x60 + (n)*0x100)) /* Direction Register */
+#define GPIO_PXDIRS(n)	(GPIO_BASE + (0x64 + (n)*0x100)) /* Direction Set Register */
+#define GPIO_PXDIRC(n)	(GPIO_BASE + (0x68 + (n)*0x100)) /* Direction Clear Register */
+#define GPIO_PXTRG(n)	(GPIO_BASE + (0x70 + (n)*0x100)) /* Trigger Register */
+#define GPIO_PXTRGS(n)	(GPIO_BASE + (0x74 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXTRGC(n)	(GPIO_BASE + (0x78 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXFLG(n)	(GPIO_BASE + (0x80 + (n)*0x100)) /* Port Flag Register */
+#define GPIO_PXFLGC(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Flag Clear Register */
+
+#define REG_GPIO_PXPIN(n)	REG32(GPIO_PXPIN((n)))  /* PIN level */
+#define REG_GPIO_PXDAT(n)	REG32(GPIO_PXDAT((n)))  /* 1: interrupt pending */
+#define REG_GPIO_PXDATS(n)	REG32(GPIO_PXDATS((n)))
+#define REG_GPIO_PXDATC(n)	REG32(GPIO_PXDATC((n)))
+#define REG_GPIO_PXIM(n)	REG32(GPIO_PXIM((n)))   /* 1: mask pin interrupt */
+#define REG_GPIO_PXIMS(n)	REG32(GPIO_PXIMS((n)))
+#define REG_GPIO_PXIMC(n)	REG32(GPIO_PXIMC((n)))
+#define REG_GPIO_PXPE(n)	REG32(GPIO_PXPE((n)))   /* 1: disable pull up/down */
+#define REG_GPIO_PXPES(n)	REG32(GPIO_PXPES((n)))
+#define REG_GPIO_PXPEC(n)	REG32(GPIO_PXPEC((n)))
+#define REG_GPIO_PXFUN(n)	REG32(GPIO_PXFUN((n)))  /* 0:GPIO or intr, 1:FUNC */
+#define REG_GPIO_PXFUNS(n)	REG32(GPIO_PXFUNS((n)))
+#define REG_GPIO_PXFUNC(n)	REG32(GPIO_PXFUNC((n)))
+#define REG_GPIO_PXSEL(n)	REG32(GPIO_PXSEL((n))) /* 0:GPIO/Fun0,1:intr/fun1*/
+#define REG_GPIO_PXSELS(n)	REG32(GPIO_PXSELS((n)))
+#define REG_GPIO_PXSELC(n)	REG32(GPIO_PXSELC((n)))
+#define REG_GPIO_PXDIR(n)	REG32(GPIO_PXDIR((n))) /* 0:input/low-level-trig/falling-edge-trig, 1:output/high-level-trig/rising-edge-trig */
+#define REG_GPIO_PXDIRS(n)	REG32(GPIO_PXDIRS((n)))
+#define REG_GPIO_PXDIRC(n)	REG32(GPIO_PXDIRC((n)))
+#define REG_GPIO_PXTRG(n)	REG32(GPIO_PXTRG((n))) /* 0:level-trigger, 1:edge-trigger */
+#define REG_GPIO_PXTRGS(n)	REG32(GPIO_PXTRGS((n)))
+#define REG_GPIO_PXTRGC(n)	REG32(GPIO_PXTRGC((n)))
+#define REG_GPIO_PXFLG(n)	REG32(GPIO_PXFLG((n))) /* interrupt flag */
+#define REG_GPIO_PXFLGC(n)	REG32(GPIO_PXFLGC((n))) /* interrupt flag */
+
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* Register Offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+#define OFF_UMR		(0x24)	/* RW 8b H'00, UART M Register */
+#define OFF_UACR	(0x28)	/* RW 8b H'00, UART Add Cycle Register */
+
+/* Register Address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+#define UART0_UMR	(UART0_BASE + OFF_UMR)
+#define UART0_UACR	(UART0_BASE + OFF_UACR)
+
+#define UART1_RDR	(UART1_BASE + OFF_RDR)
+#define UART1_TDR	(UART1_BASE + OFF_TDR)
+#define UART1_DLLR	(UART1_BASE + OFF_DLLR)
+#define UART1_DLHR	(UART1_BASE + OFF_DLHR)
+#define UART1_IER	(UART1_BASE + OFF_IER)
+#define UART1_ISR	(UART1_BASE + OFF_ISR)
+#define UART1_FCR	(UART1_BASE + OFF_FCR)
+#define UART1_LCR	(UART1_BASE + OFF_LCR)
+#define UART1_MCR	(UART1_BASE + OFF_MCR)
+#define UART1_LSR	(UART1_BASE + OFF_LSR)
+#define UART1_MSR	(UART1_BASE + OFF_MSR)
+#define UART1_SPR	(UART1_BASE + OFF_SPR)
+#define UART1_SIRCR	(UART1_BASE + OFF_SIRCR)
+
+#define UART2_RDR	(UART2_BASE + OFF_RDR)
+#define UART2_TDR	(UART2_BASE + OFF_TDR)
+#define UART2_DLLR	(UART2_BASE + OFF_DLLR)
+#define UART2_DLHR	(UART2_BASE + OFF_DLHR)
+#define UART2_IER	(UART2_BASE + OFF_IER)
+#define UART2_ISR	(UART2_BASE + OFF_ISR)
+#define UART2_FCR	(UART2_BASE + OFF_FCR)
+#define UART2_LCR	(UART2_BASE + OFF_LCR)
+#define UART2_MCR	(UART2_BASE + OFF_MCR)
+#define UART2_LSR	(UART2_BASE + OFF_LSR)
+#define UART2_MSR	(UART2_BASE + OFF_MSR)
+#define UART2_SPR	(UART2_BASE + OFF_SPR)
+#define UART2_SIRCR	(UART2_BASE + OFF_SIRCR)
+
+#define UART3_RDR	(UART3_BASE + OFF_RDR)
+#define UART3_TDR	(UART3_BASE + OFF_TDR)
+#define UART3_DLLR	(UART3_BASE + OFF_DLLR)
+#define UART3_DLHR	(UART3_BASE + OFF_DLHR)
+#define UART3_IER	(UART3_BASE + OFF_IER)
+#define UART3_ISR	(UART3_BASE + OFF_ISR)
+#define UART3_FCR	(UART3_BASE + OFF_FCR)
+#define UART3_LCR	(UART3_BASE + OFF_LCR)
+#define UART3_MCR	(UART3_BASE + OFF_MCR)
+#define UART3_LSR	(UART3_BASE + OFF_LSR)
+#define UART3_MSR	(UART3_BASE + OFF_MSR)
+#define UART3_SPR	(UART3_BASE + OFF_SPR)
+#define UART3_SIRCR	(UART3_BASE + OFF_SIRCR)
+
+
+/*
+ * Define macros for UARTIER
+ * UART Interrupt Enable Register
+ */
+#define UARTIER_RIE	(1 << 0)	/* 0: receive fifo full interrupt disable */
+#define UARTIER_TIE	(1 << 1)	/* 0: transmit fifo empty interrupt disable */
+#define UARTIER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UARTIER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UARTIER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UARTISR
+ * UART Interrupt Status Register
+ */
+#define UARTISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UARTISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UARTISR_IID_MSI		(0 << 1)  /* Modem status interrupt */
+#define UARTISR_IID_THRI	(1 << 1)  /* Transmitter holding register empty */
+#define UARTISR_IID_RDI		(2 << 1)  /* Receiver data interrupt */
+#define UARTISR_IID_RLSI	(3 << 1)  /* Receiver line status interrupt */
+#define UARTISR_IID_RTO		(6 << 1)  /* Receive timeout */
+#define UARTISR_FFMS		(3 << 6)  /* FIFO mode select, set when UARTFCR.FE is set to 1 */
+#define UARTISR_FFMS_NO_FIFO	(0 << 6)
+#define UARTISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UARTFCR
+ * UART FIFO Control Register
+ */
+#define UARTFCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UARTFCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UARTFCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UARTFCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UARTFCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UARTFCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UARTFCR_RTRG_1	(0 << 6)
+#define UARTFCR_RTRG_4	(1 << 6)
+#define UARTFCR_RTRG_8	(2 << 6)
+#define UARTFCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UARTLCR
+ * UART Line Control Register
+ */
+#define UARTLCR_WLEN	(3 << 0)	/* word length */
+#define UARTLCR_WLEN_5	(0 << 0)
+#define UARTLCR_WLEN_6	(1 << 0)
+#define UARTLCR_WLEN_7	(2 << 0)
+#define UARTLCR_WLEN_8	(3 << 0)
+#define UARTLCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UARTLCR_STOP1	(0 << 2)
+#define UARTLCR_STOP2	(1 << 2)
+#define UARTLCR_PE	(1 << 3)	/* 0: parity disable */
+#define UARTLCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UARTLCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UARTLCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UARTLCR_DLAB	(1 << 7)	/* 0: access UARTRDR/TDR/IER  1: access UARTDLLR/DLHR */
+
+/*
+ * Define macros for UARTLSR
+ * UART Line Status Register
+ */
+#define UARTLSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UARTLSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UARTLSR_PER	(1 << 2)	/* 0: no parity error */
+#define UARTLSR_FER	(1 << 3)	/* 0; no framing error */
+#define UARTLSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UARTLSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UARTLSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UARTLSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UARTMCR
+ * UART Modem Control Register
+ */
+#define UARTMCR_RTS	(1 << 1)	/* 0: RTS_ output high, 1: RTS_ output low */
+#define UARTMCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UARTMCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UARTMSR
+ * UART Modem Status Register
+ */
+#define UARTMSR_CCTS	(1 << 0)        /* 1: a change on CTS_ pin */
+#define UARTMSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)  /* 0: transmitter is in UART mode  1: SIR mode */
+#define SIRCR_RSIRE	(1 << 1)  /* 0: receiver is in UART mode  1: SIR mode */
+#define SIRCR_TPWS	(1 << 2)  /* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TDPL	(1 << 3)  /* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RDPL	(1 << 4)  /* 0: decoder interprets positive pulse as 0 */
+
+
+/*************************************************************************
+ * AIC (AC97/I2S Controller)
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12        /* Receive FIFO Threshold */
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8         /* Transmit FIFO Threshold */
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_LSMP		(1 << 6)  /* Play Zero sample or last sample */
+#define	AIC_FR_ICDC		(1 << 5)  /* External(0) or Internal CODEC(1) */
+#define	AIC_FR_AUSEL		(1 << 4)  /* AC97(0) or I2S/MSB-justified(1) */
+#define	AIC_FR_RST		(1 << 3)  /* AIC registers reset */
+#define	AIC_FR_BCKD		(1 << 2)  /* I2S BIT_CLK direction, 0:input,1:output */
+#define	AIC_FR_SYNCD		(1 << 1)  /* I2S SYNC direction, 0:input,1:output */
+#define	AIC_FR_ENB		(1 << 0)  /* AIC enable bit */
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_OSS_BIT		19  /* Output Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_OSS_MASK		(0x7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0x0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(0x1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(0x2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(0x3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(0x4 << AIC_CR_OSS_BIT)
+#define	AIC_CR_ISS_BIT		16  /* Input Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_ISS_MASK		(0x7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0x0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(0x1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(0x2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(0x3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(0x4 << AIC_CR_ISS_BIT)
+#define	AIC_CR_RDMS		(1 << 15)  /* Receive DMA enable */
+#define	AIC_CR_TDMS		(1 << 14)  /* Transmit DMA enable */
+#define	AIC_CR_M2S		(1 << 11)  /* Mono to Stereo enable */
+#define	AIC_CR_ENDSW		(1 << 10)  /* Endian switch enable */
+#define	AIC_CR_AVSTSU		(1 << 9)   /* Signed <-> Unsigned toggle enable */
+#define	AIC_CR_FLUSH_TX		(1 << 8)   /* Flush TX FIFO */
+#define	AIC_CR_FLUSH_RX		(1 << 7)   /* Flush RX FIFO */
+#define	AIC_CR_EROR		(1 << 6)   /* Enable ROR interrupt */
+#define	AIC_CR_ETUR		(1 << 5)   /* Enable TUR interrupt */
+#define	AIC_CR_ERFS		(1 << 4)   /* Enable RFS interrupt */
+#define	AIC_CR_ETFS		(1 << 3)   /* Enable TFS interrupt */
+#define	AIC_CR_ENLBF		(1 << 2)   /* Enable Loopback Function */
+#define	AIC_CR_ERPL		(1 << 1)   /* Enable Playback Function */
+#define	AIC_CR_EREC		(1 << 0)   /* Enable Record Function */
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16          /* Receive Valid Slots */
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit, PCM Left */
+#define	AIC_ACCR1_XS_BIT	0          /* Transmit Valid Slots */
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit, PCM Left */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18) /* Enable RSTO interrupt */
+#define	AIC_ACCR2_ESADR		(1 << 17) /* Enable SADR interrupt */
+#define	AIC_ACCR2_ECADT		(1 << 16) /* Enable CADT interrupt */
+#define	AIC_ACCR2_OASS_BIT	8  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)  /* SDATA_OUT output value */
+#define	AIC_ACCR2_SR		(1 << 2)  /* RESET# pin level */
+#define	AIC_ACCR2_SS		(1 << 1)  /* SYNC pin level */
+#define	AIC_ACCR2_SA		(1 << 0)  /* SYNC and SDATA_OUT alternation */
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12) /* Stop BIT_CLK for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_BIT	1  /* Input/Output Sample Size for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0) /* 0:I2S, 1:MSB-justified */
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24  /* Receive FIFO Level */
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8   /* Transmit FIFO level */
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6) /* Receive FIFO Overrun */
+#define	AIC_SR_TUR		(1 << 5) /* Transmit FIFO Underrun */
+#define	AIC_SR_RFS		(1 << 4) /* Receive FIFO Service Request */
+#define	AIC_SR_TFS		(1 << 3) /* Transmit FIFO Service Request */
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_SLTERR		(1 << 21) /* Slot Error Flag */
+#define	AIC_ACSR_CRDY		(1 << 20) /* External CODEC Ready Flag */
+#define	AIC_ACSR_CLPM		(1 << 19) /* External CODEC low power mode flag */
+#define	AIC_ACSR_RSTO		(1 << 18) /* External CODEC regs read status timeout */
+#define	AIC_ACSR_SADR		(1 << 17) /* External CODEC regs status addr and data received */
+#define	AIC_ACSR_CADT		(1 << 16) /* Command Address and Data Transmitted */
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)  /* AIC Busy in I2S/MSB-justified format */
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+/*************************************************************************
+ * ICDC (Internal CODEC)
+ *************************************************************************/
+
+#define	ICDC_CKCFG	  (ICDC_BASE + 0x00a0)  /* Clock Configure Register */
+#define	ICDC_RGADW	  (ICDC_BASE + 0x00a4)  /* internal register access control */
+#define	ICDC_RGDATA	  (ICDC_BASE + 0x00a8)  /* internal register data output */
+
+#define	REG_ICDC_CKCFG		REG32(ICDC_CKCFG)
+#define	REG_ICDC_RGADW		REG32(ICDC_RGADW)
+#define	REG_ICDC_RGDATA		REG32(ICDC_RGDATA)
+
+/* ICDC Clock Configure Register */
+#define	ICDC_CKCFG_CKRDY	(1 << 1)
+#define	ICDC_CKCFG_SELAD	(1 << 0)
+
+/* ICDC internal register access control Register */
+#define ICDC_RGADW_RGWR         (1 << 16)
+#define ICDC_RGADW_RGADDR_BIT   8
+#define	ICDC_RGADW_RGADDR_MASK	(0x7f << ICDC_RGADW_RGADDR_BIT)
+#define ICDC_RGADW_RGDIN_BIT    0
+#define	ICDC_RGADW_RGDIN_MASK	(0xff << ICDC_RGADW_RGDIN_BIT)
+
+/* ICDC internal register data output Register */
+#define ICDC_RGDATA_IRQ         (1 << 8)
+#define ICDC_RGDATA_RGDOUT_BIT  0
+#define ICDC_RGDATA_RGDOUT_MASK (0xff << ICDC_RGDATA_RGDOUT_BIT)
+
+/*************************************************************************
+ * PCM Controller
+ *************************************************************************/
+
+#define PCM_CTL                 (PCM_BASE + 0x000)
+#define PCM_CFG                 (PCM_BASE + 0x004)
+#define PCM_DP                  (PCM_BASE + 0x008)
+#define PCM_INTC                (PCM_BASE + 0x00c)
+#define PCM_INTS                (PCM_BASE + 0x010)
+#define PCM_DIV                 (PCM_BASE + 0x014)
+
+#define REG_PCM_CTL             REG32(PCM_CTL)
+#define REG_PCM_CFG             REG32(PCM_CFG)
+#define REG_PCM_DP              REG32(PCM_DP)
+#define REG_PCM_INTC            REG32(PCM_INTC)
+#define REG_PCM_INTS            REG32(PCM_INTS)
+#define REG_PCM_DIV             REG32(PCM_DIV)
+
+/* PCM Controller control Register (PCM_CTL) */
+
+#define PCM_CTL_ERDMA		(1 << 9)  /* Enable Receive DMA */
+#define PCM_CTL_ETDMA           (1 << 8)  /* Enable Transmit DMA */
+#define PCM_CTL_LSMP		(1 << 7)  /* Play Zero sample or last sample */
+#define PCM_CTL_ERPL            (1 << 6)  /* Enable Playing Back Function */
+#define PCM_CTL_EREC            (1 << 5)  /* Enable Recording Function */
+#define PCM_CTL_FLUSH           (1 << 4)  /* FIFO flush */
+#define PCM_CTL_RST             (1 << 3)  /* Reset PCM */
+#define PCM_CTL_CLKEN           (1 << 1)  /* Enable the clock division logic */
+#define PCM_CTL_PCMEN           (1 << 0)  /* Enable PCM module */
+
+/* PCM Controller configure Register (PCM_CFG) */
+
+#define PCM_CFG_SLOT_BIT        13
+#define PCM_CFG_SLOT_MASK       (0x3 << PCM_CFG_SLOT_BIT)
+  #define PCM_CFG_SLOT_0	  (0 << PCM_CFG_SLOT_BIT) /* Slot is 0 */
+  #define PCM_CFG_SLOT_1	  (1 << PCM_CFG_SLOT_BIT) /* Slot is 1 */
+  #define PCM_CFG_SLOT_2	  (2 << PCM_CFG_SLOT_BIT) /* Slot is 2 */
+  #define PCM_CFG_SLOT_3	  (3 << PCM_CFG_SLOT_BIT) /* Slot is 3 */
+#define PCM_CFG_ISS_BIT         12
+#define PCM_CFG_ISS_MASK        (0x1 << PCM_CFG_ISS_BIT)
+  #define PCM_CFG_ISS_8           (0 << PCM_CFG_ISS_BIT)
+  #define PCM_CFG_ISS_16          (1 << PCM_CFG_ISS_BIT)
+#define PCM_CFG_OSS_BIT         11
+#define PCM_CFG_OSS_MASK        (0x1 << PCM_CFG_OSS_BIT)
+  #define PCM_CFG_OSS_8           (0 << PCM_CFG_OSS_BIT)
+  #define PCM_CFG_OSS_16          (1 << PCM_CFG_OSS_BIT)
+#define PCM_CFG_IMSBPOS         (1 << 10)
+#define PCM_CFG_OMSBPOS         (1 << 9)
+#define	PCM_CFG_RFTH_BIT	5        /* Receive FIFO Threshold */
+#define	PCM_CFG_RFTH_MASK	(0xf << PCM_CFG_RFTH_BIT)
+#define	PCM_CFG_TFTH_BIT	1         /* Transmit FIFO Threshold */
+#define	PCM_CFG_TFTH_MASK	(0xf << PCM_CFG_TFTH_BIT)
+#define PCM_CFG_MODE            (0x0 << 0)
+
+/* PCM Controller interrupt control Register (PCM_INTC) */
+
+#define PCM_INTC_ETFS           (1 << 3)
+#define PCM_INTC_ETUR           (1 << 2)
+#define PCM_INTC_ERFS           (1 << 1)
+#define PCM_INTC_EROR           (1 << 0)
+
+/* PCM Controller interrupt status Register (PCM_INTS) */
+
+#define PCM_INTS_RSTS		(1 << 14) /* Reset or flush has not complete */
+#define PCM_INTS_TFL_BIT        9
+#define PCM_INTS_TFL_MASK       (0x1f << PCM_INTS_TFL_BIT)
+#define PCM_INTS_TFS		(1 << 8) /* Tranmit FIFO Service Request */
+#define PCM_INTS_TUR		(1 << 7) /* Transmit FIFO Under Run */
+#define PCM_INTS_RFL_BIT        2
+#define PCM_INTS_RFL_MASK       (0x1f << PCM_INTS_RFL_BIT)
+#define PCM_INTS_RFS		(1 << 1) /* Receive FIFO Service Request */
+#define PCM_INTS_ROR		(1 << 0) /* Receive FIFO Over Run */
+
+/* PCM Controller clock division Register (PCM_DIV) */
+#define PCM_DIV_SYNL_BIT        11
+#define PCM_DIV_SYNL_MASK       (0x3f << PCM_DIV_SYNL_BIT)
+#define PCM_DIV_SYNDIV_BIT      6
+#define PCM_DIV_SYNDIV_MASK     (0x1f << PCM_DIV_SYNDIV_BIT)
+#define PCM_DIV_CLKDIV_BIT      0
+#define PCM_DIV_CLKDIV_MASK     (0x3f << PCM_DIV_CLKDIV_BIT)
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+/*************************************************************************
+ * SSI (Synchronous Serial Interface)
+ *************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define	SSI_DR(n)		(SSI_BASE + 0x000 + (n)*0x2000)
+#define	SSI_CR0(n)		(SSI_BASE + 0x004 + (n)*0x2000)
+#define	SSI_CR1(n)		(SSI_BASE + 0x008 + (n)*0x2000)
+#define	SSI_SR(n)		(SSI_BASE + 0x00C + (n)*0x2000)
+#define	SSI_ITR(n)		(SSI_BASE + 0x010 + (n)*0x2000)
+#define	SSI_ICR(n)		(SSI_BASE + 0x014 + (n)*0x2000)
+#define	SSI_GR(n)		(SSI_BASE + 0x018 + (n)*0x2000)
+
+#define	REG_SSI_DR(n)		REG32(SSI_DR(n))
+#define	REG_SSI_CR0(n)		REG16(SSI_CR0(n))
+#define	REG_SSI_CR1(n)		REG32(SSI_CR1(n))
+#define	REG_SSI_SR(n)		REG32(SSI_SR(n))
+#define	REG_SSI_ITR(n)		REG16(SSI_ITR(n))
+#define	REG_SSI_ICR(n)		REG8(SSI_ICR(n))
+#define	REG_SSI_GR(n)		REG16(SSI_GR(n))
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+#define SSI_MAX_FIFO_ENTRIES 	128 /* 128 txfifo and 128 rxfifo */
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_EACLRUN		(1 << 7) /* hardware auto clear underrun when TxFifo no empty */
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_TTRG_BIT	16 /* SSI1 TX trigger */
+#define SSI_CR1_TTRG_MASK	(0xf << SSI_CR1_TTRG_BIT)
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_RTRG_BIT	8 /* SSI RX trigger */
+#define SSI_CR1_RTRG_MASK	(0xf << SSI_CR1_RTRG_BIT)
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	16
+#define SSI_SR_TFIFONUM_MASK	(0xff << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0xff << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+
+/*************************************************************************
+ * MSC
+ ************************************************************************/
+#define JZ_MAX_MSC_NUM 2
+
+#define JZ_MSC_ID_INVALID(msc_id) ( ((msc_id) < 0) || ( (msc_id) > JZ_MAX_MSC_NUM ) )
+/* n = 0, 1 (MSC0, MSC1) */
+#define	MSC_STRPCL(n)		(MSC_BASE + (n)*0x1000 + 0x000)
+#define	MSC_STAT(n)		(MSC_BASE + (n)*0x1000 + 0x004)
+#define	MSC_CLKRT(n)		(MSC_BASE + (n)*0x1000 + 0x008)
+#define	MSC_CMDAT(n)		(MSC_BASE + (n)*0x1000 + 0x00C)
+#define	MSC_RESTO(n)		(MSC_BASE + (n)*0x1000 + 0x010)
+#define	MSC_RDTO(n)		(MSC_BASE + (n)*0x1000 + 0x014)
+#define	MSC_BLKLEN(n)		(MSC_BASE + (n)*0x1000 + 0x018)
+#define	MSC_NOB(n)		(MSC_BASE + (n)*0x1000 + 0x01C)
+#define	MSC_SNOB(n)		(MSC_BASE + (n)*0x1000 + 0x020)
+#define	MSC_IMASK(n)		(MSC_BASE + (n)*0x1000 + 0x024)
+#define	MSC_IREG(n)		(MSC_BASE + (n)*0x1000 + 0x028)
+#define	MSC_CMD(n)		(MSC_BASE + (n)*0x1000 + 0x02C)
+#define	MSC_ARG(n)		(MSC_BASE + (n)*0x1000 + 0x030)
+#define	MSC_RES(n)		(MSC_BASE + (n)*0x1000 + 0x034)
+#define	MSC_RXFIFO(n)		(MSC_BASE + (n)*0x1000 + 0x038)
+#define	MSC_TXFIFO(n)		(MSC_BASE + (n)*0x1000 + 0x03C)
+#define	MSC_LPM(n)		(MSC_BASE + (n)*0x1000 + 0x040)
+
+#define	REG_MSC_STRPCL(n)	REG16(MSC_STRPCL(n))
+#define	REG_MSC_STAT(n)		REG32(MSC_STAT(n))
+#define	REG_MSC_CLKRT(n)	REG16(MSC_CLKRT(n))
+#define	REG_MSC_CMDAT(n)	REG32(MSC_CMDAT(n))
+#define	REG_MSC_RESTO(n)	REG16(MSC_RESTO(n))
+#define	REG_MSC_RDTO(n)		REG32(MSC_RDTO(n))
+#define	REG_MSC_BLKLEN(n)	REG16(MSC_BLKLEN(n))
+#define	REG_MSC_NOB(n)		REG16(MSC_NOB(n))
+#define	REG_MSC_SNOB(n)		REG16(MSC_SNOB(n))
+#define	REG_MSC_IMASK(n)	REG32(MSC_IMASK(n))
+#define	REG_MSC_IREG(n)		REG16(MSC_IREG(n))
+#define	REG_MSC_CMD(n)		REG8(MSC_CMD(n))
+#define	REG_MSC_ARG(n)		REG32(MSC_ARG(n))
+#define	REG_MSC_RES(n)		REG16(MSC_RES(n))
+#define	REG_MSC_RXFIFO(n)	REG32(MSC_RXFIFO(n))
+#define	REG_MSC_TXFIFO(n)	REG32(MSC_TXFIFO(n))
+#define	REG_MSC_LPM(n)		REG32(MSC_LPM(n))
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+#define MSC_STRPCL_SEND_CCSD		(1 << 15) /*send command completion signal disable to ceata */
+#define MSC_STRPCL_SEND_AS_CCSD		(1 << 14) /*send internally generated stop after sending ccsd */
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+#define MSC_STAT_AUTO_CMD_DONE		(1 << 31) /*12 is internally generated by controller has finished */
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	(0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	(0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	(0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	(0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	(0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	(0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	(0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	(0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+#define	MSC_CMDAT_CCS_EXPECTED		(1 << 31) /* interrupts are enabled in ce-ata */
+#define	MSC_CMDAT_READ_CEATA		(1 << 30)
+#define	MSC_CMDAT_SDIO_PRDT		(1 << 17) /* exact 2 cycle */
+#define	MSC_CMDAT_SEND_AS_STOP		(1 << 16)
+#define	MSC_CMDAT_RTRG_BIT		14
+  #define MSC_CMDAT_RTRG_EQUALT_8	(0x0 << MSC_CMDAT_RTRG_BIT)
+  #define MSC_CMDAT_RTRG_EQUALT_16	(0x1 << MSC_CMDAT_RTRG_BIT) /* reset value */
+  #define MSC_CMDAT_RTRG_EQUALT_24	(0x2 << MSC_CMDAT_RTRG_BIT)
+
+#define	MSC_CMDAT_TTRG_BIT		12
+  #define MSC_CMDAT_TTRG_LESS_8		(0x0 << MSC_CMDAT_TTRG_BIT)
+  #define MSC_CMDAT_TTRG_LESS_16	(0x1 << MSC_CMDAT_TTRG_BIT) /*reset value  */
+  #define MSC_CMDAT_TTRG_LESS_24	(0x2 << MSC_CMDAT_TTRG_BIT)
+#define	MSC_CMDAT_STOP_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	(0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	(0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_8BIT	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT) /* 8-bit data bus */
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+#define	MSC_IMASK_AUTO_CMD_DONE		(1 << 8)
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+#define	MSC_IREG_AUTO_CMD_DONE		(1 << 8)
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+/* MSC Low Power Mode Register (MSC_LPM) */
+#define	MSC_SET_LPM			(1 << 0)
+
+/*************************************************************************
+ * EMC (External Memory Controller)
+ *************************************************************************/
+#define EMC_BCR    	(EMC_BASE + 0x00)  /* Bus Control Register */
+#define EMC_SMCR0	(EMC_BASE + 0x10)  /* Static Memory Control Register 0 */
+#define EMC_SMCR1	(EMC_BASE + 0x14)  /* Static Memory Control Register 1 */
+#define EMC_SMCR2	(EMC_BASE + 0x18)  /* Static Memory Control Register 2 */
+#define EMC_SMCR3	(EMC_BASE + 0x1c)  /* Static Memory Control Register 3 */
+#define EMC_SMCR4	(EMC_BASE + 0x20)  /* Static Memory Control Register 4 */
+#define EMC_SACR0	(EMC_BASE + 0x30)  /* Static Memory Bank 0 Addr Config Reg */
+#define EMC_SACR1	(EMC_BASE + 0x34)  /* Static Memory Bank 1 Addr Config Reg */
+#define EMC_SACR2	(EMC_BASE + 0x38)  /* Static Memory Bank 2 Addr Config Reg */
+#define EMC_SACR3	(EMC_BASE + 0x3c)  /* Static Memory Bank 3 Addr Config Reg */
+#define EMC_SACR4	(EMC_BASE + 0x40)  /* Static Memory Bank 4 Addr Config Reg */
+
+#define EMC_NFCSR	(EMC_BASE + 0x050) /* NAND Flash Control/Status Register */
+
+#define EMC_DMCR	(EMC_BASE + 0x80)  /* DRAM Control Register */
+#define EMC_RTCSR	(EMC_BASE + 0x84)  /* Refresh Time Control/Status Register */
+#define EMC_RTCNT	(EMC_BASE + 0x88)  /* Refresh Timer Counter */
+#define EMC_RTCOR	(EMC_BASE + 0x8c)  /* Refresh Time Constant Register */
+#define EMC_DMAR0	(EMC_BASE + 0x90)  /* SDRAM Bank 0 Addr Config Register */
+#define EMC_DMAR1	(EMC_BASE + 0x94)  /* SDRAM Bank 1 Addr Config Register */
+#define EMC_SDMR0	(EMC_BASE + 0xa000) /* Mode Register of SDRAM bank 0 */
+
+#define REG_EMC_BCR 	REG32(EMC_BCR)
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR0	REG32(EMC_DMAR0)
+#define REG_EMC_DMAR1	REG32(EMC_DMAR1)
+
+/* Bus Control Register */
+#define EMC_BCR_BT_SEL_BIT      30
+#define EMC_BCR_BT_SEL_MASK     (0x3 << EMC_BCR_BT_SEL_BIT)
+#define EMC_BCR_PK_SEL          (1 << 24)
+#define EMC_BCR_BSR_MASK          (1 << 2)  /* Nand and SDRAM Bus Share Select: 0, share; 1, unshare */
+  #define EMC_BCR_BSR_SHARE       (0 << 2)
+  #define EMC_BCR_BSR_UNSHARE     (1 << 2)
+#define EMC_BCR_BRE             (1 << 1)
+#define EMC_BCR_ENDIAN          (1 << 0)
+
+/* Static Memory Control Register */
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+/* Static Memory Bank Addr Config Reg */
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+/* NAND Flash Control/Status Register */
+#define EMC_NFCSR_NFCE4		(1 << 7) /* NAND Flash Enable */
+#define EMC_NFCSR_NFE4		(1 << 6) /* NAND Flash FCE# Assertion Enable */
+#define EMC_NFCSR_NFCE3		(1 << 5)
+#define EMC_NFCSR_NFE3		(1 << 4)
+#define EMC_NFCSR_NFCE2		(1 << 3)
+#define EMC_NFCSR_NFE2		(1 << 2)
+#define EMC_NFCSR_NFCE1		(1 << 1)
+#define EMC_NFCSR_NFE1		(1 << 0)
+
+/* DRAM Control Register */
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_MBSEL		(1 << 16)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+/* Refresh Time Control/Status Register */
+#define EMC_RTCSR_SFR		(1 << 8)    /* self refresh flag */
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+/* SDRAM Bank Address Configuration Register */
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+/* Mode Register of SDRAM bank 0 */
+#define EMC_SDMR_BM		(1 << 9) /* Write Burst Mode */
+#define EMC_SDMR_OM_BIT		7        /* Operating Mode */
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4        /* CAS Latency */
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3        /* Burst Type */
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT) /* Sequential */
+  #define EMC_SDMR_BT_INT	(1 << EMC_SDMR_BT_BIT) /* Interleave */
+#define EMC_SDMR_BL_BIT		0        /* Burst Length */
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+#define	CIM_SIZE		(CIM_BASE + 0x0030)
+#define	CIM_OFFSET		(CIM_BASE + 0x0034)
+#define	CIM_RAM_ADDR		(CIM_BASE + 0x1000)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+#define	REG_CIM_SIZE		REG32(CIM_SIZE)
+#define	REG_CIM_OFFSET		REG32(CIM_OFFSET)
+
+#define	CIM_CFG_ORDER_BIT	18
+#define	CIM_CFG_ORDER_MASK	(0x3 << CIM_CFG_ORDER_BIT)
+  #define CIM_CFG_ORDER_0	  (0x0 << CIM_CFG_ORDER_BIT) 	/* Y0CbY1Cr; YCbCr */
+  #define CIM_CFG_ORDER_1	  (0x1 << CIM_CFG_ORDER_BIT)	/* Y0CrY1Cb; YCrCb */
+  #define CIM_CFG_ORDER_2	  (0x2 << CIM_CFG_ORDER_BIT)	/* CbY0CrY1; CbCrY */
+  #define CIM_CFG_ORDER_3	  (0x3 << CIM_CFG_ORDER_BIT)	/* CrY0CbY1; CrCbY */
+#define	CIM_CFG_DF_BIT		16
+#define	CIM_CFG_DF_MASK		  (0x3 << CIM_CFG_DF_BIT)
+  #define CIM_CFG_DF_YUV444	  (0x1 << CIM_CFG_DF_BIT) 	/* YCbCr444 */
+  #define CIM_CFG_DF_YUV422	  (0x2 << CIM_CFG_DF_BIT)	/* YCbCr422 */
+  #define CIM_CFG_DF_ITU656	  (0x3 << CIM_CFG_DF_BIT)	/* ITU656 YCbCr422 */
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14) /* VSYNC Polarity:0-rising edge active,1-falling edge active */
+#define	CIM_CFG_HSP		(1 << 13) /* HSYNC Polarity:0-rising edge active,1-falling edge active */
+#define	CIM_CFG_PCP		(1 << 12) /* PCLK working edge: 0-rising, 1-falling */
+#define	CIM_CFG_DMA_BURST_TYPE_BIT	10
+#define	CIM_CFG_DMA_BURST_TYPE_MASK	(0x3 << CIM_CFG_DMA_BURST_TYPE_BIT)
+  #define	CIM_CFG_DMA_BURST_INCR4		(0 << CIM_CFG_DMA_BURST_TYPE_BIT)
+  #define	CIM_CFG_DMA_BURST_INCR8		(1 << CIM_CFG_DMA_BURST_TYPE_BIT)	/* Suggested */
+  #define	CIM_CFG_DMA_BURST_INCR16	(2 << CIM_CFG_DMA_BURST_TYPE_BIT)	/* Suggested High speed AHB*/
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)	/* Only for ITU656 Progressive mode */
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT) /* 11 22 33 44 0xY0CbY1Cr */
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT) /* 22 33 44 11 0xCbY1CrY0 */
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT) /* 33 44 11 22 0xY1CrY0Cb */
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT) /* 44 11 22 33 0xCrY0CbY1 */
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT) /* 44 33 22 11 0xCrY1CbY0 */
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT) /* 33 22 11 44 0xY1CbY0Cr */
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT) /* 22 11 44 33 0xCbY0CrY1 */
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT) /* 11 44 33 22 0xY0CrY1Cb */
+#define	CIM_CFG_BYPASS_BIT	2
+#define	CIM_CFG_BYPASS_MASK	(1 << CIM_CFG_BYPASS_BIT)
+  #define CIM_CFG_BYPASS	  (1 << CIM_CFG_BYPASS_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+#define	CIM_CTRL_EEOF_LINE_BIT	20
+#define	CIM_CTRL_EEOF_LINE_MASK	(0xfff << CIM_CTRL_EEOF_LINE_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+
+#define	CIM_CTRL_DMA_EEOF	(1 << 15)	/* Enable EEOF interrupt */
+#define	CIM_CTRL_WIN_EN		(1 << 14)
+#define	CIM_CTRL_VDDM		(1 << 13) /* VDD interrupt enable */
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_DMA_SYNC	(1 << 7)	/*when change DA, do frame sync */
+#define	CIM_CTRL_RXF_TRIG_BIT	3
+#define	CIM_CTRL_RXF_TRIG_MASK	(0xf << CIM_CTRL_RXF_TRIG_BIT) /* trigger value = (n+1)*burst_type */
+
+#define	CIM_CTRL_DMA_EN		(1 << 2) /* Enable DMA */
+#define	CIM_CTRL_RXF_RST	(1 << 1) /* RxFIFO reset */
+#define	CIM_CTRL_ENA		(1 << 0) /* Enable CIM */
+
+/* CIM State Register  (CIM_STATE) */
+#define	CIM_STATE_DMA_EEOF	(1 << 7) /* DMA Line EEOf irq */
+#define	CIM_STATE_DMA_SOF	(1 << 6) /* DMA start irq */
+#define	CIM_STATE_DMA_EOF	(1 << 5) /* DMA end irq */
+#define	CIM_STATE_DMA_STOP	(1 << 4) /* DMA stop irq */
+#define	CIM_STATE_RXF_OF	(1 << 3) /* RXFIFO over flow irq */
+#define	CIM_STATE_RXF_TRIG	(1 << 2) /* RXFIFO triger meet irq */
+#define	CIM_STATE_RXF_EMPTY	(1 << 1) /* RXFIFO empty irq */
+#define	CIM_STATE_VDD		(1 << 0) /* CIM disabled irq */
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31) /* enable DMA start irq */
+#define	CIM_CMD_EOFINT		(1 << 30) /* enable DMA end irq */
+#define	CIM_CMD_EEOFINT		(1 << 29) /* enable DMA EEOF irq */
+#define	CIM_CMD_STOP		(1 << 28) /* enable DMA stop irq */
+#define	CIM_CMD_OFRCV		(1 << 27) /* enable recovery when TXFiFo overflow */
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+/* CIM Window-Image Size Register  (CIM_SIZE) */
+#define	CIM_SIZE_LPF_BIT	16 /* Lines per freame for csc output image */
+#define	CIM_SIZE_LPF_MASK	(0x1fff << CIM_SIZE_LPF_BIT)
+#define	CIM_SIZE_PPL_BIT	0 /* Pixels per line for csc output image, should be an even number */
+#define	CIM_SIZE_PPL_MASK	(0x1fff << CIM_SIZE_PPL_BIT)
+
+/* CIM Image Offset Register  (CIM_OFFSET) */
+#define	CIM_OFFSET_V_BIT	16 /* Vertical offset */
+#define	CIM_OFFSET_V_MASK	(0xfff << CIM_OFFSET_V_BIT)
+#define	CIM_OFFSET_H_BIT	0 /* Horizontal offset, should be an enen number */
+#define	CIM_OFFSET_H_MASK	(0xfff << CIM_OFFSET_H_BIT) /*OFFSET_H should be even number*/
+
+/*************************************************************************
+ * SADC (Smart A/D Controller)
+ *************************************************************************/
+
+#define SADC_ENA	(SADC_BASE + 0x00)  /* ADC Enable Register */
+#define SADC_CFG	(SADC_BASE + 0x04)  /* ADC Configure Register */
+#define SADC_CTRL	(SADC_BASE + 0x08)  /* ADC Control Register */
+#define SADC_STATE	(SADC_BASE + 0x0C)  /* ADC Status Register*/
+#define SADC_SAMETIME	(SADC_BASE + 0x10)  /* ADC Same Point Time Register */
+#define SADC_WAITTIME	(SADC_BASE + 0x14)  /* ADC Wait Time Register */
+#define SADC_TSDAT	(SADC_BASE + 0x18)  /* ADC Touch Screen Data Register */
+#define SADC_BATDAT	(SADC_BASE + 0x1C)  /* ADC PBAT Data Register */
+#define SADC_SADDAT	(SADC_BASE + 0x20)  /* ADC SADCIN Data Register */
+#define SADC_ADCLK	(SADC_BASE + 0x28)  /* ADC Clock Divide Register */
+
+#define REG_SADC_ENA		REG8(SADC_ENA)
+#define REG_SADC_CFG		REG32(SADC_CFG)
+#define REG_SADC_CTRL		REG8(SADC_CTRL)
+#define REG_SADC_STATE		REG8(SADC_STATE)
+#define REG_SADC_SAMETIME	REG16(SADC_SAMETIME)
+#define REG_SADC_WAITTIME	REG16(SADC_WAITTIME)
+#define REG_SADC_TSDAT		REG32(SADC_TSDAT)
+#define REG_SADC_BATDAT		REG16(SADC_BATDAT)
+#define REG_SADC_SADDAT		REG16(SADC_SADDAT)
+#define REG_SADC_ADCLK		REG32(SADC_ADCLK)
+
+/* ADC Enable Register */
+#define SADC_ENA_ADEN		(1 << 7)  /* Touch Screen Enable */
+#define SADC_ENA_ENTR_SLP	(1 << 6)  /* Touch Screen Enable */
+#define SADC_ENA_EXIT_SLP	(1 << 5)  /* Touch Screen Enable */
+#define SADC_ENA_TSEN		(1 << 2)  /* Touch Screen Enable */
+#define SADC_ENA_PBATEN		(1 << 1)  /* PBAT Enable */
+#define SADC_ENA_SADCINEN	(1 << 0)  /* SADCIN Enable */
+
+/* ADC Configure Register */
+#define SADC_CFG_SPZZ    (1 << 31) //added
+#define SADC_CFG_EXIN           (1 << 30)
+#define SADC_CFG_CLKOUT_NUM_BIT	16
+#define SADC_CFG_CLKOUT_NUM_MASK (0x7 << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_DNUM(x)  (((x) - 1) << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_TS_DMA		(1 << 15)  /* Touch Screen DMA Enable */
+#define SADC_CFG_XYZ_BIT	13  /* XYZ selection */
+#define SADC_CFG_XYZ_MASK	(0x3 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XY		(0 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ		(1 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ1Z2	(2 << SADC_CFG_XYZ_BIT)
+#define SADC_CFG_SNUM_BIT	10  /* Sample Number */
+#define SADC_CFG_SNUM_MASK	(0x7 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_1	(0x0 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_2	(0x1 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_3	(0x2 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_4	(0x3 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_5	(0x4 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_6	(0x5 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_8	(0x6 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_9	(0x7 << SADC_CFG_SNUM_BIT)
+#define SADC_CFG_SNUM(x) (((x) - 1) << SADC_CFG_SNUM_BIT)//added
+#define SADC_CFG_CLKDIV_BIT	5  /* AD Converter frequency clock divider */
+#define SADC_CFG_CLKDIV_MASK	(0x1f << SADC_CFG_CLKDIV_BIT)
+#define SADC_CFG_PBAT_HIGH	(0 << 4)  /* PBAT >= 2.5V */
+#define SADC_CFG_PBAT_LOW	(1 << 4)  /* PBAT < 2.5V */
+#define SADC_CFG_CMD_BIT	0  /* ADC Command */
+#define SADC_CFG_CMD_MASK	(0xf << SADC_CFG_CMD_BIT)
+  #define SADC_CFG_CMD_X_SE	(0x0 << SADC_CFG_CMD_BIT) /* X Single-End */
+  #define SADC_CFG_CMD_Y_SE	(0x1 << SADC_CFG_CMD_BIT) /* Y Single-End */
+  #define SADC_CFG_CMD_X_DIFF	(0x2 << SADC_CFG_CMD_BIT) /* X Differential */
+  #define SADC_CFG_CMD_Y_DIFF	(0x3 << SADC_CFG_CMD_BIT) /* Y Differential */
+  #define SADC_CFG_CMD_Z1_DIFF	(0x4 << SADC_CFG_CMD_BIT) /* Z1 Differential */
+  #define SADC_CFG_CMD_Z2_DIFF	(0x5 << SADC_CFG_CMD_BIT) /* Z2 Differential */
+  #define SADC_CFG_CMD_Z3_DIFF	(0x6 << SADC_CFG_CMD_BIT) /* Z3 Differential */
+  #define SADC_CFG_CMD_Z4_DIFF	(0x7 << SADC_CFG_CMD_BIT) /* Z4 Differential */
+  #define SADC_CFG_CMD_TP_SE	(0x8 << SADC_CFG_CMD_BIT) /* Touch Pressure */
+  #define SADC_CFG_CMD_PBATH_SE	(0x9 << SADC_CFG_CMD_BIT) /* PBAT >= 2.5V */
+  #define SADC_CFG_CMD_PBATL_SE	(0xa << SADC_CFG_CMD_BIT) /* PBAT < 2.5V */
+  #define SADC_CFG_CMD_SADCIN_SE (0xb << SADC_CFG_CMD_BIT) /* Measure SADCIN */
+  #define SADC_CFG_CMD_INT_PEN	(0xc << SADC_CFG_CMD_BIT) /* INT_PEN Enable */
+
+/* ADC Control Register */
+#define SADC_CTRL_SLPENDM	(1 << 5)  /* sleep Interrupt Mask */
+#define SADC_CTRL_PENDM		(1 << 4)  /* Pen Down Interrupt Mask */
+#define SADC_CTRL_PENUM		(1 << 3)  /* Pen Up Interrupt Mask */
+#define SADC_CTRL_TSRDYM	(1 << 2)  /* Touch Screen Data Ready Interrupt Mask */
+#define SADC_CTRL_PBATRDYM	(1 << 1)  /* PBAT Data Ready Interrupt Mask */
+#define SADC_CTRL_SRDYM		(1 << 0)  /* SADCIN Data Ready Interrupt Mask */
+
+/* ADC Status Register */
+#define SADC_STATE_SLEEPND	(1 << 5)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PEND		(1 << 4)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PENU		(1 << 3)  /* Pen Up Interrupt Flag */
+#define SADC_STATE_TSRDY	(1 << 2)  /* Touch Screen Data Ready Interrupt Flag */
+#define SADC_STATE_PBATRDY	(1 << 1)  /* PBAT Data Ready Interrupt Flag */
+#define SADC_STATE_SRDY		(1 << 0)  /* SADCIN Data Ready Interrupt Flag */
+
+/* ADC Touch Screen Data Register */
+#define SADC_TSDAT_DATA0_BIT	0
+#define SADC_TSDAT_DATA0_MASK	(0xfff << SADC_TSDAT_DATA0_BIT)
+#define SADC_TSDAT_TYPE0	(1 << 15)
+#define SADC_TSDAT_DATA1_BIT	16
+#define SADC_TSDAT_DATA1_MASK	(0xfff << SADC_TSDAT_DATA1_BIT)
+#define SADC_TSDAT_TYPE1	(1 << 31)
+
+/* ADC Clock Divide Register */
+#define SADC_ADCLK_CLKDIV_10_BIT	16
+#define SADC_ADCLK_CLKDIV_10_MASK	(0x7f << SADC_ADCLK_CLKDIV_10_BIT)
+#define SADC_ADCLK_CLKDIV_BIT		0
+#define SADC_ADCLK_CLKDIV_MASK		(0x3f << SADC_ADCLK_CLKDIV_BIT)
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+
+#define SLCD_CFG	(SLCD_BASE + 0xA0)  /* SLCD Configure Register */
+#define SLCD_CTRL	(SLCD_BASE + 0xA4)  /* SLCD Control Register */
+#define SLCD_STATE	(SLCD_BASE + 0xA8)  /* SLCD Status Register */
+#define SLCD_DATA	(SLCD_BASE + 0xAC)  /* SLCD Data Register */
+
+#define REG_SLCD_CFG	REG32(SLCD_CFG)
+#define REG_SLCD_CTRL	REG8(SLCD_CTRL)
+#define REG_SLCD_STATE	REG8(SLCD_STATE)
+#define REG_SLCD_DATA	REG32(SLCD_DATA)
+
+/* SLCD Configure Register */
+#define SLCD_CFG_DWIDTH_BIT	10
+#define SLCD_CFG_DWIDTH_MASK	(0x7 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_18BIT	(0 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_16BIT	(1 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x3	(2 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x2	(3 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x1	(4 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_24BIT	(5 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_9BIT_x2	(7 << SLCD_CFG_DWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_BIT	(8)
+#define SLCD_CFG_CWIDTH_MASK	(0x7 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_16BIT	(0 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_8BIT	(1 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_18BIT	(2 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_24BIT	(3 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CS_ACTIVE_LOW	(0 << 4)
+#define SLCD_CFG_CS_ACTIVE_HIGH	(1 << 4)
+#define SLCD_CFG_RS_CMD_LOW	(0 << 3)
+#define SLCD_CFG_RS_CMD_HIGH	(1 << 3)
+#define SLCD_CFG_CLK_ACTIVE_FALLING	(0 << 1)
+#define SLCD_CFG_CLK_ACTIVE_RISING	(1 << 1)
+#define SLCD_CFG_TYPE_PARALLEL	(0 << 0)
+#define SLCD_CFG_TYPE_SERIAL	(1 << 0)
+
+/* SLCD Control Register */
+#define SLCD_CTRL_DMA_MODE	(1 << 2)
+#define SLCD_CTRL_DMA_START	(1 << 1)
+#define SLCD_CTRL_DMA_EN	(1 << 0)
+
+/* SLCD Status Register */
+#define SLCD_STATE_BUSY		(1 << 0)
+
+/* SLCD Data Register */
+#define SLCD_DATA_RS_DATA	(0 << 31)
+#define SLCD_DATA_RS_COMMAND	(1 << 31)
+
+/*************************************************************************
+ * LCD (LCD Controller)
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00) /* LCD Configure Register */
+#define LCD_CTRL	(LCD_BASE + 0x30) /* LCD Control Register */
+#define LCD_STATE	(LCD_BASE + 0x34) /* LCD Status Register */
+
+#define LCD_OSDC	(LCD_BASE + 0x100) /* LCD OSD Configure Register */
+#define LCD_OSDCTRL	(LCD_BASE + 0x104) /* LCD OSD Control Register */
+#define LCD_OSDS	(LCD_BASE + 0x108) /* LCD OSD Status Register */
+#define LCD_BGC		(LCD_BASE + 0x10C) /* LCD Background Color Register */
+#define LCD_KEY0	(LCD_BASE + 0x110) /* LCD Foreground Color Key Register 0 */
+#define LCD_KEY1	(LCD_BASE + 0x114) /* LCD Foreground Color Key Register 1 */
+#define LCD_ALPHA	(LCD_BASE + 0x118) /* LCD ALPHA Register */
+#define LCD_IPUR	(LCD_BASE + 0x11C) /* LCD IPU Restart Register */
+
+#define LCD_VAT		(LCD_BASE + 0x0c) /* Virtual Area Setting Register */
+#define LCD_DAH		(LCD_BASE + 0x10) /* Display Area Horizontal Start/End Point */
+#define LCD_DAV		(LCD_BASE + 0x14) /* Display Area Vertical Start/End Point */
+
+#define LCD_XYP0	(LCD_BASE + 0x120) /* Foreground 0 XY Position Register */
+#define LCD_XYP1	(LCD_BASE + 0x124) /* Foreground 1 XY Position Register */
+#define LCD_SIZE0	(LCD_BASE + 0x128) /* Foreground 0 Size Register */
+#define LCD_SIZE1	(LCD_BASE + 0x12C) /* Foreground 1 Size Register */
+#define LCD_RGBC	(LCD_BASE + 0x90) /* RGB Controll Register */
+
+#define LCD_VSYNC	(LCD_BASE + 0x04) /* Vertical Synchronize Register */
+#define LCD_HSYNC	(LCD_BASE + 0x08) /* Horizontal Synchronize Register */
+#define LCD_PS		(LCD_BASE + 0x18) /* PS Signal Setting */
+#define LCD_CLS		(LCD_BASE + 0x1c) /* CLS Signal Setting */
+#define LCD_SPL		(LCD_BASE + 0x20) /* SPL Signal Setting */
+#define LCD_REV		(LCD_BASE + 0x24) /* REV Signal Setting */
+#define LCD_IID		(LCD_BASE + 0x38) /* Interrupt ID Register */
+#define LCD_DA0		(LCD_BASE + 0x40) /* Descriptor Address Register 0 */
+#define LCD_SA0		(LCD_BASE + 0x44) /* Source Address Register 0 */
+#define LCD_FID0	(LCD_BASE + 0x48) /* Frame ID Register 0 */
+#define LCD_CMD0	(LCD_BASE + 0x4c) /* DMA Command Register 0 */
+#define LCD_DA1		(LCD_BASE + 0x50) /* Descriptor Address Register 1 */
+#define LCD_SA1		(LCD_BASE + 0x54) /* Source Address Register 1 */
+#define LCD_FID1	(LCD_BASE + 0x58) /* Frame ID Register 1 */
+#define LCD_CMD1	(LCD_BASE + 0x5c) /* DMA Command Register 1 */
+
+#define LCD_OFFS0	(LCD_BASE + 0x60) /* DMA Offsize Register 0 */
+#define LCD_PW0		(LCD_BASE + 0x64) /* DMA Page Width Register 0 */
+#define LCD_CNUM0	(LCD_BASE + 0x68) /* DMA Command Counter Register 0 */
+#define LCD_DESSIZE0	(LCD_BASE + 0x6C) /* Foreground Size in Descriptor 0 Register*/
+#define LCD_OFFS1	(LCD_BASE + 0x70) /* DMA Offsize Register 1 */
+#define LCD_PW1		(LCD_BASE + 0x74) /* DMA Page Width Register 1 */
+#define LCD_CNUM1	(LCD_BASE + 0x78) /* DMA Command Counter Register 1 */
+#define LCD_DESSIZE1	(LCD_BASE + 0x7C) /* Foreground Size in Descriptor 1 Register*/
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+
+#define REG_LCD_OSDC	REG16(LCD_OSDC)
+#define REG_LCD_OSDCTRL	REG16(LCD_OSDCTRL)
+#define REG_LCD_OSDS	REG16(LCD_OSDS)
+#define REG_LCD_BGC	REG32(LCD_BGC)
+#define REG_LCD_KEY0	REG32(LCD_KEY0)
+#define REG_LCD_KEY1	REG32(LCD_KEY1)
+#define REG_LCD_ALPHA	REG8(LCD_ALPHA)
+#define REG_LCD_IPUR	REG32(LCD_IPUR)
+
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+
+#define REG_LCD_XYP0	REG32(LCD_XYP0)
+#define REG_LCD_XYP1	REG32(LCD_XYP1)
+#define REG_LCD_SIZE0	REG32(LCD_SIZE0)
+#define REG_LCD_SIZE1	REG32(LCD_SIZE1)
+#define REG_LCD_RGBC	REG16(LCD_RGBC)
+
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+#define REG_LCD_OFFS0	REG32(LCD_OFFS0)
+#define REG_LCD_PW0	REG32(LCD_PW0)
+#define REG_LCD_CNUM0	REG32(LCD_CNUM0)
+#define REG_LCD_DESSIZE0	REG32(LCD_DESSIZE0)
+#define REG_LCD_OFFS1	REG32(LCD_OFFS1)
+#define REG_LCD_PW1	REG32(LCD_PW1)
+#define REG_LCD_CNUM1	REG32(LCD_CNUM1)
+#define REG_LCD_DESSIZE1	REG32(LCD_DESSIZE1)
+
+/* LCD Configure Register */
+#define LCD_CFG_LCDPIN_BIT	31  /* LCD pins selection */
+#define LCD_CFG_LCDPIN_MASK	(0x1 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_LCD	(0x0 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_SLCD	(0x1 << LCD_CFG_LCDPIN_BIT)
+#define LCD_CFG_TVEPEH		(1 << 30) /* TVE PAL enable extra halfline signal */
+#define LCD_CFG_FUHOLD		(1 << 29) /* hold pixel clock when outFIFO underrun */
+#define LCD_CFG_NEWDES		(1 << 28) /* use new descripter. old: 4words, new:8words */
+#define LCD_CFG_PALBP		(1 << 27) /* bypass data format and alpha blending */
+#define LCD_CFG_TVEN		(1 << 26) /* indicate the terminal is lcd or tv */
+#define LCD_CFG_RECOVER		(1 << 25) /* Auto recover when output fifo underrun */
+#define LCD_CFG_DITHER		(1 << 24) /* Dither function */
+#define LCD_CFG_PSM		(1 << 23) /* PS signal mode */
+#define LCD_CFG_CLSM		(1 << 22) /* CLS signal mode */
+#define LCD_CFG_SPLM		(1 << 21) /* SPL signal mode */
+#define LCD_CFG_REVM		(1 << 20) /* REV signal mode */
+#define LCD_CFG_HSYNM		(1 << 19) /* HSYNC signal mode */
+#define LCD_CFG_PCLKM		(1 << 18) /* PCLK signal mode */
+#define LCD_CFG_INVDAT		(1 << 17) /* Inverse output data */
+#define LCD_CFG_SYNDIR_IN	(1 << 16) /* VSYNC&HSYNC direction */
+#define LCD_CFG_PSP		(1 << 15) /* PS pin reset state */
+#define LCD_CFG_CLSP		(1 << 14) /* CLS pin reset state */
+#define LCD_CFG_SPLP		(1 << 13) /* SPL pin reset state */
+#define LCD_CFG_REVP		(1 << 12) /* REV pin reset state */
+#define LCD_CFG_HSP		(1 << 11) /* HSYNC polarity:0-active high,1-active low */
+#define LCD_CFG_PCP		(1 << 10) /* PCLK polarity:0-rising,1-falling */
+#define LCD_CFG_DEP		(1 << 9)  /* DE polarity:0-active high,1-active low */
+#define LCD_CFG_VSP		(1 << 8)  /* VSYNC polarity:0-rising,1-falling */
+#define LCD_CFG_MODE_TFT_18BIT 	(1 << 7)  /* 18bit TFT */
+#define LCD_CFG_MODE_TFT_16BIT 	(0 << 7)  /* 16bit TFT */
+#define LCD_CFG_MODE_TFT_24BIT 	(1 << 6)  /* 24bit TFT */
+#define LCD_CFG_PDW_BIT		4  /* STN pins utilization */
+#define LCD_CFG_PDW_MASK	(0x3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_PDW_1		(0 << LCD_CFG_PDW_BIT) /* LCD_D[0] */
+  #define LCD_CFG_PDW_2		(1 << LCD_CFG_PDW_BIT) /* LCD_D[0:1] */
+  #define LCD_CFG_PDW_4		(2 << LCD_CFG_PDW_BIT) /* LCD_D[0:3]/LCD_D[8:11] */
+  #define LCD_CFG_PDW_8		(3 << LCD_CFG_PDW_BIT) /* LCD_D[0:7]/LCD_D[8:15] */
+#define LCD_CFG_MODE_BIT	0  /* Display Device Mode Select */
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_CFG_MODE_BIT) /* 16,18 bit TFT */
+  #define LCD_CFG_MODE_SPECIAL_TFT_1	(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_2	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_3	(3 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(6 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SERIAL_TFT	(12 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_LCM  		(13 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SLCD  		LCD_CFG_MODE_LCM
+
+/* LCD Control Register */
+#define LCD_CTRL_BST_BIT	28  /* Burst Length Selection */
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT) /* 4-word */
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT) /* 8-word */
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT) /* 16-word */
+  #define LCD_CTRL_BST_32	(3 << LCD_CTRL_BST_BIT) /* 32-word */
+#define LCD_CTRL_RGB565		(0 << 27) /* RGB565 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_RGB555		(1 << 27) /* RGB555 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_OFUP		(1 << 26) /* Output FIFO underrun protection enable */
+#define LCD_CTRL_FRC_BIT	24  /* STN FRC Algorithm Selection */
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT) /* 16 grayscale */
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT) /* 4 grayscale */
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT) /* 2 grayscale */
+#define LCD_CTRL_PDD_BIT	16  /* Load Palette Delay Counter */
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_VGA		(1 << 15) /* VGA interface enable */
+#define LCD_CTRL_DACTE		(1 << 14) /* DAC loop back test */
+#define LCD_CTRL_EOFM		(1 << 13) /* EOF interrupt mask */
+#define LCD_CTRL_SOFM		(1 << 12) /* SOF interrupt mask */
+#define LCD_CTRL_OFUM		(1 << 11) /* Output FIFO underrun interrupt mask */
+#define LCD_CTRL_IFUM0		(1 << 10) /* Input FIFO 0 underrun interrupt mask */
+#define LCD_CTRL_IFUM1		(1 << 9)  /* Input FIFO 1 underrun interrupt mask */
+#define LCD_CTRL_LDDM		(1 << 8)  /* LCD disable done interrupt mask */
+#define LCD_CTRL_QDM		(1 << 7)  /* LCD quick disable done interrupt mask */
+#define LCD_CTRL_BEDN		(1 << 6)  /* Endian selection */
+#define LCD_CTRL_PEDN		(1 << 5)  /* Endian in byte:0-msb first, 1-lsb first */
+#define LCD_CTRL_DIS		(1 << 4)  /* Disable indicate bit */
+#define LCD_CTRL_ENA		(1 << 3)  /* LCD enable bit */
+#define LCD_CTRL_BPP_BIT	0  /* Bits Per Pixel */
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT) /* 1 bpp */
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT) /* 2 bpp */
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT) /* 4 bpp */
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT) /* 8 bpp */
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT) /* 15/16 bpp */
+  #define LCD_CTRL_BPP_18_24	(5 << LCD_CTRL_BPP_BIT) /* 18/24/32 bpp */
+  #define LCD_CTRL_BPP_CMPS_24	(6 << LCD_CTRL_BPP_BIT) /* 24 compress bpp */
+
+/* LCD Status Register */
+#define LCD_STATE_QD		(1 << 7) /* Quick Disable Done */
+#define LCD_STATE_EOF		(1 << 5) /* EOF Flag */
+#define LCD_STATE_SOF		(1 << 4) /* SOF Flag */
+#define LCD_STATE_OFU		(1 << 3) /* Output FIFO Underrun */
+#define LCD_STATE_IFU0		(1 << 2) /* Input FIFO 0 Underrun */
+#define LCD_STATE_IFU1		(1 << 1) /* Input FIFO 1 Underrun */
+#define LCD_STATE_LDD		(1 << 0) /* LCD Disabled */
+
+/* OSD Configure Register */
+#define LCD_OSDC_SOFM1		(1 << 15) /* Start of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_EOFM1		(1 << 14) /* End of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_SOFM0		(1 << 11) /* Start of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_EOFM0		(1 << 10) /* End of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_F1EN		(1 << 4) /* enable foreground 1 */
+#define LCD_OSDC_F0EN		(1 << 3) /* enable foreground 0 */
+#define LCD_OSDC_ALPHAEN		(1 << 2) /* enable alpha blending */
+#define LCD_OSDC_ALPHAMD		(1 << 1) /* alpha blending mode */
+#define LCD_OSDC_OSDEN		(1 << 0) /* OSD mode enable */
+
+/* OSD Controll Register */
+#define LCD_OSDCTRL_IPU		(1 << 15) /* input data from IPU */
+#define LCD_OSDCTRL_RGB565	(0 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_RGB555	(1 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_CHANGES	(1 << 3) /* Change size flag */
+#define LCD_OSDCTRL_OSDBPP_BIT	0 	 /* Bits Per Pixel of OSD Channel 1 */
+#define LCD_OSDCTRL_OSDBPP_MASK	(0x7<<LCD_OSDCTRL_OSDBPP_BIT) 	 /* Bits Per Pixel of OSD Channel 1's MASK */
+  #define LCD_OSDCTRL_OSDBPP_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_15_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_18_24	(5 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 18,24 bit*/
+  #define LCD_OSDCTRL_OSDBPP_CMPS_24	(6 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 18,24 bit*/
+
+/* OSD State Register */
+#define LCD_OSDS_SOF1		(1 << 15) /* Start of frame flag for foreground 1 */
+#define LCD_OSDS_EOF1		(1 << 14) /* End of frame flag for foreground 1 */
+#define LCD_OSDS_SOF0		(1 << 11) /* Start of frame flag for foreground 0 */
+#define LCD_OSDS_EOF0		(1 << 10) /* End of frame flag for foreground 0 */
+#define LCD_OSDS_READY		(1 << 0)  /* Read for accept the change */
+
+/* Background Color Register */
+#define LCD_BGC_RED_OFFSET	(1 << 16)  /* Red color offset */
+#define LCD_BGC_RED_MASK	(0xFF<<LCD_BGC_RED_OFFSET)
+#define LCD_BGC_GREEN_OFFSET	(1 << 8)   /* Green color offset */
+#define LCD_BGC_GREEN_MASK	(0xFF<<LCD_BGC_GREEN_OFFSET)
+#define LCD_BGC_BLUE_OFFSET	(1 << 0)   /* Blue color offset */
+#define LCD_BGC_BLUE_MASK	(0xFF<<LCD_BGC_BLUE_OFFSET)
+
+/* Foreground Color Key Register 0,1(foreground 0, foreground 1) */
+#define LCD_KEY_KEYEN		(1 << 31)   /* enable color key */
+#define LCD_KEY_KEYMD		(1 << 30)   /* color key mode */
+#define LCD_KEY_RED_OFFSET	16  /* Red color offset */
+#define LCD_KEY_RED_MASK	(0xFF<<LCD_KEY_RED_OFFSET)
+#define LCD_KEY_GREEN_OFFSET	8   /* Green color offset */
+#define LCD_KEY_GREEN_MASK	(0xFF<<LCD_KEY_GREEN_OFFSET)
+#define LCD_KEY_BLUE_OFFSET	0   /* Blue color offset */
+#define LCD_KEY_BLUE_MASK	(0xFF<<LCD_KEY_BLUE_OFFSET)
+#define LCD_KEY_MASK		(LCD_KEY_RED_MASK|LCD_KEY_GREEN_MASK|LCD_KEY_BLUE_MASK)
+
+/* IPU Restart Register */
+#define LCD_IPUR_IPUREN		(1 << 31)   /* IPU restart function enable*/
+#define LCD_IPUR_IPURMASK	(0xFFFFFF)   /* IPU restart value mask*/
+
+/* RGB Control Register */
+#define LCD_RGBC_RGBDM		(1 << 15)   /* enable RGB Dummy data */
+#define LCD_RGBC_DMM		(1 << 14)   /* RGB Dummy mode */
+#define LCD_RGBC_YCC		(1 << 8)    /* RGB to YCC */
+#define LCD_RGBC_ODDRGB_BIT	4	/* odd line serial RGB data arrangement */
+#define LCD_RGBC_ODDRGB_MASK	(0x7<<LCD_RGBC_ODDRGB_BIT)
+  #define LCD_RGBC_ODD_RGB	0
+  #define LCD_RGBC_ODD_RBG	1
+  #define LCD_RGBC_ODD_GRB	2
+  #define LCD_RGBC_ODD_GBR	3
+  #define LCD_RGBC_ODD_BRG	4
+  #define LCD_RGBC_ODD_BGR	5
+#define LCD_RGBC_EVENRGB_BIT	0	/* even line serial RGB data arrangement */
+#define LCD_RGBC_EVENRGB_MASK	(0x7<<LCD_RGBC_EVENRGB_BIT)
+  #define LCD_RGBC_EVEN_RGB	0
+  #define LCD_RGBC_EVEN_RBG	1
+  #define LCD_RGBC_EVEN_GRB	2
+  #define LCD_RGBC_EVEN_GBR	3
+  #define LCD_RGBC_EVEN_BRG	4
+  #define LCD_RGBC_EVEN_BGR	5
+
+/* Vertical Synchronize Register */
+#define LCD_VSYNC_VPS_BIT	16  /* VSYNC pulse start in line clock, fixed to 0 */
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0   /* VSYNC pulse end in line clock */
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+/* Horizontal Synchronize Register */
+#define LCD_HSYNC_HPS_BIT	16  /* HSYNC pulse start position in dot clock */
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0   /* HSYNC pulse end position in dot clock */
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+/* Virtual Area Setting Register */
+#define LCD_VAT_HT_BIT		16  /* Horizontal Total size in dot clock */
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0   /* Vertical Total size in dot clock */
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+/* Display Area Horizontal Start/End Point Register */
+#define LCD_DAH_HDS_BIT		16  /* Horizontal display area start in dot clock */
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0   /* Horizontal display area end in dot clock */
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+/* Display Area Vertical Start/End Point Register */
+#define LCD_DAV_VDS_BIT		16  /* Vertical display area start in line clock */
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0   /* Vertical display area end in line clock */
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+/* Foreground XY Position Register */
+#define LCD_XYP_YPOS_BIT	16  /* Y position bit of foreground 0 or 1 */
+#define LCD_XYP_YPOS_MASK	(0xffff << LCD_XYP_YPOS_BIT)
+#define LCD_XYP_XPOS_BIT	0   /* X position bit of foreground 0 or 1 */
+#define LCD_XYP_XPOS_MASK	(0xffff << LCD_XYP_XPOS_BIT)
+
+/* PS Signal Setting */
+#define LCD_PS_PSS_BIT		16  /* PS signal start position in dot clock */
+#define LCD_PS_PSS_MASK		(0xffff << LCD_PS_PSS_BIT)
+#define LCD_PS_PSE_BIT		0   /* PS signal end position in dot clock */
+#define LCD_PS_PSE_MASK		(0xffff << LCD_PS_PSE_BIT)
+
+/* CLS Signal Setting */
+#define LCD_CLS_CLSS_BIT	16  /* CLS signal start position in dot clock */
+#define LCD_CLS_CLSS_MASK	(0xffff << LCD_CLS_CLSS_BIT)
+#define LCD_CLS_CLSE_BIT	0   /* CLS signal end position in dot clock */
+#define LCD_CLS_CLSE_MASK	(0xffff << LCD_CLS_CLSE_BIT)
+
+/* SPL Signal Setting */
+#define LCD_SPL_SPLS_BIT	16  /* SPL signal start position in dot clock */
+#define LCD_SPL_SPLS_MASK	(0xffff << LCD_SPL_SPLS_BIT)
+#define LCD_SPL_SPLE_BIT	0   /* SPL signal end position in dot clock */
+#define LCD_SPL_SPLE_MASK	(0xffff << LCD_SPL_SPLE_BIT)
+
+/* REV Signal Setting */
+#define LCD_REV_REVS_BIT	16  /* REV signal start position in dot clock */
+#define LCD_REV_REVS_MASK	(0xffff << LCD_REV_REVS_BIT)
+
+/* DMA Command Register */
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_CMD		(1 << 29) /* indicate command in slcd mode */
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+/* DMA Offsize Register 0,1 */
+
+/* DMA Page Width Register 0,1 */
+
+/* DMA Command Counter Register 0,1 */
+
+/* Foreground 0,1 Size Register */
+#define LCD_DESSIZE_HEIGHT_BIT	16  /* height of foreground 1 */
+#define LCD_DESSIZE_HEIGHT_MASK	(0xffff << LCD_DESSIZE_HEIGHT_BIT)
+#define LCD_DESSIZE_WIDTH_BIT	0  /* width of foreground 1 */
+#define LCD_DESSIZE_WIDTH_MASK	(0xffff << LCD_DESSIZE_WIDTH_BIT)
+
+/*************************************************************************
+ * TVE (TV Encoder Controller)
+ *************************************************************************/
+#define TVE_CTRL	(TVE_BASE + 0x40) /* TV Encoder Control register */
+#define TVE_FRCFG	(TVE_BASE + 0x44) /* Frame configure register */
+#define TVE_SLCFG1	(TVE_BASE + 0x50) /* TV signal level configure register 1 */
+#define TVE_SLCFG2	(TVE_BASE + 0x54) /* TV signal level configure register 2*/
+#define TVE_SLCFG3	(TVE_BASE + 0x58) /* TV signal level configure register 3*/
+#define TVE_LTCFG1	(TVE_BASE + 0x60) /* Line timing configure register 1 */
+#define TVE_LTCFG2	(TVE_BASE + 0x64) /* Line timing configure register 2 */
+#define TVE_CFREQ	(TVE_BASE + 0x70) /* Chrominance sub-carrier frequency configure register */
+#define TVE_CPHASE	(TVE_BASE + 0x74) /* Chrominance sub-carrier phase configure register */
+#define TVE_CBCRCFG	(TVE_BASE + 0x78) /* Chrominance filter configure register */
+#define TVE_WSSCR	(TVE_BASE + 0x80) /* Wide screen signal control register */
+#define TVE_WSSCFG1	(TVE_BASE + 0x84) /* Wide screen signal configure register 1 */
+#define TVE_WSSCFG2	(TVE_BASE + 0x88) /* Wide screen signal configure register 2 */
+#define TVE_WSSCFG3	(TVE_BASE + 0x8c) /* Wide screen signal configure register 3 */
+
+#define REG_TVE_CTRL     REG32(TVE_CTRL)
+#define REG_TVE_FRCFG    REG32(TVE_FRCFG)
+#define REG_TVE_SLCFG1   REG32(TVE_SLCFG1)
+#define REG_TVE_SLCFG2   REG32(TVE_SLCFG2)
+#define REG_TVE_SLCFG3   REG32(TVE_SLCFG3)
+#define REG_TVE_LTCFG1   REG32(TVE_LTCFG1)
+#define REG_TVE_LTCFG2   REG32(TVE_LTCFG2)
+#define REG_TVE_CFREQ    REG32(TVE_CFREQ)
+#define REG_TVE_CPHASE   REG32(TVE_CPHASE)
+#define REG_TVE_CBCRCFG	 REG32(TVE_CBCRCFG)
+#define REG_TVE_WSSCR    REG32(TVE_WSSCR)
+#define REG_TVE_WSSCFG1  REG32(TVE_WSSCFG1)
+#define REG_TVE_WSSCFG2	 REG32(TVE_WSSCFG2)
+#define REG_TVE_WSSCFG3  REG32(TVE_WSSCFG3)
+
+/* TV Encoder Control register */
+#define TVE_CTRL_EYCBCR         (1 << 25)    /* YCbCr_enable */
+#define TVE_CTRL_ECVBS          (1 << 24)    /* cvbs_enable */
+#define TVE_CTRL_DAPD3	        (1 << 23)    /* DAC 3 power down */
+#define TVE_CTRL_DAPD2	        (1 << 22)    /* DAC 2 power down */
+#define TVE_CTRL_DAPD1	        (1 << 21)    /* DAC 1 power down */
+#define TVE_CTRL_DAPD           (1 << 20)    /* power down all DACs */
+#define TVE_CTRL_YCDLY_BIT      16
+#define TVE_CTRL_YCDLY_MASK     (0x7 << TVE_CTRL_YCDLY_BIT)
+#define TVE_CTRL_CGAIN_BIT      14
+#define TVE_CTRL_CGAIN_MASK     (0x3 << TVE_CTRL_CGAIN_BIT)
+  #define TVE_CTRL_CGAIN_FULL		(0 << TVE_CTRL_CGAIN_BIT) /* gain = 1 */
+  #define TVE_CTRL_CGAIN_QUTR		(1 << TVE_CTRL_CGAIN_BIT) /* gain = 1/4 */
+  #define TVE_CTRL_CGAIN_HALF		(2 << TVE_CTRL_CGAIN_BIT) /* gain = 1/2 */
+  #define TVE_CTRL_CGAIN_THREE_QURT	(3 << TVE_CTRL_CGAIN_BIT) /* gain = 3/4 */
+#define TVE_CTRL_CBW_BIT        12
+#define TVE_CTRL_CBW_MASK       (0x3 << TVE_CTRL_CBW_BIT)
+  #define TVE_CTRL_CBW_NARROW	(0 << TVE_CTRL_CBW_BIT) /* Narrow band */
+  #define TVE_CTRL_CBW_WIDE	(1 << TVE_CTRL_CBW_BIT) /* Wide band */
+  #define TVE_CTRL_CBW_EXTRA	(2 << TVE_CTRL_CBW_BIT) /* Extra wide band */
+  #define TVE_CTRL_CBW_ULTRA	(3 << TVE_CTRL_CBW_BIT) /* Ultra wide band */
+#define TVE_CTRL_SYNCT          (1 << 9)
+#define TVE_CTRL_PAL            (1 << 8)
+#define TVE_CTRL_FINV           (1 << 7) /* invert_top:1-invert top and bottom fields. */
+#define TVE_CTRL_ZBLACK         (1 << 6) /* bypass_yclamp:1-Black of luminance (Y) input is 0.*/
+#define TVE_CTRL_CR1ST          (1 << 5) /* uv_order:0-Cb before Cr,1-Cr before Cb */
+#define TVE_CTRL_CLBAR          (1 << 4) /* Color bar mode:0-Output input video to TV,1-Output color bar to TV */
+#define TVE_CTRL_SWRST          (1 << 0) /* Software reset:1-TVE is reset */
+
+/* Signal level configure register 1 */
+#define TVE_SLCFG1_BLACKL_BIT   0
+#define TVE_SLCFG1_BLACKL_MASK  (0x3ff << TVE_SLCFG1_BLACKL_BIT)
+#define TVE_SLCFG1_WHITEL_BIT   16
+#define TVE_SLCFG1_WHITEL_MASK  (0x3ff << TVE_SLCFG1_WHITEL_BIT)
+
+/* Signal level configure register 2 */
+#define TVE_SLCFG2_BLANKL_BIT    0
+#define TVE_SLCFG2_BLANKL_MASK   (0x3ff << TVE_SLCFG2_BLANKL_BIT)
+#define TVE_SLCFG2_VBLANKL_BIT   16
+#define TVE_SLCFG2_VBLANKL_MASK  (0x3ff << TVE_SLCFG2_VBLANKL_BIT)
+
+/* Signal level configure register 3 */
+#define TVE_SLCFG3_SYNCL_BIT   0
+#define TVE_SLCFG3_SYNCL_MASK  (0xff << TVE_SLCFG3_SYNCL_BIT)
+
+/* Line timing configure register 1 */
+#define TVE_LTCFG1_BACKP_BIT   0
+#define TVE_LTCFG1_BACKP_MASK  (0x7f << TVE_LTCFG1_BACKP_BIT)
+#define TVE_LTCFG1_HSYNCW_BIT   8
+#define TVE_LTCFG1_HSYNCW_MASK  (0x7f << TVE_LTCFG1_HSYNCW_BIT)
+#define TVE_LTCFG1_FRONTP_BIT   16
+#define TVE_LTCFG1_FRONTP_MASK  (0x1f << TVE_LTCFG1_FRONTP_BIT)
+
+/* Line timing configure register 2 */
+#define TVE_LTCFG2_BURSTW_BIT    0
+#define TVE_LTCFG2_BURSTW_MASK   (0x3f << TVE_LTCFG2_BURSTW_BIT)
+#define TVE_LTCFG2_PREBW_BIT     8
+#define TVE_LTCFG2_PREBW_MASK    (0x1f << TVE_LTCFG2_PREBW_BIT)
+#define TVE_LTCFG2_ACTLIN_BIT    16
+#define TVE_LTCFG2_ACTLIN_MASK	(0x7ff << TVE_LTCFG2_ACTLIN_BIT)
+
+/* Chrominance sub-carrier phase configure register */
+#define TVE_CPHASE_CCRSTP_BIT    0
+#define TVE_CPHASE_CCRSTP_MASK   (0x3 << TVE_CPHASE_CCRSTP_BIT)
+  #define TVE_CPHASE_CCRSTP_8	(0 << TVE_CPHASE_CCRSTP_BIT) /* Every 8 field */
+  #define TVE_CPHASE_CCRSTP_4	(1 << TVE_CPHASE_CCRSTP_BIT) /* Every 4 field */
+  #define TVE_CPHASE_CCRSTP_2	(2 << TVE_CPHASE_CCRSTP_BIT) /* Every 2 lines */
+  #define TVE_CPHASE_CCRSTP_0	(3 << TVE_CPHASE_CCRSTP_BIT) /* Never */
+#define TVE_CPHASE_ACTPH_BIT     16
+#define TVE_CPHASE_ACTPH_MASK    (0xff << TVE_CPHASE_ACTPH_BIT)
+#define TVE_CPHASE_INITPH_BIT    24
+#define TVE_CPHASE_INITPH_MASK   (0xff << TVE_CPHASE_INITPH_BIT)
+
+/* Chrominance filter configure register */
+#define TVE_CBCRCFG_CRGAIN_BIT       0
+#define TVE_CBCRCFG_CRGAIN_MASK      (0xff << TVE_CBCRCFG_CRGAIN_BIT)
+#define TVE_CBCRCFG_CBGAIN_BIT       8
+#define TVE_CBCRCFG_CBGAIN_MASK      (0xff << TVE_CBCRCFG_CBGAIN_BIT)
+#define TVE_CBCRCFG_CRBA_BIT         16
+#define TVE_CBCRCFG_CRBA_MASK        (0xff << TVE_CBCRCFG_CRBA_BIT)
+#define TVE_CBCRCFG_CBBA_BIT         24
+#define TVE_CBCRCFG_CBBA_MASK        (0xff << TVE_CBCRCFG_CBBA_BIT)
+
+/* Frame configure register */
+#define TVE_FRCFG_NLINE_BIT          0
+#define TVE_FRCFG_NLINE_MASK         (0x3ff << TVE_FRCFG_NLINE_BIT)
+#define TVE_FRCFG_L1ST_BIT           16
+#define TVE_FRCFG_L1ST_MASK          (0xff << TVE_FRCFG_L1ST_BIT)
+
+/* Wide screen signal control register */
+#define TVE_WSSCR_EWSS0_BIT	0
+#define TVE_WSSCR_EWSS1_BIT	1
+#define TVE_WSSCR_WSSTP_BIT	2
+#define TVE_WSSCR_WSSCKBP_BIT	3
+#define TVE_WSSCR_WSSEDGE_BIT	4
+#define TVE_WSSCR_WSSEDGE_MASK	(0x7 << TVE_WSSCR_WSSEDGE_BIT)
+#define TVE_WSSCR_ENCH_BIT	8
+#define TVE_WSSCR_NCHW_BIT	9
+#define TVE_WSSCR_NCHFREQ_BIT	12
+#define TVE_WSSCR_NCHFREQ_MASK	(0x7 << TVE_WSSCR_NCHFREQ_BIT)
+
+/*************************************************************************
+ * USB Device
+ *************************************************************************/
+#define USB_BASE  UDC_BASE
+
+#define USB_REG_FADDR		(USB_BASE + 0x00) /* Function Address 8-bit */
+#define USB_REG_POWER		(USB_BASE + 0x01) /* Power Managemetn 8-bit */
+#define USB_REG_INTRIN		(USB_BASE + 0x02) /* Interrupt IN 16-bit */
+#define USB_REG_INTROUT		(USB_BASE + 0x04) /* Interrupt OUT 16-bit */
+#define USB_REG_INTRINE		(USB_BASE + 0x06) /* Intr IN enable 16-bit */
+#define USB_REG_INTROUTE	(USB_BASE + 0x08) /* Intr OUT enable 16-bit */
+#define USB_REG_INTRUSB		(USB_BASE + 0x0a) /* Interrupt USB 8-bit */
+#define USB_REG_INTRUSBE	(USB_BASE + 0x0b) /* Interrupt USB Enable 8-bit */
+#define USB_REG_FRAME		(USB_BASE + 0x0c) /* Frame number 16-bit */
+#define USB_REG_INDEX		(USB_BASE + 0x0e) /* Index register 8-bit */
+#define USB_REG_TESTMODE	(USB_BASE + 0x0f) /* USB test mode 8-bit */
+
+#define USB_REG_CSR0		(USB_BASE + 0x12) /* EP0 CSR 8-bit */
+#define USB_REG_INMAXP		(USB_BASE + 0x10) /* EP1-2 IN Max Pkt Size 16-bit */
+#define USB_REG_INCSR		(USB_BASE + 0x12) /* EP1-2 IN CSR LSB 8/16bit */
+#define USB_REG_INCSRH		(USB_BASE + 0x13) /* EP1-2 IN CSR MSB 8-bit */
+#define USB_REG_OUTMAXP		(USB_BASE + 0x14) /* EP1 OUT Max Pkt Size 16-bit */
+#define USB_REG_OUTCSR		(USB_BASE + 0x16) /* EP1 OUT CSR LSB 8/16bit */
+#define USB_REG_OUTCSRH		(USB_BASE + 0x17) /* EP1 OUT CSR MSB 8-bit */
+#define USB_REG_OUTCOUNT	(USB_BASE + 0x18) /* bytes in EP0/1 OUT FIFO 16-bit */
+
+#define USB_FIFO_EP0		(USB_BASE + 0x20)
+#define USB_FIFO_EP1		(USB_BASE + 0x24)
+#define USB_FIFO_EP2		(USB_BASE + 0x28)
+
+#define USB_REG_EPINFO		(USB_BASE + 0x78) /* Endpoint information */
+#define USB_REG_RAMINFO		(USB_BASE + 0x79) /* RAM information */
+
+#define USB_REG_INTR		(USB_BASE + 0x200) /* DMA pending interrupts */
+#define USB_REG_CNTL1		(USB_BASE + 0x204) /* DMA channel 1 control */
+#define USB_REG_ADDR1		(USB_BASE + 0x208) /* DMA channel 1 AHB memory addr */
+#define USB_REG_COUNT1		(USB_BASE + 0x20c) /* DMA channel 1 byte count */
+#define USB_REG_CNTL2		(USB_BASE + 0x214) /* DMA channel 2 control */
+#define USB_REG_ADDR2		(USB_BASE + 0x218) /* DMA channel 2 AHB memory addr */
+#define USB_REG_COUNT2		(USB_BASE + 0x21c) /* DMA channel 2 byte count */
+
+
+/* Power register bit masks */
+#define USB_POWER_SUSPENDM	0x01
+#define USB_POWER_RESUME	0x04
+#define USB_POWER_HSMODE	0x10
+#define USB_POWER_HSENAB	0x20
+#define USB_POWER_SOFTCONN	0x40
+
+/* Interrupt register bit masks */
+#define USB_INTR_SUSPEND	0x01
+#define USB_INTR_RESUME		0x02
+#define USB_INTR_RESET		0x04
+
+#define USB_INTR_EP0		0x0001
+#define USB_INTR_INEP1		0x0002
+#define USB_INTR_INEP2		0x0004
+#define USB_INTR_OUTEP1		0x0002
+
+/* CSR0 bit masks */
+#define USB_CSR0_OUTPKTRDY	0x01
+#define USB_CSR0_INPKTRDY	0x02
+#define USB_CSR0_SENTSTALL	0x04
+#define USB_CSR0_DATAEND	0x08
+#define USB_CSR0_SETUPEND	0x10
+#define USB_CSR0_SENDSTALL	0x20
+#define USB_CSR0_SVDOUTPKTRDY	0x40
+#define USB_CSR0_SVDSETUPEND	0x80
+
+/* Endpoint CSR register bits */
+#define USB_INCSRH_AUTOSET	0x80
+#define USB_INCSRH_ISO		0x40
+#define USB_INCSRH_MODE		0x20
+#define USB_INCSRH_DMAREQENAB	0x10
+#define USB_INCSRH_DMAREQMODE	0x04
+#define USB_INCSR_CDT		0x40
+#define USB_INCSR_SENTSTALL	0x20
+#define USB_INCSR_SENDSTALL	0x10
+#define USB_INCSR_FF		0x08
+#define USB_INCSR_UNDERRUN	0x04
+#define USB_INCSR_FFNOTEMPT	0x02
+#define USB_INCSR_INPKTRDY	0x01
+#define USB_OUTCSRH_AUTOCLR	0x80
+#define USB_OUTCSRH_ISO		0x40
+#define USB_OUTCSRH_DMAREQENAB	0x20
+#define USB_OUTCSRH_DNYT	0x10
+#define USB_OUTCSRH_DMAREQMODE	0x08
+#define USB_OUTCSR_CDT		0x80
+#define USB_OUTCSR_SENTSTALL	0x40
+#define USB_OUTCSR_SENDSTALL	0x20
+#define USB_OUTCSR_FF		0x10
+#define USB_OUTCSR_DATAERR	0x08
+#define USB_OUTCSR_OVERRUN	0x04
+#define USB_OUTCSR_FFFULL	0x02
+#define USB_OUTCSR_OUTPKTRDY	0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK		0x01
+#define USB_TEST_J		0x02
+#define USB_TEST_K		0x04
+#define USB_TEST_PACKET		0x08
+
+/* DMA control bits */
+#define USB_CNTL_ENA		0x01
+#define USB_CNTL_DIR_IN		0x02
+#define USB_CNTL_MODE_1		0x04
+#define USB_CNTL_INTR_EN	0x08
+#define USB_CNTL_EP(n)		((n) << 4)
+#define USB_CNTL_BURST_0	(0 << 9)
+#define USB_CNTL_BURST_4	(1 << 9)
+#define USB_CNTL_BURST_8	(2 << 9)
+#define USB_CNTL_BURST_16	(3 << 9)
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define	BCH_CR         	(BCH_BASE + 0x00) /* BCH Control register */
+#define	BCH_CRS       	(BCH_BASE + 0x04) /* BCH Control Set register */
+#define	BCH_CRC       	(BCH_BASE + 0x08) /* BCH Control Clear register */
+#define	BCH_CNT    	(BCH_BASE + 0x0C) /* BCH ENC/DEC Count register */
+#define	BCH_DR     	(BCH_BASE + 0x10) /* BCH data register */
+#define	BCH_PAR0    	(BCH_BASE + 0x14) /* BCH Parity 0 register */
+#define	BCH_PAR1    	(BCH_BASE + 0x18) /* BCH Parity 1 register */
+#define	BCH_PAR2    	(BCH_BASE + 0x1C) /* BCH Parity 2 register */
+#define	BCH_PAR3    	(BCH_BASE + 0x20) /* BCH Parity 3 register */
+#define	BCH_INTS    	(BCH_BASE + 0x24) /* BCH Interrupt Status register */
+#define	BCH_ERR0        (BCH_BASE + 0x28) /* BCH Error Report 0 register */
+#define	BCH_ERR1        (BCH_BASE + 0x2C) /* BCH Error Report 1 register */
+#define	BCH_ERR2        (BCH_BASE + 0x30) /* BCH Error Report 2 register */
+#define	BCH_ERR3        (BCH_BASE + 0x34) /* BCH Error Report 3 register */
+#define	BCH_INTE        (BCH_BASE + 0x38) /* BCH Interrupt Enable register */
+#define	BCH_INTES       (BCH_BASE + 0x3C) /* BCH Interrupt Set register */
+#define	BCH_INTEC       (BCH_BASE + 0x40) /* BCH Interrupt Clear register */
+
+#define	REG_BCH_CR      REG32(BCH_CR)
+#define	REG_BCH_CRS     REG32(BCH_CRS)
+#define	REG_BCH_CRC     REG32(BCH_CRC)
+#define	REG_BCH_CNT     REG32(BCH_CNT)
+#define	REG_BCH_DR      REG8(BCH_DR)
+#define	REG_BCH_PAR0    REG32(BCH_PAR0)
+#define	REG_BCH_PAR1    REG32(BCH_PAR1)
+#define	REG_BCH_PAR2    REG32(BCH_PAR2)
+#define	REG_BCH_PAR3    REG32(BCH_PAR3)
+#define	REG_BCH_INTS    REG32(BCH_INTS)
+#define	REG_BCH_ERR0    REG32(BCH_ERR0)
+#define	REG_BCH_ERR1    REG32(BCH_ERR1)
+#define	REG_BCH_ERR2    REG32(BCH_ERR2)
+#define	REG_BCH_ERR3    REG32(BCH_ERR3)
+#define	REG_BCH_INTE    REG32(BCH_INTE)
+#define	REG_BCH_INTEC   REG32(BCH_INTEC)
+#define	REG_BCH_INTES   REG32(BCH_INTES)
+
+/* BCH Control Register*/
+#define	BCH_CR_DMAE              (1 << 4)  /* BCH DMA Enable */
+#define	BCH_CR_ENCE              (1 << 3)  /* BCH Encoding Select */
+#define	BCH_CR_DECE              (0 << 3)  /* BCH Decoding Select */
+#define	BCH_CR_BSEL8             (1 << 2)  /* 8 Bit BCH Select */
+#define	BCH_CR_BSEL4             (0 << 2)  /* 4 Bit BCH Select */
+#define	BCH_CR_BRST              (1 << 1)  /* BCH Reset */
+#define	BCH_CR_BCHE              (1 << 0)  /* BCH Enable */
+
+/* BCH Interrupt Status Register */
+#define	BCH_INTS_ERRC_BIT        28
+#define	BCH_INTS_ERRC_MASK       (0xf << BCH_INTS_ERRC_BIT)
+#define	BCH_INTS_ALL0            (1 << 5)
+#define	BCH_INTS_ALLf            (1 << 4)
+#define	BCH_INTS_DECF            (1 << 3)
+#define	BCH_INTS_ENCF            (1 << 2)
+#define	BCH_INTS_UNCOR           (1 << 1)
+#define	BCH_INTS_ERR             (1 << 0)
+
+/* BCH ENC/DEC Count Register */
+#define BCH_CNT_DEC_BIT          16
+#define BCH_CNT_DEC_MASK         (0x3ff << BCH_CNT_DEC_BIT)
+#define BCH_CNT_ENC_BIT          0
+#define BCH_CNT_ENC_MASK         (0x3ff << BCH_CNT_ENC_BIT)
+
+/* BCH Error Report Register */
+#define BCH_ERR_INDEX_ODD_BIT    16
+#define BCH_ERR_INDEX_ODD_MASK   (0x1fff << BCH_ERR_INDEX_ODD_BIT)
+#define BCH_ERR_INDEX_EVEN_BIT   0
+#define BCH_ERR_INDEX_EVEN_MASK  (0x1fff << BCH_ERR_INDEX_EVEN_BIT)
+
+/*************************************************************************
+ * OWI (One-wire Bus Controller )
+ *************************************************************************/
+#define OWI_CFG (OWI_BASE + 0x00) /* OWI Configure Register */
+#define OWI_CTL (OWI_BASE + 0x04) /* OWI Control Register */
+#define OWI_STS (OWI_BASE + 0x08) /* OWI Status Register */
+#define OWI_DAT (OWI_BASE + 0x0c) /* OWI Data Register */
+#define OWI_DIV (OWI_BASE + 0x10) /* OWI Clock Divide Register */
+
+#define REG_OWI_CFG  REG8(OWI_CFG)
+#define REG_OWI_CTL  REG8(OWI_CTL)
+#define REG_OWI_STS  REG8(OWI_STS)
+#define REG_OWI_DAT  REG8(OWI_DAT)
+#define REG_OWI_DIV  REG8(OWI_DIV)
+
+/* OWI Configure Register */
+#define OWI_CFG_MODE      (1 << 7) /*  0: Regular speed mode  1: Overdrive  speed mode */
+#define OWI_CFG_RDDATA    (1 << 6) /* 1: receive data from one-wire bus and stored in OWDAT*/
+#define OWI_CFG_WRDATA    (1 << 5) /* 1: transmit the data in OWDAT */
+#define OWI_CFG_RDST      (1 << 4) /* 1: was sampled during a read */
+#define OWI_CFG_WR1RD     (1 << 3) /* 1: generate write 1 sequence on line */
+#define OWI_CFG_WR0       (1 << 2) /* 1: generate write 0 sequence on line */
+#define OWI_CFG_RST       (1 << 1) /* 1: generate reset pulse and sample slaves presence pulse*/
+#define OWI_CFG_ENA       (1 << 0) /* 1: enable the OWI operation */
+
+/* OWI Control Register */
+#define OWI_CTL_EBYTE     (1 << 2) /* enable byte write/read interrupt */
+#define OWI_CTL_EBIT      (1 << 1) /* enable bit write/read interrupt */
+#define OWI_CTL_ERST      (1 << 0) /* enable reset sequence finished interrupt */
+
+/* OWI Status Register */
+#define OWI_STS_PST       (1 << 7) /* 1: one-wire bus has device on it */
+#define OWI_STS_BYTE_RDY  (1 << 2) /* 1: have received or transmitted a data */
+#define OWI_STS_BIT_RDY   (1 << 1) /* 1: have received or transmitted a bit */
+#define OWI_STS_PST_RDY   (1 << 0) /* 1: have finished a reset pulse */
+
+/* OWI Clock Divide Register */
+#define OWI_DIV_CLKDIV_BIT  5
+
+
+/*************************************************************************
+ * MC (Motion Compensation)
+ *************************************************************************/
+#define MC_CTRL		(MC_BASE + 0x00) /* MC Control Register */
+#define MC_STAT		(MC_BASE + 0x04) /* MC Status Register */
+#define MC_REF_ADDR	(MC_BASE + 0x08) /* MC Reference Block Address Register */
+#define MC_REF2_ADDR	(MC_BASE + 0x0C) /* MC 2nd Reference Block Address Register */
+#define MC_CURR_ADDR	(MC_BASE + 0x10) /* MC Current Block Address Register */
+#define MC_REF_STRD	(MC_BASE + 0x14) /* MC Reference Frame Stride Register */
+#define MC_CURR_STRD	(MC_BASE + 0x18) /* MC Current Frame Stride Register */
+#define MC_ITP_INFO	(MC_BASE + 0x1C) /* MC Block Interpolation Information Register */
+#define MC_TAP_COEF1	(MC_BASE + 0x20) /* MC TAP Filter Coefficient 1 Register */
+#define MC_TAP_COEF2	(MC_BASE + 0x24) /* MC TAP Filter Coefficient 2 Register */
+
+#define REG_MC_CTRL		REG32(MC_CTRL)
+#define REG_MC_STAT		REG32(MC_STAT)
+#define REG_MC_REF_ADDR		REG32(MC_REF_ADDR)
+#define REG_MC_REF2_ADDR	REG32(MC_REF2_ADDR)
+#define REG_MC_CURR_ADDR	REG32(MC_CURR_ADDR)
+#define REG_MC_REF_STRD		REG32(MC_REF_STRD)
+#define REG_MC_CURR_STRD	REG32(MC_CURR_STRD)
+#define REG_MC_ITP_INFO		REG32(MC_ITP_INFO)
+#define REG_MC_TAP_COEF1	REG32(MC_TAP_COEF1)
+#define REG_MC_TAP_COEF2	REG32(MC_TAP_COEF2)
+
+/* MC Control Register */
+#define MC_CTRL_CACHECLR	(1 << 2) /* MC Cache clear */
+#define MC_CTRL_RESET		(1 << 1) /* MC Reset */
+#define MC_CTRL_ENABLE		(1 << 0) /* MC enable */
+
+/* MC Status Register */
+#define MC_STAT_OUT_END		(1 << 0) /* Output DMA termination flag */
+
+/* MC Reference Frame Stride Register, unit: byte */
+#define MC_REF_STRD_BIT		16
+#define MC_REF_STRD_MASK	(0xfff << MC_REF_STRD_BIT)
+#define MC_REF_STRD2_BIT	0
+#define MC_REF_STRD2_MASK	(0xfff << MC_REF_STRD2_BIT)
+
+/* MC Current Frame Stride Register, unit: byte */
+#define MC_CURR_STRD_BIT	0
+#define MC_CURR_STRD_MASK	(0xfff << MC_CURR_STRD_BIT)
+
+/* MC Block Interpolation Information Register */
+#define MC_ITP_INFO_RND1_BIT	24  /* Rounding data during interpolation */
+#define MC_ITP_INFO_RND1_MASK	(0xff << MC_ITP_INFO_RND1_BIT)
+#define MC_ITP_INFO_RND0_BIT	16  /* Rounding data during interpolation */
+#define MC_ITP_INFO_RND0_MASK	(0xff << MC_ITP_INFO_RND0_BIT)
+#define MC_ITP_INFO_AVG		(1 << 12)  /* 0: output interpolated data directly; 1: doing average operation with 2nd source data after interpolating and output */
+#define MC_ITP_INFO_FMT_BIT	8  /* Indicate current interpolation's type */
+#define MC_ITP_INFO_RMT_MASK	(0xf << MC_ITP_INFO_RMT_BIT)
+  #define MC_ITP_INFO_FMT_MPEG_HPEL  (0x0 << MC_ITP_INFO_RMT_BIT) /* MPEG Half-pixel interpolation */
+  #define MC_ITP_INFO_FMT_MPEG_QPEL  (0x1 << MC_ITP_INFO_RMT_BIT) /* MPEG 8-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_QPEL  (0x2 << MC_ITP_INFO_RMT_BIT) /* H264 6-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_EPEL  (0x3 << MC_ITP_INFO_RMT_BIT) /* H264 2-tap Eight-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_WPDT  (0x4 << MC_ITP_INFO_RMT_BIT) /* H264 Weighted-prediction */
+  #define MC_ITP_INFO_FMT_WMV2_QPEL  (0x5 << MC_ITP_INFO_RMT_BIT) /* WMV2 4-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_VC1_QPEL   (0x6 << MC_ITP_INFO_RMT_BIT) /* VC1 4-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV8_TPEL   (0x7 << MC_ITP_INFO_RMT_BIT) /* RV8 4-tap Third-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV8_CHROM  (0x8 << MC_ITP_INFO_RMT_BIT) /* RV8 2-tap Third-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV9_QPEL   (0x9 << MC_ITP_INFO_RMT_BIT) /* RV9 6-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV9_CHROM  (0xa << MC_ITP_INFO_RMT_BIT) /* RV9 2-tap Quarter-pixel interpolation */
+#define MC_ITP_INFO_BLK_W_BIT	6  /* Indicate reference block's width, unit: pixel */
+#define MC_ITP_INFO_BLK_W_MASK	(0x3 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_2	(0x0 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_4	(0x1 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_8	(0x2 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_16	(0x3 << MC_ITP_INFO_BLK_W_BIT)
+#define MC_ITP_INFO_BLK_H_BIT	4  /* Indicate reference block's height, unit: pixel */
+#define MC_ITP_INFO_BLK_H_MASK	(0x3 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_2	(0x0 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_4	(0x1 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_8	(0x2 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_16	(0x3 << MC_ITP_INFO_BLK_H_BIT)
+#define MC_ITP_INFO_ITP_CASE_BIT	0  /* Indicate interpolation final destination pixel position */
+#define MC_ITP_INFO_ITP_CASE_MASK	(0xf << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V0	(0x0 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V0	(0x1 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V0	(0x2 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V0	(0x3 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V1	(0x4 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V1	(0x5 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V1	(0x6 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V1	(0x7 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V2	(0x8 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V2	(0x9 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V2	(0xa << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V2	(0xb << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V3	(0xc << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V3	(0xd << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V3	(0xe << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V3	(0xf << MC_ITP_INFO_ITP_CASE_BIT)
+
+/* MC TAP Filter Coefficient 1 Register */
+#define MC_TAP_COEF1_TAP_COEF4_BIT	24
+#define MC_TAP_COEF1_TAP_COEF4_MASK	(0xff << MC_TAP_COEF1_TAP_COEF4_BIT)
+#define MC_TAP_COEF1_TAP_COEF3_BIT	16
+#define MC_TAP_COEF1_TAP_COEF3_MASK	(0xff << MC_TAP_COEF1_TAP_COEF3_BIT)
+#define MC_TAP_COEF1_TAP_COEF2_BIT	8
+#define MC_TAP_COEF1_TAP_COEF2_MASK	(0xff << MC_TAP_COEF1_TAP_COEF2_BIT)
+#define MC_TAP_COEF1_TAP_COEF1_BIT	0
+#define MC_TAP_COEF1_TAP_COEF1_MASK	(0xff << MC_TAP_COEF1_TAP_COEF1_BIT)
+
+/* MC TAP Filter Coefficient 2 Register */
+#define MC_TAP_COEF2_TAP_COEF8_BIT	24
+#define MC_TAP_COEF2_TAP_COEF8_MASK	(0xff << MC_TAP_COEF2_TAP_COEF8_BIT)
+#define MC_TAP_COEF2_TAP_COEF7_BIT	16
+#define MC_TAP_COEF2_TAP_COEF7_MASK	(0xff << MC_TAP_COEF2_TAP_COEF7_BIT)
+#define MC_TAP_COEF2_TAP_COEF6_BIT	8
+#define MC_TAP_COEF2_TAP_COEF6_MASK	(0xff << MC_TAP_COEF2_TAP_COEF6_BIT)
+#define MC_TAP_COEF2_TAP_COEF5_BIT	0
+#define MC_TAP_COEF2_TAP_COEF5_MASK	(0xff << MC_TAP_COEF2_TAP_COEF5_BIT)
+
+
+/*************************************************************************
+ * ME (Motion Estimation)
+ *************************************************************************/
+#define ME_CTRL		(ME_BASE + 0x00) /* ME Control Register */
+#define ME_REF_ADDR	(ME_BASE + 0x04) /* ME Reference Block Address Register */
+#define ME_CURR_ADDR	(ME_BASE + 0x08) /* ME Current Block Address Register */
+#define ME_DIFF_ADDR	(ME_BASE + 0x0C) /* ME Difference Address Register */
+#define ME_REF_STRD	(ME_BASE + 0x10) /* ME Reference Frame Stride Register */
+#define ME_CURR_STRD	(ME_BASE + 0x14) /* ME Current Frame Stride Register */
+#define ME_DIFF_STRD	(ME_BASE + 0x18) /* ME Difference Frame Stride Register */
+#define ME_SETTINGS	(ME_BASE + 0x1C) /* ME Settings Register */
+#define ME_MVD		(ME_BASE + 0x20) /* ME Motion Vector Difference Register */
+#define ME_FLAG		(ME_BASE + 0x24) /* ME Flag Register */
+
+#define REG_ME_CTRL		REG32(ME_CTRL)
+#define REG_ME_REF_ADDR		REG32(ME_REF_ADDR)
+#define REG_ME_CURR_ADDR	REG32(ME_CURR_ADDR)
+#define REG_ME_DIFF_ADDR	REG32(ME_DIFF_ADDR)
+#define REG_ME_REF_STRD		REG32(ME_REF_STRD)
+#define REG_ME_CURR_STRD	REG32(ME_CURR_STRD)
+#define REG_ME_DIFF_STRD	REG32(ME_DIFF_STRD)
+#define REG_ME_SETTINGS		REG32(ME_SETTINGS)
+#define REG_ME_MVD		REG32(ME_MVD)
+#define REG_ME_FLAG		REG32(ME_FLAG)
+
+
+/* ME Control Register */
+#define ME_CTRL_FLUSH		(1 << 2) /* ME cache clear */
+#define ME_CTRL_RESET		(1 << 1) /* ME reset */
+#define ME_CTRL_ENABLE		(1 << 0) /* ME enable */
+
+/* ME Settings Register */
+#define ME_SETTINGS_SAD_GATE_BIT	16 /* The max SAD value which can be accepted */
+#define ME_SETTINGS_SAD_GATE_MASK	(0xffff << ME_SETTINGS_SAD_GATE_BIT)
+#define ME_SETTINGS_STEP_NUM_BIT	0  /* The max step number the search process can not exceed */
+#define ME_SETTINGS_STEP_NUM_MASK	(0x3f << ME_SETTINGS_STEP_NUM_BIT)
+
+/* ME Motion Vector Difference Register */
+#define ME_MVD_MVDY_BIT		16 /* The MVD value of coordinate-Y */
+#define ME_MVD_MVDY_MASK	(0xffff << ME_MVD_MVDY_BIT)
+#define ME_MVD_MVDX_BIT		0  /* The MVD value of coordinate-X */
+#define ME_MVD_MVDX_MASK	(0xffff << ME_MVD_MVDX_BIT)
+
+/* ME Flag Register */
+#define ME_FLAG_INTRA		(1 << 1) /* Indicate the current MB will be predicted in intra mode */
+#define ME_FLAG_COMPLETED	(1 << 0) /* The ME of the current part of the MB is completed */
+
+
+/*************************************************************************
+ * OTP (One Time Programmable Module)
+ *************************************************************************/
+#define OTP_ID0		(OTP_BASE + 0x00) /* ID0 Register */
+#define OTP_ID1		(OTP_BASE + 0x04) /* ID1 Register */
+#define OTP_ID2		(OTP_BASE + 0x08) /* ID2 Register */
+#define OTP_ID3		(OTP_BASE + 0x0C) /* ID3 Register */
+#define OTP_BR0		(OTP_BASE + 0x10) /* BOOTROM0 Register */
+#define OTP_BR1		(OTP_BASE + 0x14) /* BOOTROM1 Register */
+#define OTP_HW0		(OTP_BASE + 0x18) /* Chip Hardware 0 Register */
+#define OTP_HW1		(OTP_BASE + 0x1C) /* Chip Hardware 1 Register */
+
+#define REG_OTP_ID0	REG32(OTP_ID0)
+#define REG_OTP_ID1	REG32(OTP_ID1)
+#define REG_OTP_ID2	REG32(OTP_ID2)
+#define REG_OTP_ID3	REG32(OTP_ID3)
+#define REG_OTP_BR0	REG32(OTP_BR0)
+#define REG_OTP_BR1	REG32(OTP_BR1)
+#define REG_OTP_HW0	REG32(OTP_HW0)
+#define REG_OTP_HW1	REG32(OTP_HW1)
+
+/* ID0 Register */
+#define OTP_ID0_WID_BIT		24 /* Wafer ID */
+#define OTP_ID0_WID_MASK	(0xff << OTP_ID0_WID_BIT)
+#define OTP_ID0_MID_BIT		16 /* MASK ID */
+#define OTP_ID0_MID_MASK	(0xff << OTP_ID0_MID_BIT)
+#define OTP_ID0_FID_BIT		8 /* Foundary ID */
+#define OTP_ID0_FID_MASK	(0xff << OTP_ID0_FID_BIT)
+#define OTP_ID0_PID_BIT		0 /* Product ID */
+#define OTP_ID0_PID_MASK	(0xff << OTP_ID0_PID_BIT)
+
+/* ID1 Register */
+#define OTP_ID1_LID_BIT		8 /* Lot ID */
+#define OTP_ID1_LID_MASK	(0xffffff << OTP_ID1_LID_BIT)
+#define OTP_ID1_TID_BIT		0 /* Test House ID */
+#define OTP_ID1_TID_MASK	(0xff << OTP_ID1_TID_BIT)
+
+/* ID2 Register */
+#define OTP_ID2_XADR_BIT	24 /* Die X-dir Address */
+#define OTP_ID2_XADR_MASK	(0xff << OTP_ID2_XADR_BIT)
+#define OTP_ID2_YADR_BIT	16 /* Die Y-dir Address */
+#define OTP_ID2_YADR_MASK	(0xff << OTP_ID2_YADR_BIT)
+#define OTP_ID2_TDATE_BIT	0  /* Testing Date */
+#define OTP_ID2_TDATE_MASK	(0xffff << OTP_ID2_TDATE_BIT)
+
+/* ID3 Register */
+#define OTP_ID3_CID_BIT		16 /* Customer ID */
+#define OTP_ID3_CID_MASK	(0xffff << OTP_ID3_CID_BIT)
+#define OTP_ID3_CP_BIT		0 /* Chip Parameters */
+#define OTP_ID3_CP_MASK		(0xffff << OTP_ID3_CP_BIT)
+
+/* BOOTROM1 Register */
+#define OTP_BR1_UDCBOOT_BIT	0
+#define OTP_BR1_UDCBOOT_MASK	(0xff << OTP_BR1_UDCBOOT_BIT)
+  #define OTP_BR1_UDCBOOT_AUTO	(0xf0 << OTP_BR1_UDCBOOT_BIT)
+  #define OTP_BR1_UDCBOOT_24M	(0x0f << OTP_BR1_UDCBOOT_BIT) /* 24MHz OSC */
+  #define OTP_BR1_UDCBOOT_13M	(0x0c << OTP_BR1_UDCBOOT_BIT) /* 13MHz OSC */
+  #define OTP_BR1_UDCBOOT_26M	(0x03 << OTP_BR1_UDCBOOT_BIT) /* 26MHz OSC */
+  #define OTP_BR1_UDCBOOT_27M	(0x00 << OTP_BR1_UDCBOOT_BIT) /* 27MHz OSC */
+
+/* Chip Hardware 1 Register */
+#define OTP_HW1_MC_EN		(0x3 << 30) /* MC is enabled */
+#define OTP_HW1_ME_EN		(0x3 << 28)
+#define OTP_HW1_DE_EN		(0x3 << 26)
+#define OTP_HW1_IDCT_EN		(0x3 << 24)
+#define OTP_HW1_UART3_EN	(0x3 << 22)
+#define OTP_HW1_UART2_EN	(0x3 << 20)
+#define OTP_HW1_UART1_EN	(0x3 << 18)
+#define OTP_HW1_UART0_EN	(0x3 << 16)
+#define OTP_HW1_SSI1_EN		(0x3 << 14)
+#define OTP_HW1_SSI0_EN		(0x3 << 12)
+#define OTP_HW1_MSC1_EN		(0x3 << 10)
+#define OTP_HW1_MSC0_EN		(0x3 << 8)
+#define OTP_HW1_UHC_EN		(0x3 << 6)
+#define OTP_HW1_TVE_EN		(0x3 << 4)
+#define OTP_HW1_TSSI_EN		(0x3 << 2)
+#define OTP_HW1_CIM_EN		(0x3 << 0)
+
+
+/*************************************************************************
+ * TSSI MPEG 2-TS slave interface
+ *************************************************************************/
+#define TSSI_ENA       ( TSSI_BASE + 0x00 )   /* TSSI enable register */
+#define TSSI_CFG       ( TSSI_BASE + 0x04 )   /* TSSI configure register */
+#define TSSI_CTRL      ( TSSI_BASE + 0x08 )   /* TSSI control register */
+#define TSSI_STAT      ( TSSI_BASE + 0x0c )   /* TSSI state register */
+#define TSSI_FIFO      ( TSSI_BASE + 0x10 )   /* TSSI FIFO register */
+#define TSSI_PEN       ( TSSI_BASE + 0x14 )   /* TSSI PID enable register */
+#define TSSI_PID(n)    ( TSSI_BASE + 0x20 + 4*(n) )   /* TSSI PID filter register */
+#define TSSI_PID0      ( TSSI_BASE + 0x20 )
+#define TSSI_PID1      ( TSSI_BASE + 0x24 )
+#define TSSI_PID2      ( TSSI_BASE + 0x28 )
+#define TSSI_PID3      ( TSSI_BASE + 0x2c )
+#define TSSI_PID4      ( TSSI_BASE + 0x30 )
+#define TSSI_PID5      ( TSSI_BASE + 0x34 )
+#define TSSI_PID6      ( TSSI_BASE + 0x38 )
+#define TSSI_PID7      ( TSSI_BASE + 0x3c )
+#define TSSI_PID_MAX   8	/* max PID: 7 */
+
+#define REG_TSSI_ENA       REG8( TSSI_ENA )
+#define REG_TSSI_CFG       REG16( TSSI_CFG )
+#define REG_TSSI_CTRL      REG8( TSSI_CTRL )
+#define REG_TSSI_STAT      REG8( TSSI_STAT )
+#define REG_TSSI_FIFO      REG32( TSSI_FIFO )
+#define REG_TSSI_PEN       REG32( TSSI_PEN )
+#define REG_TSSI_PID(n)    REG32( TSSI_PID(n) )
+#define REG_TSSI_PID0      REG32( TSSI_PID0 )
+#define REG_TSSI_PID1      REG32( TSSI_PID1 )
+#define REG_TSSI_PID2      REG32( TSSI_PID2 )
+#define REG_TSSI_PID3      REG32( TSSI_PID3 )
+#define REG_TSSI_PID4      REG32( TSSI_PID4 )
+#define REG_TSSI_PID5      REG32( TSSI_PID5 )
+#define REG_TSSI_PID6      REG32( TSSI_PID6 )
+#define REG_TSSI_PID7      REG32( TSSI_PID7 )
+
+/* TSSI enable register */
+#define TSSI_ENA_SFT_RST 	( 1 << 7 )      /* soft reset bit */
+#define TSSI_ENA_PID_EN 	( 1 << 2 )      /* soft filtering function enable bit */
+#define TSSI_ENA_DMA_EN 	( 1 << 1 )      /* DMA enable bit */
+#define TSSI_ENA_ENA 		( 1 << 0 )      /* TSSI enable bit */
+
+/* TSSI configure register */
+#define TSSI_CFG_TRIG_BIT 	14 /* fifo trig number */
+#define TSSI_CFG_TRIG_MASK 	( 0x3 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_4 	( 0 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_8 	( 1 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_16 	( 2 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_END_WD 	( 1 << 9 )      /* order of data in word */
+#define TSSI_CFG_END_BT 	( 1 << 8 )      /* order of data in byte */
+#define TSSI_CFG_TSDI_H 	( 1 << 7 )      /* data pin polarity */
+#define TSSI_CFG_USE_0 		( 1 << 6 )      /* serial mode data pin select */
+#define TSSI_CFG_USE_TSDI0 	( 0 << 6 )      /* TSDI0 as serial mode data pin */
+#define TSSI_CFG_USE_TSDI7 	( 1 << 6 )      /* TSDI7 as serial mode data pin */
+#define TSSI_CFG_TSCLK_CH 	( 1 << 5 )      /* clk channel select */
+#define TSSI_CFG_PARAL 		( 1 << 4 )      /* mode select */
+#define TSSI_CFG_PARAL_MODE 	( 1 << 4 )      /* parallel select */
+#define TSSI_CFG_SERIAL_MODE 	( 0 << 4 )      /* serial select */
+#define TSSI_CFG_TSCLK_P 	( 1 << 3 )      /* clk edge select */
+#define TSSI_CFG_TSFRM_H 	( 1 << 2 )      /* TSFRM polarity select */
+#define TSSI_CFG_TSSTR_H 	( 1 << 1 )      /* TSSTR polarity select */
+#define TSSI_CFG_TSFAIL_H 	( 1 << 0 )      /* TSFAIL polarity select */
+
+/* TSSI control register */
+#define TSSI_CTRL_OVRNM 	( 1 << 1 )      /* FIFO overrun interrupt mask bit */
+#define TSSI_CTRL_TRIGM 	( 1 << 0 )      /* FIFO trigger interrupt mask bit */
+
+/* TSSI state register */
+#define TSSI_STAT_OVRN 		( 1 << 1 )      /* FIFO overrun interrupt flag bit */
+#define TSSI_STAT_TRIG 		( 1 << 0 )      /* FIFO trigger interrupt flag bit */
+
+/* TSSI PID enable register */
+#define TSSI_PEN_EN00 	( 1 << 0 )      /* enable PID n */
+#define TSSI_PEN_EN10 	( 1 << 1 )
+#define TSSI_PEN_EN20 	( 1 << 2 )
+#define TSSI_PEN_EN30 	( 1 << 3 )
+#define TSSI_PEN_EN40 	( 1 << 4 )
+#define TSSI_PEN_EN50 	( 1 << 5 )
+#define TSSI_PEN_EN60 	( 1 << 6 )
+#define TSSI_PEN_EN70 	( 1 << 7 )
+#define TSSI_PEN_EN01 	( 1 << 16 )
+#define TSSI_PEN_EN11 	( 1 << 17 )
+#define TSSI_PEN_EN21 	( 1 << 18 )
+#define TSSI_PEN_EN31 	( 1 << 19 )
+#define TSSI_PEN_EN41 	( 1 << 20 )
+#define TSSI_PEN_EN51 	( 1 << 21 )
+#define TSSI_PEN_EN61 	( 1 << 22 )
+#define TSSI_PEN_EN71 	( 1 << 23 )
+#define TSSI_PEN_PID0 	( 1 << 31 ) /* PID filter enable PID0 */
+
+/* TSSI PID Filter Registers */
+#define TSSI_PID_PID1_BIT 	16
+#define TSSI_PID_PID1_MASK 	(0x1FFF<<TSSI_PID_PID1_BIT)
+#define TSSI_PID_PID0_BIT 	0
+#define TSSI_PID_PID0_MASK 	(0x1FFF<<TSSI_PID_PID0_BIT)
+
+
+/*************************************************************************
+ * IPU (Image Processing Unit)
+ *************************************************************************/
+
+/* IPU Control Register */
+#define REG_IPU_CTRL			(IPU_BASE + 0x0)
+
+/* IPU Status Register */
+#define REG_IPU_STATUS			(IPU_BASE + 0x4)
+
+/* Data Format Register */
+#define REG_IPU_D_FMT			(IPU_BASE + 0x8)
+
+/* Input Y or YUV422 Packaged Data Address Register */
+#define REG_IPU_Y_ADDR			(IPU_BASE + 0xc)
+
+/* Input U Data Address Register */
+#define REG_IPU_U_ADDR			(IPU_BASE + 0x10)
+
+/* Input V Data Address Register */
+#define REG_IPU_V_ADDR			(IPU_BASE + 0x14)
+
+/* Input Geometric Size Register */
+#define REG_IPU_IN_FM_GS		(IPU_BASE + 0x18)
+
+/* Input Y Data Line Stride Register */
+#define REG_IPU_Y_STRIDE		(IPU_BASE + 0x1c)
+
+/* Input UV Data Line Stride Register */
+#define REG_IPU_UV_STRIDE		(IPU_BASE + 0x20)
+
+/* Output Frame Start Address Register */
+#define REG_IPU_OUT_ADDR		(IPU_BASE + 0x24)
+
+/* Output Geometric Size Register */
+#define REG_IPU_OUT_GS			(IPU_BASE + 0x28)
+
+/* Output Data Line Stride Register */
+#define REG_IPU_OUT_STRIDE		(IPU_BASE + 0x2c)
+
+/* Resize Coefficients Table Index Register */
+#define REG_IPU_RSZ_COEF_INDEX		(IPU_BASE + 0x30)
+
+/* CSC C0 Coefficient Register */
+#define REG_IPU_CSC_CO_COEF		(IPU_BASE + 0x34)
+
+/* CSC C1 Coefficient Register */
+#define REG_IPU_CSC_C1_COEF		(IPU_BASE + 0x38)
+
+/* CSC C2 Coefficient Register */
+#define REG_IPU_CSC_C2_COEF		(IPU_BASE + 0x3c)
+
+/* CSC C3 Coefficient Register */
+#define REG_IPU_CSC_C3_COEF		(IPU_BASE + 0x40)
+
+/* CSC C4 Coefficient Register */
+#define REG_IPU_CSC_C4_COEF		(IPU_BASE + 0x44)
+
+/* Horizontal Resize Coefficients Look Up Table Register group */
+#define REG_IPU_HRSZ_LUT_BASE 		(IPU_BASE + 0x48)
+
+/* Virtical Resize Coefficients Look Up Table Register group */
+#define REG_IPU_VRSZ_LUT_BASE 		(IPU_BASE + 0x4c)
+
+/* CSC Offset Parameter Register */
+#define REG_IPU_CSC_OFSET_PARA		(IPU_BASE + 0x50)
+
+/* Input Y Physical Table Address Register */
+#define REG_IPU_Y_PHY_T_ADDR		(IPU_BASE + 0x54)
+
+/* Input U Physical Table Address Register */
+#define REG_IPU_U_PHY_T_ADDR		(IPU_BASE + 0x58)
+
+/* Input V Physical Table Address Register */
+#define REG_IPU_V_PHY_T_ADDR		(IPU_BASE + 0x5c)
+
+/* Output Physical Table Address Register */
+#define REG_IPU_OUT_PHY_T_ADDR		(IPU_BASE + 0x60)
+
+/* IPU Control */
+#define IPU_CTRL_DFIX_SEL			(1 << 17)
+#define IPU_CTRL_FIELD_SEL			(1 << 16)
+#define IPU_CTRL_FIELD_CONF_EN			(1 << 15)
+#define IPU_CTRL_DISP_SEL			(1 << 14)
+#define IPU_CTRL_DPAGE_MAP			(1 << 13)
+#define IPU_CTRL_SPAGE_MAP 			(1 << 12)
+#define IPU_CTRL_LCDC_SEL			(1 << 11)
+#define IPU_CTRL_SPKG_SEL			(1 << 10)
+#define IPU_CTRL_V_SCALE			(1 << 9)
+#define IPU_CTRL_H_SCALE			(1 << 8)
+#define IPU_CTRL_IPU_RST			(1 << 6)
+#define IPU_CTRL_FM_IRQ_EN			(1 << 5)
+#define IPU_CTRL_CSC_EN				(1 << 4)
+#define IPU_CTRL_VRSZ_EN			(1 << 3)
+#define IPU_CTRL_HRSZ_EN			(1 << 2)
+#define IPU_CTRL_IPU_RUN			(1 << 1)
+#define IPU_CTRL_CHIP_EN			(1 << 0)
+
+/* IPU Status */
+#define IPU_STAT_SIZE_ERR			(1 << 2)
+#define IPU_STAT_FMT_ERR			(1 << 1)
+#define IPU_STAT_OUT_END			(1 << 0)
+
+/* IPU Data Format */
+#define IPU_D_FMT_RGB_OUT_888_FMT		(1 << 24)
+
+#define IPU_D_FMT_RGB_OUT_OFT_MASK		(0x7 << 21)
+
+#define IPU_D_FMT_RGB_OUT_OFT_RGB		(0 << 21)
+#define IPU_D_FMT_RGB_OUT_OFT_RBG		(1 << 21)
+#define IPU_D_FMT_RGB_OUT_OFT_GBR		(2 << 21)
+#define IPU_D_FMT_RGB_OUT_OFT_GRB		(3 << 21)
+#define IPU_D_FMT_RGB_OUT_OFT_BRG		(4 << 21)
+#define IPU_D_FMT_RGB_OUT_OFT_BGR		(5 << 21)
+
+#define IPU_D_FMT_OUT_FMT_MASK			(0x3 << 19)
+
+#define IPU_D_FMT_OUT_FMT_RGB555		(0 << 19)
+#define IPU_D_FMT_OUT_FMT_RGB565		(1 << 19)
+#define IPU_D_FMT_OUT_FMT_RGB888		(2 << 19)
+#define IPU_D_FMT_OUT_FMT_YUV422		(3 << 19)
+
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_MASK		(0x7 << 16)
+
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_Y1UY0V	(0 << 16)
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_Y1VY0U	(1 << 16)
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_UY1VY0	(2 << 16)
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_VY1UY0	(3 << 16)
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_Y0UY1V	(4 << 16)
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_Y0VY1U	(5 << 16)
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_UY0VY1	(6 << 16)
+#define IPU_D_FMT_YUV_PKG_OUT_OFT_VY0UY1	(7 << 16)
+
+#define IPU_D_FMT_IN_OFT_MASK			(0x3 << 2)
+
+#define IPU_D_FMT_IN_OFT_Y1UY0V			(0 << 2)
+#define IPU_D_FMT_IN_OFT_Y1VY0U			(1 << 2)
+#define IPU_D_FMT_IN_OFT_UY1VY0			(2 << 2)
+#define IPU_D_FMT_IN_OFT_VY1UY0			(3 << 2)
+
+#define IPU_D_FMT_IN_FMT_MASK			(0x3 << 0)
+
+#define IPU_D_FMT_IN_FMT_YUV420			(0 << 0)
+#define IPU_D_FMT_IN_FMT_YUV422			(1 << 0)
+#define IPU_D_FMT_IN_FMT_YUV444			(2 << 0)
+#define IPU_D_FMT_IN_FMT_YUV411			(3 << 0)
+
+/* Input Geometric Size Register */
+#define IPU_IN_FM_GS_W_MASK			(0xFFF)
+#define IPU_IN_FM_GS_W(n)			((n) << 16)
+
+#define IPU_IN_FM_GS_H_MASK			(0xFFF)
+#define IPU_IN_FM_GS_H(n)			((n) << 0)
+
+/* Input UV Data Line Stride Register */
+#define IPU_UV_STRIDE_U_S_MASK			(0x1FFF)
+#define IPU_UV_STRIDE_U_S(n) 			((n) << 16)
+
+#define IPU_UV_STRIDE_V_S_MASK			(0x1FFF)
+#define IPU_UV_STRIDE_V_S(n)			((n) << 0)
+
+/* Output Geometric Size Register */
+#define IPU_OUT_GS_W_MASK			(0x7FFF)
+#define IPU_OUT_GS_W(n)				((n) << 16)
+
+#define IPU_OUT_GS_H_MASK			(0x1FFF)
+#define IPU_OUT_GS_H(n)				((n) << 0)
+
+/* Resize Coefficients Table Index Register */
+#define IPU_RSZ_COEF_INDEX_HE_IDX_MASK		(0x1F)
+#define IPU_RSZ_COEF_INDEX_HE_IDX(n)		((n) << 16)
+
+#define IPU_RSZ_COEF_INDEX_VE_IDX_MASK		(0x1F)
+#define IPU_RSZ_COEF_INDEX_VE_IDX(n)		((n) << 0)
+
+/* Resize Coefficients Look Up Table Register group */
+#define IPU_HRSZ_COEF_LUT_START			(1 << 12)
+
+#define IPU_HRSZ_COEF_LUT_W_COEF_MASK		(0x3FF)
+#define IPU_HRSZ_COEF_LUT_W_COEF(n)		((n) << 2)
+
+#define IPU_HRSZ_COEF_LUT_IN_EN			(1 << 1)
+#define IPU_HRSZ_COEF_LUT_OUT_EN		(1 << 0)
+
+#define IPU_VRSZ_COEF_LUT_START			(1 << 12)
+
+#define IPU_VRSZ_COEF_LUT_W_COEF_MASK		(0x3FF)
+#define IPU_VRSZ_COEF_LUT_W_COEF(n)		((n) << 2)
+
+#define IPU_VRSZ_COEF_LUT_IN_EN			(1 << 1)
+#define IPU_VRSZ_COEF_LUT_OUT_EN		(1 << 0)
+
+/* CSC Offset Parameter Register */
+#define IPU_CSC_OFFSET_PARA_CHROM_OF_MASK	(0xFF)
+#define IPU_CSC_OFFSET_PARA_CHROM_OF(n)		((n) << 16)
+
+#define IPU_CSC_OFFSET_LUMA_OF_MASK		(0xFF)
+#define IPU_CSC_OFFSET_LUMA_OF(n)		((n) << 0)
+
+#endif /* __JZ4750D_REGS_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/serial.h b/arch/mips/include/asm/mach-jz4750d/serial.h
new file mode 100644
index 0000000..d23c586
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/serial.h
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/serial.h
+ *
+ *  Ingenic's JZ4750D common include.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_BOARD_SERIAL_H__
+#define __ASM_BOARD_SERIAL_H__
+
+#ifndef CONFIG_SERIAL_MANY_PORTS
+#undef RS_TABLE_SIZE
+#define RS_TABLE_SIZE  1
+#endif
+
+#define JZ_BASE_BAUD	(12000000/16)
+
+#define JZ_SERIAL_PORT_DEFNS \
+	{ .baud_base = JZ_BASE_BAUD, .irq = IRQ_UART0, \
+	  .flags = STD_COM_FLAGS, .iomem_base = (u8 *)UART0_BASE, \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM },
+
+#endif /* __ASM_BORAD_SERIAL_H__ */
diff --git a/arch/mips/include/asm/mach-jz4750d/spi.h b/arch/mips/include/asm/mach-jz4750d/spi.h
new file mode 100644
index 0000000..a34c6a2
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/spi.h
@@ -0,0 +1,72 @@
+/*
+ * linux/arch/mips/include/asm/mach-jz4760b/spi.h
+ *
+ * SSI controller for SPI protocol,use FIFO and DMA;
+ *
+ * Copyright (c) 2010 Ingenic Semiconductor Inc.
+ * Author: Shumb <sbhuang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef __I_SPI_H__
+#define __I_SPI_H__
+
+/* the max number of spi devices */
+#define MAX_SPI_DEVICES				10
+#define MAX_SPI_HOST				1
+
+#define JZ_SPI_ID_INVALID(ssi_id) ( ((ssi_id) < 0) || ((ssi_id) > (MAX_SPI_HOST - 1)) )
+
+#define MAX_SPI_CHIPSELECT_NUM 		MAX_GPIO_NUM
+
+#define PIN_SSI_CE0 	0
+#define PIN_SSI_CE1 	1
+
+struct jz47xx_spi_info {
+	u8	chnl;								/* the chanel of SSI controller */
+	u16	bus_num;							/* spi_master.bus_num */
+	unsigned is_pllclk:1;					/* source clock: 1---pllclk;0---exclk */
+	unsigned long		 board_size;		/* spi_master.num_chipselect */
+	struct spi_board_info	*board_info; 	/* link to spi devices info */
+	void (*set_cs)(struct jz47xx_spi_info *spi, u8 cs,unsigned int pol); /* be defined by spi devices driver user */
+	void (*pins_config)(void);				/* configure spi function pins (CLK,DR,RT) by user if need. */
+	u32	 num_chipselect;
+};
+
+/* Chipselect "set_cs" function could be defined by user. Example as the follow ... */
+/*
+static void spi_gpio_cs(struct jz47xx_spi_info *spi, int cs, int pol);
+{
+	int pinval;
+
+	switch(cs){
+	case 0:
+		pinval = 32*1+31;
+		break;
+	case 1:
+		pinval = 32*1+30;
+		break;
+	case 2:
+		pinval = 32*1+29;
+		break;
+	default:
+		pinval = 32*1+28;
+		break;	
+	}
+	__gpio_as_output(pinval);				
+	switch (pol) {
+	case BITBANG_CS_ACTIVE:
+		__gpio_set_pin(pinval);
+		break;
+	case BITBANG_CS_INACTIVE:
+		__gpio_clear_pin(pinval);
+		break;
+	}
+
+}*/
+
+#endif
diff --git a/arch/mips/include/asm/mach-jz4750d/war.h b/arch/mips/include/asm/mach-jz4750d/war.h
new file mode 100644
index 0000000..3a5bc17
--- /dev/null
+++ b/arch/mips/include/asm/mach-jz4750d/war.h
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_JZ4740_WAR_H
+#define __ASM_MIPS_MACH_JZ4740_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_JZ4740_WAR_H */
diff --git a/arch/mips/include/asm/ptrace.h b/arch/mips/include/asm/ptrace.h
index cdc6a46..3c00e00 100644
--- a/arch/mips/include/asm/ptrace.h
+++ b/arch/mips/include/asm/ptrace.h
@@ -135,7 +135,11 @@ extern int ptrace_set_watch_regs(struct task_struct *child,
 /*
  * Does the process account for user or for system time?
  */
+#if defined(CONFIG_JZ_TCSM)
+#define user_mode(regs) ((((regs)->cp0_status & KU_MASK) == KU_USER) || (((regs)->cp0_status & 0x08000000) == 0x08000000))
+# else
 #define user_mode(regs) (((regs)->cp0_status & KU_MASK) == KU_USER)
+#endif
 
 #define instruction_pointer(regs) ((regs)->cp0_epc)
 #define profile_pc(regs) instruction_pointer(regs)
diff --git a/arch/mips/include/asm/r4kcache.h b/arch/mips/include/asm/r4kcache.h
index 387bf59..39b1ced 100644
--- a/arch/mips/include/asm/r4kcache.h
+++ b/arch/mips/include/asm/r4kcache.h
@@ -17,6 +17,58 @@
 #include <asm/cpu-features.h>
 #include <asm/mipsmtregs.h>
 
+#ifdef CONFIG_JZRISC
+
+#define K0_TO_K1()				\
+do {						\
+	unsigned long __k0_addr;		\
+						\
+	__asm__ __volatile__(			\
+	"la %0, 1f\n\t"				\
+	"or	%0, %0, %1\n\t"			\
+	"jr	%0\n\t"				\
+	"nop\n\t"				\
+	"1: nop\n"				\
+	: "=&r"(__k0_addr)			\
+	: "r" (0x20000000) );			\
+} while(0)
+
+#define K1_TO_K0()				\
+do {						\
+	unsigned long __k0_addr;		\
+	__asm__ __volatile__(			\
+	"nop;nop;nop;nop;nop;nop;nop\n\t"	\
+	"la %0, 1f\n\t"				\
+	"jr	%0\n\t"				\
+	"nop\n\t"				\
+	"1:	nop\n"				\
+	: "=&r" (__k0_addr));			\
+} while (0)
+
+#define INVALIDATE_BTB()			\
+do {						\
+	unsigned long tmp;			\
+	__asm__ __volatile__(			\
+	".set mips32\n\t"			\
+	"mfc0 %0, $16, 7\n\t"			\
+	"nop\n\t"				\
+	"ori %0, 2\n\t"				\
+	"mtc0 %0, $16, 7\n\t"			\
+	"nop\n\t"				\
+	: "=&r" (tmp));				\
+} while (0)
+
+#define SYNC_WB() __asm__ __volatile__ ("sync")
+
+#else /* CONFIG_JZRISC */
+
+#define K0_TO_K1() do { } while (0)
+#define K1_TO_K0() do { } while (0)
+#define INVALIDATE_BTB() do { } while (0)
+#define SYNC_WB() do { } while (0)
+
+#endif /* CONFIG_JZRISC */
+
 /*
  * This macro return a properly sign-extended address suitable as base address
  * for indexed cache operations.  Two issues here:
@@ -144,6 +196,7 @@ static inline void flush_icache_line_indexed(unsigned long addr)
 {
 	__iflush_prologue
 	cache_op(Index_Invalidate_I, addr);
+	INVALIDATE_BTB();
 	__iflush_epilogue
 }
 
@@ -151,6 +204,7 @@ static inline void flush_dcache_line_indexed(unsigned long addr)
 {
 	__dflush_prologue
 	cache_op(Index_Writeback_Inv_D, addr);
+	SYNC_WB();
 	__dflush_epilogue
 }
 
@@ -163,6 +217,7 @@ static inline void flush_icache_line(unsigned long addr)
 {
 	__iflush_prologue
 	cache_op(Hit_Invalidate_I, addr);
+	INVALIDATE_BTB();
 	__iflush_epilogue
 }
 
@@ -170,6 +225,7 @@ static inline void flush_dcache_line(unsigned long addr)
 {
 	__dflush_prologue
 	cache_op(Hit_Writeback_Inv_D, addr);
+	SYNC_WB();
 	__dflush_epilogue
 }
 
@@ -177,6 +233,7 @@ static inline void invalidate_dcache_line(unsigned long addr)
 {
 	__dflush_prologue
 	cache_op(Hit_Invalidate_D, addr);
+	SYNC_WB();
 	__dflush_epilogue
 }
 
@@ -209,6 +266,7 @@ static inline void flush_scache_line(unsigned long addr)
 static inline void protected_flush_icache_line(unsigned long addr)
 {
 	protected_cache_op(Hit_Invalidate_I, addr);
+	INVALIDATE_BTB();
 }
 
 /*
@@ -220,6 +278,7 @@ static inline void protected_flush_icache_line(unsigned long addr)
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
 	protected_cache_op(Hit_Writeback_Inv_D, addr);
+	SYNC_WB();
 }
 
 static inline void protected_writeback_scache_line(unsigned long addr)
@@ -396,8 +455,12 @@ static inline void blast_##pfx##cache##lsize##_page_indexed(unsigned long page)
 __BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
 __BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
 __BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16)
+
+#ifndef CONFIG_JZRISC
 __BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
 __BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
+#endif
+
 __BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32)
 __BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 64)
 __BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
@@ -405,12 +468,125 @@ __BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64)
 __BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128)
 
 __BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 16)
+
+#ifndef CONFIG_JZRISC
 __BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 32)
+#endif
+
 __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 16)
 __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 32)
 __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 64)
 __BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 128)
 
+#ifdef CONFIG_JZRISC
+
+static inline void blast_dcache32(void)
+{
+	unsigned long start = INDEX_BASE;
+	unsigned long end = start + current_cpu_data.dcache.waysize;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	unsigned long ws_end = current_cpu_data.dcache.ways <<
+	                       current_cpu_data.dcache.waybit;
+	unsigned long ws, addr;
+
+	for (ws = 0; ws < ws_end; ws += ws_inc)
+		for (addr = start; addr < end; addr += 0x400)
+			cache32_unroll32(addr|ws,Index_Writeback_Inv_D);
+
+	SYNC_WB();
+}
+
+static inline void blast_dcache32_page(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = page + PAGE_SIZE;
+
+	do {
+		cache32_unroll32(start,Hit_Writeback_Inv_D);
+		start += 0x400;
+	} while (start < end);
+
+	SYNC_WB();
+}
+
+static inline void blast_dcache32_page_indexed(unsigned long page)
+{
+	unsigned long indexmask = current_cpu_data.dcache.waysize - 1;
+	unsigned long start = INDEX_BASE + (page & indexmask);
+	unsigned long end = start + PAGE_SIZE;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	unsigned long ws_end = current_cpu_data.dcache.ways <<
+	                       current_cpu_data.dcache.waybit;
+	unsigned long ws, addr;
+
+	for (ws = 0; ws < ws_end; ws += ws_inc)
+		for (addr = start; addr < end; addr += 0x400)
+			cache32_unroll32(addr|ws,Index_Writeback_Inv_D);
+
+	SYNC_WB();
+}
+
+static inline void blast_icache32(void)
+{
+	unsigned long start = INDEX_BASE;
+	unsigned long end = start + current_cpu_data.icache.waysize;
+	unsigned long ws_inc = 1UL << current_cpu_data.icache.waybit;
+	unsigned long ws_end = current_cpu_data.icache.ways <<
+	                       current_cpu_data.icache.waybit;
+	unsigned long ws, addr;
+
+	K0_TO_K1();
+
+	for (ws = 0; ws < ws_end; ws += ws_inc)
+		for (addr = start; addr < end; addr += 0x400)
+			cache32_unroll32(addr|ws,Index_Invalidate_I);
+
+	INVALIDATE_BTB();
+
+	K1_TO_K0();
+}
+
+static inline void blast_icache32_page(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = page + PAGE_SIZE;
+
+	K0_TO_K1();
+
+	do {
+		cache32_unroll32(start,Hit_Invalidate_I);
+		start += 0x400;
+	} while (start < end);
+
+	INVALIDATE_BTB();
+
+	K1_TO_K0();
+}
+
+static inline void blast_icache32_page_indexed(unsigned long page)
+{
+	unsigned long indexmask = current_cpu_data.icache.waysize - 1;
+	unsigned long start = INDEX_BASE + (page & indexmask);
+	unsigned long end = start + PAGE_SIZE;
+	unsigned long ws_inc = 1UL << current_cpu_data.icache.waybit;
+	unsigned long ws_end = current_cpu_data.icache.ways <<
+	                       current_cpu_data.icache.waybit;
+	unsigned long ws, addr;
+
+	K0_TO_K1();
+
+	for (ws = 0; ws < ws_end; ws += ws_inc)
+		for (addr = start; addr < end; addr += 0x400)
+			cache32_unroll32(addr|ws,Index_Invalidate_I);
+
+	INVALIDATE_BTB();
+
+	K1_TO_K0();
+}
+
+#endif /* CONFIG_JZRISC */
+
+
 /* build blast_xxx_range, protected_blast_xxx_range */
 #define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \
 static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
@@ -432,13 +608,76 @@ static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
 	__##pfx##flush_epilogue						\
 }
 
+#ifndef CONFIG_JZRISC
 __BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_)
+#endif
+
 __BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
+
+#ifndef CONFIG_JZRISC
 __BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_)
 __BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, )
+#endif
+
 __BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, )
 /* blast_inv_dcache_range */
 __BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D, )
 __BUILD_BLAST_CACHE_RANGE(inv_s, scache, Hit_Invalidate_SD, )
 
+#ifdef CONFIG_JZRISC
+
+static inline void protected_blast_dcache_range(unsigned long start,
+						unsigned long end)
+{
+	unsigned long lsize = cpu_dcache_line_size();
+	unsigned long addr = start & ~(lsize - 1);
+	unsigned long aend = (end - 1) & ~(lsize - 1);
+
+	while (1) {
+		protected_cache_op(Hit_Writeback_Inv_D, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+	SYNC_WB();
+}
+
+static inline void protected_blast_icache_range(unsigned long start,
+						unsigned long end)
+{
+	unsigned long lsize = cpu_icache_line_size();
+	unsigned long addr = start & ~(lsize - 1);
+	unsigned long aend = (end - 1) & ~(lsize - 1);
+
+	K0_TO_K1();
+
+	while (1) {
+		protected_cache_op(Hit_Invalidate_I, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+	INVALIDATE_BTB();
+
+	K1_TO_K0();
+}
+
+static inline void blast_dcache_range(unsigned long start,
+				      unsigned long end)
+{
+	unsigned long lsize = cpu_dcache_line_size();
+	unsigned long addr = start & ~(lsize - 1);
+	unsigned long aend = (end - 1) & ~(lsize - 1);
+
+	while (1) {
+		cache_op(Hit_Writeback_Inv_D, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+	SYNC_WB();
+}
+
+#endif /* CONFIG_JZRISC */
+
 #endif /* _ASM_R4KCACHE_H */
diff --git a/arch/mips/include/asm/stackframe.h b/arch/mips/include/asm/stackframe.h
index 58730c5..bc26a74 100644
--- a/arch/mips/include/asm/stackframe.h
+++ b/arch/mips/include/asm/stackframe.h
@@ -367,6 +367,11 @@
 		mfc0	a0, CP0_STATUS
 		ori	a0, STATMASK
 		xori	a0, STATMASK
+
+#if defined(CONFIG_JZSOC)
+		la      v1, 0xf7ffffff
+		and     a0, a0, v1
+#endif
 		mtc0	a0, CP0_STATUS
 		li	v1, 0xff00
 		and	a0, v1
@@ -485,6 +490,13 @@
 		li	t1, ST0_CU0 | STATMASK
 		or	t0, t1
 		xori	t0, STATMASK
+
+#if defined(CONFIG_JZSOC)
+		la      t1, 0xf7ffffff
+	        and     t0, t0, t1
+		li	t1, ST0_CU0 | STATMASK
+#endif
+
 		mtc0	t0, CP0_STATUS
 #else /* CONFIG_MIPS_MT_SMTC */
 		/*
@@ -520,6 +532,12 @@
 		li	t1, ST0_CU0 | STATMASK
 		or	t0, t1
 		xori	t0, STATMASK & ~1
+
+#if defined(CONFIG_JZSOC)
+		la      t1, 0xf7ffffff
+	        and     t0, t0, t1
+		li	t1, ST0_CU0 | STATMASK
+#endif
 		mtc0	t0, CP0_STATUS
 #else /* CONFIG_MIPS_MT_SMTC */
 		/*
@@ -588,6 +606,13 @@
 #endif
 		or	t0, t1
 		xori	t0, STATMASK & ~1
+
+#if defined(CONFIG_JZSOC)
+		la      t1, 0xf7ffffff
+	        and     t0, t0, t1
+		li	t1, ST0_CU0 | (STATMASK & ~1)
+#endif
+
 		mtc0	t0, CP0_STATUS
 #ifdef CONFIG_MIPS_MT_SMTC
 		_ehb
diff --git a/arch/mips/jz4750d/Makefile b/arch/mips/jz4750d/Makefile
new file mode 100644
index 0000000..fca393d
--- /dev/null
+++ b/arch/mips/jz4750d/Makefile
@@ -0,0 +1,22 @@
+#
+# Makefile for the Ingenic JZ4750D.
+#
+
+# Object file lists.
+
+obj-y += prom.o irq.o time.o reset.o setup.o dma.o \
+	platform.o i2c.o
+
+obj-$(CONFIG_PROC_FS)		+= proc.o
+
+# board specific support
+
+obj-$(CONFIG_JZ4750D_CETUS)	+= board-cetus.o
+
+# PM support
+
+obj-$(CONFIG_PM)         +=pm.o
+
+# CPU Frequency scaling support
+
+obj-$(CONFIG_CPU_FREQ_JZ)       +=cpufreq.o
diff --git a/arch/mips/jz4750d/board-cetus.c b/arch/mips/jz4750d/board-cetus.c
new file mode 100644
index 0000000..40297dc
--- /dev/null
+++ b/arch/mips/jz4750d/board-cetus.c
@@ -0,0 +1,252 @@
+/*
+ * linux/arch/mips/jz4750d/board-cetus.c
+ *
+ * JZ4750D CETUS board setup routines.
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/mmc/host.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+#include <linux/spi/spi.h>
+
+void __init board_msc_init(void);
+
+extern int jz_add_msc_devices(unsigned int controller, struct jz_mmc_platform_data *plat);
+extern int __init jz_add_spi_devices(unsigned int host_id, struct spi_board_info *board_info,int board_num);
+
+extern void (*jz_timer_callback)(void);
+
+static void cetus_sd_gpio_init(struct device *dev)
+{
+	__gpio_as_msc0_4bit();
+	__gpio_as_output(GPIO_SD0_VCC_EN_N);
+	__gpio_as_input(GPIO_SD0_CD_N);
+}
+
+static void cetus_sd_power_on(struct device *dev)
+{
+	__gpio_clear_pin(GPIO_SD0_VCC_EN_N);
+}
+
+static void cetus_sd_power_off(struct device *dev)
+{
+	__gpio_set_pin(GPIO_SD0_VCC_EN_N);
+}
+
+static void cetus_sd_cpm_start(struct device *dev)
+{
+	__cpm_start_msc(0);
+}
+
+static unsigned int cetus_sd_status(struct device *dev)
+{
+#if defined(CONFIG_JZ_SYSTEM_AT_CARD)
+	return 1;
+#endif
+	unsigned int status;
+
+	status = (unsigned int) __gpio_get_pin(GPIO_SD0_CD_N);
+	return (!status);
+}
+
+#if 0
+static void cetus_sd_plug_change(int state)
+{
+	if(state == CARD_INSERTED)
+		__gpio_as_irq_high_level(MSC0_HOTPLUG_PIN); /* wait remove */
+	else
+		__gpio_as_irq_low_level(MSC0_HOTPLUG_PIN); /* wait insert */
+}
+#else
+static void cetus_sd_plug_change(int state)
+{
+	if(state == CARD_INSERTED)
+		__gpio_as_irq_rise_edge(MSC0_HOTPLUG_PIN);
+	else
+		__gpio_as_irq_fall_edge(MSC0_HOTPLUG_PIN);
+}
+#endif
+
+static unsigned int cetus_sd_get_wp(struct device *dev)
+{
+#if defined(CONFIG_JZ_SYSTEM_AT_CARD)
+	return 0;
+#endif
+	unsigned int status;
+
+	status = (unsigned int) __gpio_get_pin(GPIO_SD0_WP);
+	return (status);
+}
+
+struct jz_mmc_platform_data cetus_sd_data = {
+#ifndef CONFIG_JZ_MSC0_SDIO_SUPPORT
+	.support_sdio   = 0,
+#else
+	.support_sdio   = 1,
+#endif
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+#if defined(CONFIG_SYSTEM_AT_CARD)
+	.status_irq	= 0,
+	.detect_pin     = 0,
+#else
+	.status_irq	= MSC0_HOTPLUG_IRQ,
+	.detect_pin     = GPIO_SD0_CD_N,
+#endif
+	.init           = cetus_sd_gpio_init,
+	.power_on       = cetus_sd_power_on,
+	.power_off      = cetus_sd_power_off,
+	.cpm_start	= cetus_sd_cpm_start,
+	.status		= cetus_sd_status,
+	.plug_change	= cetus_sd_plug_change,
+	.write_protect  = cetus_sd_get_wp,
+	.max_bus_width  = MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED | MMC_CAP_4_BIT_DATA,
+#ifdef CONFIG_JZ_MSC0_BUS_1
+	.bus_width      = 1,
+#elif defined  CONFIG_JZ_MSC0_BUS_4
+	.bus_width      = 4,
+#else
+	.bus_width      = 8,
+#endif
+};
+
+static void cetus_tf_gpio_init(struct device *dev)
+{
+	__gpio_as_msc1_4bit();
+	__gpio_as_output(GPIO_SD1_VCC_EN_N);
+	__gpio_as_input(GPIO_SD1_CD_N);
+}
+
+static void cetus_tf_power_on(struct device *dev)
+{
+	__msc1_enable_power();
+}
+
+static void cetus_tf_power_off(struct device *dev)
+{
+	__msc1_disable_power();
+}
+
+static void cetus_tf_cpm_start(struct device *dev)
+{
+	__cpm_start_msc(1);
+}
+
+static unsigned int cetus_tf_status(struct device *dev)
+{
+	unsigned int status;
+
+	status = (unsigned int) __gpio_get_pin(GPIO_SD1_CD_N);
+	return (!status);
+}
+
+#if 0
+static void cetus_tf_plug_change(int state)
+{
+	if(state == CARD_INSERTED)
+		__gpio_as_irq_low_level(MSC1_HOTPLUG_PIN);
+	else
+		__gpio_as_irq_high_level(MSC1_HOTPLUG_PIN);
+}
+#else
+static void cetus_tf_plug_change(int state)
+{
+	if(state == CARD_INSERTED)
+		__gpio_as_irq_fall_edge(MSC1_HOTPLUG_PIN);
+	else
+		__gpio_as_irq_rise_edge(MSC1_HOTPLUG_PIN);
+}
+#endif
+
+struct jz_mmc_platform_data cetus_tf_data = {
+#ifndef CONFIG_JZ_MSC1_SDIO_SUPPORT
+	.support_sdio   = 0,
+#else
+	.support_sdio   = 1,
+#endif
+	.ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+	.status_irq	= MSC1_HOTPLUG_IRQ,
+	.detect_pin     = GPIO_SD1_CD_N,
+	.init           = cetus_tf_gpio_init,
+	.power_on       = cetus_tf_power_on,
+	.power_off      = cetus_tf_power_off,
+	.cpm_start	= cetus_tf_cpm_start,
+	.status		= cetus_tf_status,
+	.plug_change	= cetus_tf_plug_change,
+	.max_bus_width  = MMC_CAP_SD_HIGHSPEED | MMC_CAP_4_BIT_DATA,
+#ifdef CONFIG_JZ_MSC1_BUS_1
+	.bus_width      = 1,
+#else
+	.bus_width      = 4,
+#endif
+};
+
+/* SPI devices */
+struct spi_board_info cetus_spi0_board_info[]  = {
+	[0] = {
+		.modalias       = "spidev0",
+		.bus_num        = SPI0_BUS,
+		.chip_select    = SPI_CHIPSELECT_NUM_A,
+		.max_speed_hz   = 120000,
+	},
+	[1] = {
+		.modalias       = "spitest",
+		.bus_num        = SPI0_BUS,
+		.chip_select    = SPI_CHIPSELECT_NUM_B,
+		.max_speed_hz   = 2500000,
+	},
+};
+void __init board_spi_init(void){
+	jz_add_spi_devices(0,cetus_spi0_board_info,ARRAY_SIZE(cetus_spi0_board_info));
+}
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4750d/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+}
+
+void __init board_msc_init(void)
+{
+#ifdef CONFIG_JZ_MSC0
+	jz_add_msc_devices(0, &cetus_sd_data);
+#endif
+
+#ifdef CONFIG_JZ_MSC1
+	jz_add_msc_devices(1, &cetus_tf_data);
+#endif
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4750D CETUS board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = NULL;
+}
diff --git a/arch/mips/jz4750d/cpufreq.c b/arch/mips/jz4750d/cpufreq.c
new file mode 100644
index 0000000..9f31854
--- /dev/null
+++ b/arch/mips/jz4750d/cpufreq.c
@@ -0,0 +1,598 @@
+/*
+ * linux/arch/mips/jz4750d/cpufreq.c
+ *
+ * cpufreq driver for JZ4750D
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/cpufreq.h>
+
+#include <asm/jzsoc.h>
+#include <asm/processor.h>
+
+#define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_DRIVER, \
+						"cpufreq-jz4750d", msg)
+
+#undef CHANGE_PLL
+
+#define PLL_UNCHANGED 0
+#define PLL_GOES_UP   1
+#define PLL_GOES_DOWN 2
+
+#define PLL_WAIT_500NS (500*(__cpm_get_cclk()/1000000000))
+
+/* Saved the boot-time parameters */
+static struct {
+	/* SDRAM parameters */
+	unsigned int mclk;  /* memory clock, KHz */
+	unsigned int tras;  /* RAS pulse width, cycles of mclk */
+	unsigned int rcd;   /* RAS to CAS Delay, cycles of mclk */
+	unsigned int tpc;   /* RAS Precharge time, cycles of mclk */
+	unsigned int trwl;  /* Write Precharge Time, cycles of mclk */
+	unsigned int trc;   /* RAS Cycle Time, cycles of mclk */
+	unsigned int rtcor; /* Refresh Time Constant */
+	unsigned int sdram_initialized;
+
+	/* LCD parameters */
+	unsigned int lcdpix_clk; /* LCD Pixel clock, Hz */
+	unsigned int lcd_clks_initialized;
+} boot_config;
+
+struct jz4750d_freq_percpu_info {
+	struct cpufreq_frequency_table table[7];
+};
+
+static struct jz4750d_freq_percpu_info jz4750d_freq_table;
+
+/*
+ * This contains the registers value for an operating point.
+ * If only part of a register needs to change then there is
+ * a mask value for that register.
+ * When going to a new operating point the current register
+ * value is ANDed with the ~mask and ORed with the new value.
+ */
+struct dpm_regs {
+	u32 cpccr;        /* Clock Freq Control Register */
+	u32 cpccr_mask;   /* Clock Freq Control Register mask */
+	u32 cppcr;        /* PLL1 Control Register */
+	u32 cppcr_mask;   /* PLL1 Control Register mask */
+	u32 pll_up_flag;  /* New PLL freq is higher than current or not */
+};
+
+extern jz_clocks_t jz_clocks;
+
+static void jz_update_clocks(void)
+{
+	/* Next clocks must be updated if we have changed
+	 * the PLL or divisors.
+	 */
+	jz_clocks.cclk = __cpm_get_cclk();
+	jz_clocks.hclk = __cpm_get_hclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.mscclk = __cpm_get_mscclk(0);
+}
+
+static void
+jz_init_boot_config(void)
+{
+	if (!boot_config.lcd_clks_initialized) {
+		/* the first time to scale pll */
+		boot_config.lcdpix_clk = __cpm_get_pixclk();
+		boot_config.lcd_clks_initialized = 1;
+	}
+
+	if (!boot_config.sdram_initialized) {
+		/* the first time to scale frequencies */
+		unsigned int dmcr, rtcor;
+		unsigned int tras, rcd, tpc, trwl, trc;
+
+		dmcr = REG_EMC_DMCR;
+		rtcor = REG_EMC_RTCOR;
+
+		tras = (dmcr >> 13) & 0x7;
+		rcd = (dmcr >> 11) & 0x3;
+		tpc = (dmcr >> 8) & 0x7;
+		trwl = (dmcr >> 5) & 0x3;
+		trc = (dmcr >> 2) & 0x7;
+
+		boot_config.mclk = __cpm_get_mclk() / 1000;
+		boot_config.tras = tras + 4;
+		boot_config.rcd = rcd + 1;
+		boot_config.tpc = tpc + 1;
+		boot_config.trwl = trwl + 1;
+		boot_config.trc = trc * 2 + 1;
+		boot_config.rtcor = rtcor;
+
+		boot_config.sdram_initialized = 1;
+	}
+}
+
+static void jz_update_dram_rtcor(unsigned int new_mclk)
+{
+	unsigned int rtcor;
+
+	new_mclk /= 1000;
+	rtcor = boot_config.rtcor * new_mclk / boot_config.mclk;
+	rtcor--;
+
+	if (rtcor < 1) rtcor = 1;
+	if (rtcor > 255) rtcor = 255;
+
+	REG_EMC_RTCOR = rtcor;
+	REG_EMC_RTCNT = rtcor;
+}
+
+static void jz_update_dram_dmcr(unsigned int new_mclk)
+{
+	unsigned int dmcr;
+	unsigned int tras, rcd, tpc, trwl, trc;
+	unsigned int valid_time, new_time; /* ns */
+
+	new_mclk /= 1000;
+	tras = boot_config.tras * new_mclk / boot_config.mclk;
+	rcd = boot_config.rcd * new_mclk / boot_config.mclk;
+	tpc = boot_config.tpc * new_mclk / boot_config.mclk;
+	trwl = boot_config.trwl * new_mclk / boot_config.mclk;
+	trc = boot_config.trc * new_mclk / boot_config.mclk;
+
+	/* Validation checking */
+	valid_time = (boot_config.tras * 1000000) / boot_config.mclk;
+	new_time = (tras * 1000000) / new_mclk;
+	if (new_time < valid_time) tras += 1;
+
+	valid_time = (boot_config.rcd * 1000000) / boot_config.mclk;
+	new_time = (rcd * 1000000) / new_mclk;
+	if (new_time < valid_time) rcd += 1;
+
+	valid_time = (boot_config.tpc * 1000000) / boot_config.mclk;
+	new_time = (tpc * 1000000) / new_mclk;
+	if (new_time < valid_time) tpc += 1;
+
+	valid_time = (boot_config.trwl * 1000000) / boot_config.mclk;
+	new_time = (trwl * 1000000) / new_mclk;
+	if (new_time < valid_time) trwl += 1;
+
+	valid_time = (boot_config.trc * 1000000) / boot_config.mclk;
+	new_time = (trc * 1000000) / new_mclk;
+	if (new_time < valid_time) trc += 2;
+
+	tras = (tras < 4) ? 4: tras;
+	tras = (tras > 11) ? 11: tras;
+	tras -= 4;
+
+	rcd = (rcd < 1) ? 1: rcd;
+	rcd = (rcd > 4) ? 4: rcd;
+	rcd -= 1;
+
+	tpc = (tpc < 1) ? 1: tpc;
+	tpc = (tpc > 8) ? 8: tpc;
+	tpc -= 1;
+
+	trwl = (trwl < 1) ? 1: trwl;
+	trwl = (trwl > 4) ? 4: trwl;
+	trwl -= 1;
+
+	trc = (trc < 1) ? 1: trc;
+	trc = (trc > 15) ? 15: trc;
+	trc /= 2;
+
+	dmcr = REG_EMC_DMCR;
+
+	dmcr &= ~(EMC_DMCR_TRAS_MASK | EMC_DMCR_RCD_MASK | EMC_DMCR_TPC_MASK | EMC_DMCR_TRWL_MASK | EMC_DMCR_TRC_MASK);
+	dmcr |= ((tras << EMC_DMCR_TRAS_BIT) | (rcd << EMC_DMCR_RCD_BIT) | (tpc << EMC_DMCR_TPC_BIT) | (trwl << EMC_DMCR_TRWL_BIT) | (trc << EMC_DMCR_TRC_BIT));
+
+	REG_EMC_DMCR = dmcr;
+}
+
+static void jz_update_dram_prev(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so first update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR before changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	} else {
+		/* We're going SLOWER: first update RTCOR value
+		 * before changing the frequency.
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	}
+}
+
+static void jz_update_dram_post(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so update RTCOR
+		 * after changing the frequency
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	} else {
+		/* We're going SLOWER: so update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR after changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	}
+}
+
+static void jz_scale_divisors(struct dpm_regs *regs)
+{
+	unsigned int cpccr;
+	unsigned int cur_mclk, new_mclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	cpccr = REG_CPM_CPCCR;
+	cpccr &= ~((unsigned long)regs->cpccr_mask);
+	cpccr |= regs->cpccr;
+	cpccr |= CPM_CPCCR_CE;       /* update immediately */
+
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = __cpm_get_pllout() / div[(cpccr & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT];
+
+	/* Update some DRAM parameters before changing frequency */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPCCR), "r" (cpccr), "r" (wait), "r" (tmp));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+
+#ifdef CHANGE_PLL
+/* Maintain the LCD clock and pixel clock */
+static void jz_scale_lcd_divisors(struct dpm_regs *regs)
+{
+	unsigned int new_pll, new_lcd_div, new_lcdpix_div;
+	unsigned int cpccr;
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	if (!boot_config.lcd_clks_initialized) return;
+
+	new_pll = __cpm_get_pllout();
+	new_lcd_div = new_pll / boot_config.lcd_clk;
+	new_lcdpix_div = new_pll / boot_config.lcdpix_clk;
+
+	if (new_lcd_div < 1)
+		new_lcd_div = 1;
+	if (new_lcd_div > 16)
+		new_lcd_div = 16;
+
+	if (new_lcdpix_div < 1)
+		new_lcdpix_div = 1;
+	if (new_lcdpix_div > 512)
+		new_lcdpix_div = 512;
+
+//	REG_CPM_CPCCR2 = new_lcdpix_div - 1;
+
+	cpccr = REG_CPM_CPCCR;
+	cpccr &= ~CPM_CPCCR_LDIV_MASK;
+	cpccr |= ((new_lcd_div - 1) << CPM_CPCCR_LDIV_BIT);
+	cpccr |= CPM_CPCCR_CE;       /* update immediately */
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPCCR), "r" (cpccr), "r" (wait), "r" (tmp));
+}
+
+static void jz_scale_pll(struct dpm_regs *regs)
+{
+	unsigned int cppcr;
+	unsigned int cur_mclk, new_mclk, new_pll;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	int od[] = {1, 2, 2, 4};
+
+	cppcr = REG_CPM_CPPCR;
+	cppcr &= ~(regs->cppcr_mask | CPM_CPPCR_PLLS | CPM_CPPCR_PLLEN | CPM_CPPCR_PLLST_MASK);
+	regs->cppcr &= ~CPM_CPPCR_PLLEN;
+	cppcr |= (regs->cppcr | 0xff);
+
+	/* Update some DRAM parameters before changing frequency */
+	new_pll = JZ_EXTAL * ((cppcr>>23)+2) / ((((cppcr>>18)&0x1f)+2) * od[(cppcr>>16)&0x03]);
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = new_pll / div[(REG_CPM_CPCCR>>16) & 0xf];
+
+	/*
+	 * Update some SDRAM parameters
+	 */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/*
+	 * Update PLL, align code to cache line.
+	 */
+	cppcr |= CPM_CPPCR_PLLEN;
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPPCR), "r" (cppcr));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+#endif
+
+static void jz4750d_transition(struct dpm_regs *regs)
+{
+	/*
+	 * Get and save some boot-time conditions.
+	 */
+	jz_init_boot_config();
+
+#ifdef CHANGE_PLL
+	/*
+	 * Disable LCD before scaling pll.
+	 * LCD and LCD pixel clocks should not be changed even if the PLL
+	 * output frequency has been changed.
+	 */
+	REG_LCD_CTRL &= ~LCD_CTRL_ENA;
+
+	/*
+	 * Stop module clocks before scaling PLL
+	 */
+	__cpm_stop_eth();
+	__cpm_stop_aic(1);
+	__cpm_stop_aic(2);
+#endif
+
+	/* ... add more as necessary */
+
+	if (regs->pll_up_flag == PLL_GOES_UP) {
+		/* the pll frequency is going up, so change dividors first */
+		jz_scale_divisors(regs);
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+	}
+	else if (regs->pll_up_flag == PLL_GOES_DOWN) {
+		/* the pll frequency is going down, so change pll first */
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+		jz_scale_divisors(regs);
+	}
+	else {
+		/* the pll frequency is unchanged, so change divisors only */
+		jz_scale_divisors(regs);
+	}
+
+#ifdef CHANGE_PLL
+	/*
+	 * Restart module clocks before scaling PLL
+	 */
+	__cpm_start_eth();
+	__cpm_start_aic(1);
+	__cpm_start_aic(2);
+
+	/* ... add more as necessary */
+
+	/* Scale the LCD divisors after scaling pll */
+	if (regs->pll_up_flag != PLL_UNCHANGED) {
+		jz_scale_lcd_divisors(regs);
+	}
+
+	/* Enable LCD controller */
+	REG_LCD_CTRL &= ~LCD_CTRL_DIS;
+	REG_LCD_CTRL |= LCD_CTRL_ENA;
+#endif
+
+	/* Update system clocks */
+	jz_update_clocks();
+}
+
+extern unsigned int idle_times;
+static unsigned int jz4750d_freq_get(unsigned int cpu)
+{
+	return  (__cpm_get_cclk() / 1000);
+}
+
+static unsigned int index_to_divisor(unsigned int index, struct dpm_regs *regs)
+{
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[4] = {1, 2, 2, 2}; /* divisors of I:S:P:M */
+	unsigned int div_of_cclk, new_freq, i;
+
+	regs->pll_up_flag = PLL_UNCHANGED;
+	regs->cpccr_mask = CPM_CPCCR_CDIV_MASK | CPM_CPCCR_HDIV_MASK | CPM_CPCCR_PDIV_MASK | CPM_CPCCR_MDIV_MASK;
+
+	new_freq = jz4750d_freq_table.table[index].frequency;
+
+	do {
+		div_of_cclk = __cpm_get_pllout() / (1000 * new_freq);
+	} while (div_of_cclk==0);
+
+	if(div_of_cclk == 1 || div_of_cclk == 2 || div_of_cclk == 4) {
+		for(i = 1; i<4; i++) {
+			div[i] = 3;
+		}
+	} else {
+		for(i = 1; i<4; i++) {
+			div[i] = 2;
+		}
+	}
+
+	for(i = 0; i<4; i++) {
+		div[i] *= div_of_cclk;
+	}
+
+	dprintk("divisors of I:S:P:M = %d:%d:%d:%d\n", div[0], div[1], div[2], div[3]);
+
+	regs->cpccr =
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) |
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) |
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT);
+
+	return  div_of_cclk;
+}
+
+static void jz4750d_set_cpu_divider_index(unsigned int cpu, unsigned int index)
+{
+	unsigned long divisor, old_divisor;
+	struct cpufreq_freqs freqs;
+	struct dpm_regs regs;
+
+	old_divisor = __cpm_get_pllout() /  __cpm_get_cclk();
+	divisor = index_to_divisor(index, &regs);
+
+	freqs.old = __cpm_get_cclk() / 1000;
+	freqs.new =  __cpm_get_pllout() / (1000 * divisor);
+	freqs.cpu = cpu;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	if (old_divisor != divisor)
+		jz4750d_transition(&regs);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+}
+
+static int jz4750d_freq_target(struct cpufreq_policy *policy,
+			  unsigned int target_freq,
+			  unsigned int relation)
+{
+	unsigned int new_index = 0;
+
+	if (cpufreq_frequency_table_target(policy,
+					   &jz4750d_freq_table.table[0],
+					   target_freq, relation, &new_index))
+		return -EINVAL;
+
+	jz4750d_set_cpu_divider_index(policy->cpu, new_index);
+
+	dprintk("new frequency is %d KHz (REG_CPM_CPCCR:0x%x)\n", __cpm_get_cclk() / 1000, REG_CPM_CPCCR);
+
+	return 0;
+}
+
+static int jz4750d_freq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy,
+					      &jz4750d_freq_table.table[0]);
+}
+
+static int __init jz4750d_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+
+	struct cpufreq_frequency_table *table =	&jz4750d_freq_table.table[0];
+	unsigned int MAX_FREQ;
+
+	dprintk(KERN_INFO "Jz4750d cpufreq driver\n");
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->cur = MAX_FREQ = __cpm_get_cclk() / 1000; /* in kHz. Current and max frequency is determined by u-boot */
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	policy->cpuinfo.min_freq = MAX_FREQ/8;
+	policy->cpuinfo.max_freq = MAX_FREQ;
+	policy->cpuinfo.transition_latency = 100000; /* in 10^(-9) s = nanoseconds */
+
+	table[0].index = 0;
+	table[0].frequency = MAX_FREQ/8;
+	table[1].index = 1;
+	table[1].frequency = MAX_FREQ/6;
+	table[2].index = 2;
+	table[2].frequency = MAX_FREQ/4;
+	table[3].index = 3;
+	table[3].frequency = MAX_FREQ/3;
+	table[4].index = 4;
+	table[4].frequency = MAX_FREQ/2;
+	table[5].index = 5;
+	table[5].frequency = MAX_FREQ;
+	table[6].index = 6;
+	table[6].frequency = CPUFREQ_TABLE_END;
+
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	cpufreq_frequency_table_get_attr(table, policy->cpu); /* for showing /sys/devices/system/cpu/cpuX/cpufreq/stats/ */
+#endif
+
+	return  cpufreq_frequency_table_cpuinfo(policy, table);
+}
+
+static struct cpufreq_driver cpufreq_jz4750d_driver = {
+//	.flags		= CPUFREQ_STICKY,
+	.init		= jz4750d_cpufreq_driver_init,
+	.verify		= jz4750d_freq_verify,
+	.target		= jz4750d_freq_target,
+	.get		= jz4750d_freq_get,
+	.name		= "jz4750d",
+};
+
+static int __init jz4750d_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&cpufreq_jz4750d_driver);
+}
+
+static void __exit jz4750d_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&cpufreq_jz4750d_driver);
+}
+
+module_init(jz4750d_cpufreq_init);
+module_exit(jz4750d_cpufreq_exit);
+
+MODULE_AUTHOR("Regen <lhhuang@ingenic.cn>");
+MODULE_DESCRIPTION("cpufreq driver for Jz4750d");
+MODULE_LICENSE("GPL");
diff --git a/arch/mips/jz4750d/dma.c b/arch/mips/jz4750d/dma.c
new file mode 100644
index 0000000..290cc12
--- /dev/null
+++ b/arch/mips/jz4750d/dma.c
@@ -0,0 +1,822 @@
+/*
+ * linux/arch/mips/jz4750d/dma.c
+ *
+ * Support functions for the JZ4750D internal DMA channels.
+ * No-descriptor transfer only.
+ * Descriptor transfer should also call jz_request_dma() to get a free 
+ * channel and call jz_free_dma() to free the channel. And driver should
+ * build the DMA descriptor and setup the DMA channel by itself.
+ *
+ * Copyright (C) 2006 - 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+
+#include <asm/system.h>
+#include <asm/addrspace.h>
+#include <asm/jzsoc.h>
+
+/*
+ * A note on resource allocation:
+ *
+ * All drivers needing DMA channels, should allocate and release them
+ * through the public routines `jz_request_dma()' and `jz_free_dma()'.
+ *
+ * In order to avoid problems, all processes should allocate resources in
+ * the same sequence and release them in the reverse order.
+ *
+ * So, when allocating DMAs and IRQs, first allocate the DMA, then the IRQ.
+ * When releasing them, first release the IRQ, then release the DMA. The
+ * main reason for this order is that, if you are requesting the DMA buffer
+ * done interrupt, you won't know the irq number until the DMA channel is
+ * returned from jz_request_dma().
+ */
+
+struct jz_dma_chan jz_dma_table[MAX_DMA_NUM] = {
+	{dev_id:DMA_ID_BCH_ENC,}, /* DMAC0 channel 0, reserved for BCH */
+	{dev_id:-1,},		/* DMAC0 channel 1 */
+	{dev_id:-1,},		/* DMAC0 channel 2 */
+	{dev_id:-1,},		/* DMAC0 channel 3 */
+	{dev_id:-1,},		/* DMAC1 channel 0 */
+	{dev_id:-1,},		/* DMAC1 channel 1 */
+	{dev_id:-1,},		/* DMAC1 channel 2 */
+	{dev_id:-1,},		/* DMAC1 channel 3 */
+};
+
+// Device FIFO addresses and default DMA modes
+static const struct {
+	unsigned int fifo_addr;
+	unsigned int dma_mode;
+	unsigned int dma_source;
+} dma_dev_table[DMA_ID_MAX] = {
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_EXT}, /* External request with DREQn */
+	{0x18000000, DMA_AUTOINIT, DMAC_DRSR_RS_NAND}, /* NAND request */
+	{CPHYSADDR(BCH_DR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_BCH_ENC},
+	{CPHYSADDR(BCH_DR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_BCH_DEC},
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_AUTO},
+//	{CPHYSADDR(TSSI_FIFO), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_TSSIIN},
+	{CPHYSADDR(UART3_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART3OUT},
+	{CPHYSADDR(UART3_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART3IN},
+	{CPHYSADDR(UART2_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART2OUT},
+	{CPHYSADDR(UART2_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART2IN},
+	{CPHYSADDR(UART1_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART1OUT},
+	{CPHYSADDR(UART1_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART1IN},
+	{CPHYSADDR(UART0_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART0OUT},
+	{CPHYSADDR(UART0_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART0IN},
+	{CPHYSADDR(SSI_DR(0)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_SSI0OUT},
+	{CPHYSADDR(SSI_DR(0)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SSI0IN},
+	{CPHYSADDR(AIC_DR), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_AICOUT},
+	{CPHYSADDR(AIC_DR), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_AICIN},
+	{CPHYSADDR(MSC_TXFIFO(0)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_MSC0OUT},
+	{CPHYSADDR(MSC_RXFIFO(0)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_MSC0IN},
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_TCU},
+	{SADC_TSDAT, DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SADC},/* Touch Screen Data Register */
+	{CPHYSADDR(MSC_TXFIFO(1)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_MSC1OUT}, /* SSC1 TX */
+	{CPHYSADDR(MSC_RXFIFO(1)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_MSC1IN},	/* SSC1 RX */
+	{CPHYSADDR(SSI_DR(1)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_SSI1OUT},
+	{CPHYSADDR(SSI_DR(1)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SSI1IN},
+	{CPHYSADDR(PCM_DP), DMA_16BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_PMOUT},
+	{CPHYSADDR(PCM_DP), DMA_16BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_PMIN},
+	{},
+};
+
+
+int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			 int length, int *eof, void *data)
+{
+	int i, len = 0;
+	struct jz_dma_chan *chan;
+
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if ((chan = get_dma_chan(i)) != NULL) {
+			len += sprintf(buf + len, "%2d: %s\n",
+				       i, chan->dev_str);
+		}
+	}
+
+	if (fpos >= len) {
+		*start = buf;
+		*eof = 1;
+		return 0;
+	}
+	*start = buf + fpos;
+	if ((len -= fpos) > length)
+		return length;
+	*eof = 1;
+	return len;
+}
+
+
+void dump_jz_dma_channel(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return;
+	chan = &jz_dma_table[dmanr];
+
+	printk("DMA%d Registers:\n", dmanr);
+	printk("  DMACR  = 0x%08x\n", REG_DMAC_DMACR(chan->io/HALF_DMA_NUM));
+	printk("  DSAR   = 0x%08x\n", REG_DMAC_DSAR(dmanr));
+	printk("  DTAR   = 0x%08x\n", REG_DMAC_DTAR(dmanr));
+	printk("  DTCR   = 0x%08x\n", REG_DMAC_DTCR(dmanr));
+	printk("  DRSR   = 0x%08x\n", REG_DMAC_DRSR(dmanr));
+	printk("  DCCSR  = 0x%08x\n", REG_DMAC_DCCSR(dmanr));
+	printk("  DCMD  = 0x%08x\n", REG_DMAC_DCMD(dmanr));
+	printk("  DDA  = 0x%08x\n", REG_DMAC_DDA(dmanr));
+	printk("  DMADBR = 0x%08x\n", REG_DMAC_DMADBR(chan->io/HALF_DMA_NUM));
+}
+
+
+/**
+ * jz_request_dma - dynamically allcate an idle DMA channel to return
+ * @dev_id: the specified dma device id or DMA_ID_RAW_SET
+ * @dev_str: the specified dma device string name
+ * @irqhandler: the irq handler, or NULL
+ * @irqflags: the irq handler flags
+ * @irq_dev_id: the irq handler device id for shared irq
+ *
+ * Finds a free channel, and binds the requested device to it.
+ * Returns the allocated channel number, or negative on error.
+ * Requests the DMA done IRQ if irqhandler != NULL.
+ *
+*/
+/*int jz_request_dma(int dev_id, const char *dev_str,
+		   void (*irqhandler)(int, void *, struct pt_regs *),
+		   unsigned long irqflags,
+		   void *irq_dev_id)
+*/
+
+int jz_request_dma(int dev_id, const char *dev_str,
+		   irqreturn_t (*irqhandler)(int, void *),
+		   unsigned long irqflags,
+		   void *irq_dev_id)
+{
+	struct jz_dma_chan *chan;
+	int i, ret;
+
+	if (dev_id < 0 || dev_id >= DMA_ID_MAX)
+		return -EINVAL;
+
+ 	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == MAX_DMA_NUM)  /* no free channel */
+		return -ENODEV;
+
+	/* we got a free channel */
+	chan = &jz_dma_table[i];
+
+	if (irqhandler) {
+		chan->irq = IRQ_DMA_0 + i;	// allocate irq number
+		chan->irq_dev = irq_dev_id;
+		if ((ret = request_irq(chan->irq, irqhandler, irqflags,
+				       dev_str, chan->irq_dev))) {
+			chan->irq = -1;
+			chan->irq_dev = NULL;
+			return ret;
+		}
+	} else {
+		chan->irq = -1;
+		chan->irq_dev = NULL;
+	}
+
+	// fill it in
+	chan->io = i;
+	chan->dev_id = dev_id;
+	chan->dev_str = dev_str;
+	chan->fifo_addr = dma_dev_table[dev_id].fifo_addr;
+	chan->mode = dma_dev_table[dev_id].dma_mode;
+	chan->source = dma_dev_table[dev_id].dma_source;
+
+	if (i < HALF_DMA_NUM)
+		REG_DMAC_DMACKE(0) = 1 << i;
+	else
+		REG_DMAC_DMACKE(1) = 1 << (i - HALF_DMA_NUM);
+
+	return i;
+}
+
+void jz_free_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan) {
+		printk("Trying to free DMA%d\n", dmanr);
+		return;
+	}
+
+	disable_dma(dmanr);
+	if (chan->irq)
+		free_irq(chan->irq, chan->irq_dev);
+
+	chan->irq = -1;
+	chan->irq_dev = NULL;
+	chan->dev_id = -1;
+}
+
+void jz_set_dma_dest_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+	       	return;
+
+	chan->mode &= ~DMAC_DCMD_DWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCMD_DWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_DWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_DWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_src_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+	       	return;
+
+	chan->mode &= ~DMAC_DCMD_SWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCMD_SWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_SWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_SWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_block_size(int dmanr, int nbyte)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	chan->mode &= ~DMAC_DCMD_DS_MASK;
+	switch (nbyte) {
+	case 1:
+		chan->mode |= DMAC_DCMD_DS_8BIT;
+		break;
+	case 2:
+		chan->mode |= DMAC_DCMD_DS_16BIT;
+		break;
+	case 4:
+		chan->mode |= DMAC_DCMD_DS_32BIT;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_DS_16BYTE;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_DS_32BYTE;
+		break;
+	}
+}
+
+unsigned int jz_get_dma_command(int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	return chan->mode;
+}
+
+/**
+ * jz_set_dma_mode - do the raw settings for the specified DMA channel
+ * @dmanr: the specified DMA channel
+ * @mode: dma operate mode, DMA_MODE_READ or DMA_MODE_WRITE
+ * @dma_mode: dma raw mode
+ * @dma_source: dma raw request source
+ * @fifo_addr: dma raw device fifo address
+ *
+ * Ensure call jz_request_dma(DMA_ID_RAW_SET, ...) first, then call
+ * jz_set_dma_mode() rather than set_dma_mode() if you work with
+ * and external request dma device.
+ *
+ * NOTE: Don not dynamically allocate dma channel if one external request
+ *       dma device will occupy this channel.
+*/
+int jz_set_dma_mode(unsigned int dmanr, unsigned int mode,
+		    unsigned int dma_mode, unsigned int dma_source,
+		    unsigned int fifo_addr)
+{
+	int dev_id, i;
+	struct jz_dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return -ENODEV;
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == MAX_DMA_NUM)
+		return -ENODEV;
+
+	chan = &jz_dma_table[dmanr];
+	dev_id = chan->dev_id;
+	if (dev_id > 0) {
+		printk(KERN_DEBUG "%s sets the allocated DMA channel %d!\n",
+		       __FUNCTION__, dmanr);
+		return -ENODEV;
+	}
+
+	/* clone it from the dynamically allocated. */
+	if (i != dmanr) {
+		chan->irq = jz_dma_table[i].irq;
+		chan->irq_dev = jz_dma_table[i].irq_dev;
+		chan->dev_str = jz_dma_table[i].dev_str;
+		jz_dma_table[i].irq = 0;
+		jz_dma_table[i].irq_dev = NULL;
+		jz_dma_table[i].dev_id = -1;
+	}
+	chan->dev_id = DMA_ID_RAW_SET;
+	chan->io = dmanr;
+	chan->fifo_addr = fifo_addr;
+	chan->mode = dma_mode;
+	chan->source = dma_source;
+
+	set_dma_mode(dmanr, dma_mode);
+
+	return dmanr;
+}
+
+void enable_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	REG_DMAC_DCCSR(dmanr) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+	REG_DMAC_DCCSR(dmanr) |= DMAC_DCCSR_NDES; /* No-descriptor transfer */
+	__dmac_enable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_enable_irq(dmanr);
+}
+
+#define DMA_DISABLE_POLL 0x10000
+
+void disable_dma(unsigned int dmanr)
+{
+	int i;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	if (!__dmac_channel_enabled(dmanr))
+		return;
+
+	for (i = 0; i < DMA_DISABLE_POLL; i++)
+		if (__dmac_channel_transmit_end_detected(dmanr))
+			break;
+#if 0
+	if (i == DMA_DISABLE_POLL)
+		printk(KERN_INFO "disable_dma: poll expired!\n");
+#endif
+
+	__dmac_disable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_disable_irq(dmanr);
+}
+
+/* Note: DMA_MODE_MASK is simulated by sw */
+void set_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+	mode &= DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		chan->mode |= DMAC_DCMD_DAI;
+		chan->mode &= ~DMAC_DCMD_SAI;
+	} else if (mode == DMA_MODE_WRITE) {
+		chan->mode |= DMAC_DCMD_SAI;
+		chan->mode &= ~DMAC_DCMD_DAI;
+	} else {
+		printk(KERN_DEBUG "set_dma_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+	}
+	REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+	REG_DMAC_DRSR(chan->io) = chan->source;
+}
+
+void set_dma_addr(unsigned int dmanr, unsigned int phyaddr)
+{
+	unsigned int mode;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	mode = chan->mode & DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		REG_DMAC_DSAR(chan->io) = chan->fifo_addr;
+		REG_DMAC_DTAR(chan->io) = phyaddr;
+	} else if (mode == DMA_MODE_WRITE) {
+		REG_DMAC_DSAR(chan->io) = phyaddr;
+		REG_DMAC_DTAR(chan->io) = chan->fifo_addr;
+	} else
+		printk(KERN_DEBUG "Driver should call set_dma_mode() ahead set_dma_addr()!\n");
+}
+
+void set_dma_count(unsigned int dmanr, unsigned int bytecnt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	unsigned int ds;
+
+	if (!chan)
+	       	return;
+
+       	ds = (chan->mode & DMAC_DCMD_DS_MASK) >> DMAC_DCMD_DS_BIT;
+	REG_DMAC_DTCR(chan->io) = bytecnt / dma_ds[ds]; // transfer count
+}
+
+unsigned int get_dma_residue(unsigned int dmanr)
+{
+	unsigned int count, ds;
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+
+	ds = (chan->mode & DMAC_DCMD_DS_MASK) >> DMAC_DCMD_DS_BIT;
+	count = REG_DMAC_DTCR(chan->io);
+	count = count * dma_ds[ds];
+
+	return count;
+}
+
+void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case AFMT_U8:
+		/* burst mode : 32BIT */
+		break;
+	case AFMT_S16_LE:
+		/* burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			chan->mode = DMA_AIC_32_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_DAI;
+			chan->mode &= ~DMAC_DCMD_SAI;
+		} else if (mode == DMA_MODE_WRITE) {
+			chan->mode = DMA_AIC_32_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			//chan->mode = DMA_AIC_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_SAI;
+			chan->mode &= ~DMAC_DCMD_DAI;
+		} else
+			printk("oss_dma_burst_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+		
+		REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case 8:
+		/* SNDRV_PCM_FORMAT_S8 burst mode : 32BIT */
+		break;
+	case 16:
+		/* SNDRV_PCM_FORMAT_S16_LE burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			chan->mode = DMA_AIC_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_DAI;
+			chan->mode &= ~DMAC_DCMD_SAI;
+		} else if (mode == DMA_MODE_WRITE) {
+			chan->mode = DMA_AIC_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_SAI;
+			chan->mode &= ~DMAC_DCMD_DAI;
+		} else
+			printk("alsa_dma_burst_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+		
+		REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+//#define JZ4750D_DMAC_TEST_ENABLE
+#undef JZ4750D_DMAC_TEST_ENABLE
+
+#ifdef JZ4750D_DMAC_TEST_ENABLE
+
+/*
+ * DMA test: external address <--> external address
+ */
+#define TEST_DMA_SIZE  16*1024
+
+static jz_dma_desc *dma_desc;
+
+static int dma_chan;
+static dma_addr_t dma_desc_phys_addr;
+static unsigned int dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr;
+
+static int dma_check_result(void *src, void *dst, int size)
+{
+	unsigned int addr1, addr2, i, err = 0;
+
+	addr1 = (unsigned int)src;
+	addr2 = (unsigned int)dst;
+
+	for (i = 0; i < size; i += 4) {
+		if (*(volatile unsigned int *)addr1 != *(volatile unsigned int *)addr2) {
+			err++;
+			printk("wrong data at 0x%08x: src 0x%08x  dst 0x%08x\n", addr2, *(volatile unsigned int *)addr1, *(volatile unsigned int *)addr2);
+		}
+		addr1 += 4;
+		addr2 += 4;
+	}
+	printk("check DMA result err=%d\n", err);
+	return err;
+}
+
+static irqreturn_t jz4750d_dma_irq(int irq, void *dev_id)
+{
+	printk("jz4750d_dma_irq %d\n", irq);
+
+
+	if (__dmac_channel_transmit_halt_detected(dma_chan)) {
+		printk("DMA HALT\n");
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		__dmac_channel_clear_transmit_halt(dma_chan);
+	}
+
+	if (__dmac_channel_address_error_detected(dma_chan)) {
+		printk("DMA ADDR ERROR\n");
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		REG_DMAC_DSAR(dma_chan) = 0; /* clear source address register */
+		REG_DMAC_DTAR(dma_chan) = 0; /* clear target address register */
+		__dmac_channel_clear_address_error(dma_chan);
+	}
+
+	if (__dmac_channel_descriptor_invalid_detected(dma_chan)) {
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		printk("DMA DESC INVALID\n");
+		__dmac_channel_clear_descriptor_invalid(dma_chan);
+	}
+
+	if (__dmac_channel_count_terminated_detected(dma_chan)) {
+		printk("DMA CT\n");
+		__dmac_channel_clear_count_terminated(dma_chan);
+	}
+
+	if (__dmac_channel_transmit_end_detected(dma_chan)) {
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		printk("DMA TT\n");
+		__dmac_channel_clear_transmit_end(dma_chan);
+		dump_jz_dma_channel(dma_chan);
+		dma_check_result((void *)dma_src_addr, (void *)dma_dst_addr, TEST_DMA_SIZE);
+	}
+
+	return IRQ_HANDLED;
+}
+
+void dma_nodesc_test(void)
+{
+	unsigned int addr, i;
+
+	printk("dma_nodesc_test\n");
+
+	/* Request DMA channel and setup irq handler */
+	dma_chan = jz_request_dma(DMA_ID_AUTO, "auto", jz4750d_dma_irq,
+				  IRQF_DISABLED, NULL);
+	if (dma_chan < 0) {
+		printk("Setup irq failed\n");
+		return;
+	}
+
+	printk("Requested DMA channel = %d\n", dma_chan);
+
+	/* Allocate DMA buffers */
+	dma_src_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+	dma_dst_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+
+	dma_src_phys_addr = CPHYSADDR(dma_src_addr);
+	dma_dst_phys_addr = CPHYSADDR(dma_dst_addr);
+
+	printk("Buffer addresses: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	       dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr);
+
+	/* Prepare data for source buffer */
+	addr = (unsigned int)dma_src_addr;
+	for (i = 0; i < TEST_DMA_SIZE; i += 4) {
+		*(volatile unsigned int *)addr = addr;
+		addr += 4;
+	}
+	dma_cache_wback((unsigned long)dma_src_addr, TEST_DMA_SIZE);
+
+	/* Init target buffer */
+	memset((void *)dma_dst_addr, 0, TEST_DMA_SIZE);
+	dma_cache_wback((unsigned long)dma_dst_addr, TEST_DMA_SIZE);
+
+	/* Init DMA module */
+	printk("Starting DMA\n");
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = 0;
+	REG_DMAC_DCCSR(dma_chan) = 0;
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_AUTO;
+	REG_DMAC_DSAR(dma_chan) = dma_src_phys_addr;
+	REG_DMAC_DTAR(dma_chan) = dma_dst_phys_addr;
+	REG_DMAC_DTCR(dma_chan) = 512;
+	REG_DMAC_DCMD(dma_chan) = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_TIE;
+	REG_DMAC_DCCSR(dma_chan) = DMAC_DCCSR_NDES | DMAC_DCCSR_EN;
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = DMAC_DMACR_DMAE; /* global DMA enable bit */
+
+	printk("DMA started. IMR=%08x\n", REG_INTC_IMR);
+
+	/* wait a long time, ensure transfer end */
+	printk("wait 3s...\n");
+	mdelay(3000);		/* wait 3s */
+
+	REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+	/* free buffers */
+	printk("free DMA buffers\n");
+	free_pages(dma_src_addr, 2);
+	free_pages(dma_dst_addr, 2);
+
+	if (dma_desc)
+		free_pages((unsigned int)dma_desc, 0);
+
+	/* free dma */
+	jz_free_dma(dma_chan);
+}
+
+void dma_desc_test(void)
+{
+	unsigned int next, addr, i;
+	static jz_dma_desc *desc;
+
+	printk("dma_desc_test\n");
+
+	/* Request DMA channel and setup irq handler */
+	dma_chan = jz_request_dma(DMA_ID_AUTO, "auto", jz4750d_dma_irq,
+				  IRQF_DISABLED, NULL);
+	if (dma_chan < 0) {
+		printk("Setup irq failed\n");
+		return;
+	}
+
+	printk("Requested DMA channel = %d\n", dma_chan);
+
+	/* Allocate DMA buffers */
+	dma_src_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+	dma_dst_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+
+	dma_src_phys_addr = CPHYSADDR(dma_src_addr);
+	dma_dst_phys_addr = CPHYSADDR(dma_dst_addr);
+
+	printk("Buffer addresses: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	       dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr);
+
+	/* Prepare data for source buffer */
+	addr = (unsigned int)dma_src_addr;
+	for (i = 0; i < TEST_DMA_SIZE; i += 4) {
+		*(volatile unsigned int *)addr = addr;
+		addr += 4;
+	}
+	dma_cache_wback((unsigned long)dma_src_addr, TEST_DMA_SIZE);
+
+	/* Init target buffer */
+	memset((void *)dma_dst_addr, 0, TEST_DMA_SIZE);
+	dma_cache_wback((unsigned long)dma_dst_addr, TEST_DMA_SIZE);
+
+	/* Allocate DMA descriptors */
+	dma_desc = (jz_dma_desc *)__get_free_pages(GFP_KERNEL, 0);
+	dma_desc_phys_addr = CPHYSADDR((unsigned long)dma_desc);
+
+	printk("DMA descriptor address: 0x%08x  0x%08x\n", (u32)dma_desc, dma_desc_phys_addr);
+
+	/* Setup DMA descriptors */
+	desc = dma_desc;
+	next = (dma_desc_phys_addr + (sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr;    /* DMA source address */
+	desc->dtadr = dma_dst_phys_addr;    /* DMA target address */
+	desc->ddadr = (next << 24) + 128;    /* size: 128*32 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 2*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr + 4096;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 4096;	/* DMA target address */
+	desc->ddadr = (next << 24) + 256;    /* size: 256*16 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 3*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr + 8192;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 8192;	/* DMA target address */
+	desc->ddadr = (next << 24) + 256;    /* size: 256*16 bytes = 4096 bytes */
+	
+	desc++;
+	next = (dma_desc_phys_addr + 4*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BIT | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE;
+	desc->dsadr = dma_src_phys_addr + 12*1024;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 12*1024;	/* DMA target address */
+	desc->ddadr = (next << 24) + 1024;    /* size: 1024*4 bytes = 4096 bytes */
+
+	dma_cache_wback((unsigned long)dma_desc, 4*(sizeof(jz_dma_desc)));
+
+	/* Setup DMA descriptor address */
+	REG_DMAC_DDA(dma_chan) = dma_desc_phys_addr;
+
+	/* Setup request source */
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_AUTO;
+
+	/* Setup DMA channel control/status register */
+	REG_DMAC_DCCSR(dma_chan) = DMAC_DCCSR_EN;	/* descriptor transfer, clear status, start channel */
+
+	/* Enable DMA */
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = DMAC_DMACR_DMAE;
+
+	/* DMA doorbell set -- start DMA now ... */
+	REG_DMAC_DMADBSR(dma_chan/HALF_DMA_NUM) = 1 << dma_chan;
+
+	printk("DMA started. IMR=%08x\n", REG_INTC_IMR);
+	/* wait a long time, ensure transfer end */
+	printk("wait 3s...\n");
+	mdelay(3000);		/* wait 3s */
+
+	REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+	/* free buffers */
+	printk("free DMA buffers\n");
+	free_pages(dma_src_addr, 2);
+	free_pages(dma_dst_addr, 2);
+
+	if (dma_desc)
+		free_pages((unsigned int)dma_desc, 0);
+
+	/* free dma */
+	jz_free_dma(dma_chan);
+}
+
+#endif
+
+//EXPORT_SYMBOL_NOVERS(jz_dma_table);
+EXPORT_SYMBOL(jz_dma_table);
+EXPORT_SYMBOL(jz_request_dma);
+EXPORT_SYMBOL(jz_free_dma);
+EXPORT_SYMBOL(jz_set_dma_src_width);
+EXPORT_SYMBOL(jz_set_dma_dest_width);
+EXPORT_SYMBOL(jz_set_dma_block_size);
+EXPORT_SYMBOL(jz_set_dma_mode);
+EXPORT_SYMBOL(set_dma_mode);
+EXPORT_SYMBOL(jz_set_oss_dma);
+EXPORT_SYMBOL(jz_set_alsa_dma);
+EXPORT_SYMBOL(set_dma_addr);
+EXPORT_SYMBOL(set_dma_count);
+EXPORT_SYMBOL(get_dma_residue);
+EXPORT_SYMBOL(enable_dma);
+EXPORT_SYMBOL(disable_dma);
+EXPORT_SYMBOL(dump_jz_dma_channel);
diff --git a/arch/mips/jz4750d/i2c.c b/arch/mips/jz4750d/i2c.c
new file mode 100644
index 0000000..8ac7ab0
--- /dev/null
+++ b/arch/mips/jz4750d/i2c.c
@@ -0,0 +1,388 @@
+/*
+ * linux/arch/mips/jz4750/i2c.c
+ *
+ * JZ4750 Simple I2C Driver.
+ *
+ * Copyright (c) 2005-2010  Ingenic Semiconductor Inc.
+ * Author: River <zwang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/jzsoc.h>
+
+#define I2C_BUS_TIMING_START_HOLD	1	/* us */
+#define I2C_BUS_TIMING_STOP_HOLD	10	/* us */
+
+#define I2C_CTRL_WAIT_ENABLE		1	/* us */
+#define I2C_CTRL_WAIT_DISABLE		1	/* us */
+
+#define PFX "I_I2C"
+
+#define D(fmt, args...) \
+//	printk(KERN_ERR PFX": %s(): LINE: %d - "fmt"\n", __func__, __LINE__, ##args)
+
+#define E(fmt, args...) \
+	printk(KERN_ERR PFX": %s(): LINE: %d - "fmt"\n", __func__, __LINE__, ##args)
+
+/* Controller. */
+struct i2c_ctrl {
+	spinlock_t lock;
+
+	unsigned long clk;
+};
+
+static struct i2c_ctrl g_i2c_ctrl;
+
+static inline void i2c_ctrl_enable(void)
+{
+	D("Called.");
+
+	__i2c_enable();
+	
+	udelay(I2C_CTRL_WAIT_ENABLE);
+	
+	return;
+}
+	
+static inline void i2c_ctrl_disable(void)
+{
+	D("Called.");
+
+	__i2c_disable();
+
+	udelay(I2C_CTRL_WAIT_DISABLE);
+	
+	return;
+}
+
+static inline void i2c_ctrl_set_clk(unsigned long clk)
+{
+	struct i2c_ctrl *ctrl = &g_i2c_ctrl;
+	
+	D("Called.");
+
+	if (ctrl->clk != clk) {
+		D("Set clock.");
+
+		__i2c_set_clk(jz_clocks.extalclk, clk);
+		ctrl->clk = clk;
+
+		mdelay(1);
+	}
+
+	return;
+}
+
+/*
+ * I2C bus protocol basic routines
+ */
+static inline int __i2c_put_data(unsigned char data, unsigned long timeout)
+{
+	unsigned long t; 
+	
+	__i2c_write(data);
+	__i2c_set_drf();
+	
+	t = timeout;
+	while (__i2c_check_drf() != 0 && t)
+		t--;
+
+	if (!t) {
+		E("__i2c_check_drf() timeout, Data: 0x%x. timeout: %lu.", data, timeout);
+		return -ETIMEDOUT;
+	}
+
+	while (!__i2c_transmit_ended() && t)
+		t--;
+
+	if (!t) {
+		E("__i2c_transmit_ended() timeout, Data: 0x%x, timeout: %lu.", data, timeout);
+		return -ETIMEDOUT;
+	}
+
+	t = timeout;
+	while (!__i2c_received_ack() && t)
+		t--;
+
+	if (!t) {
+		E("__i2c_received_ack() timeout, Data: 0x%x, timeout: %lu.", data, timeout);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static inline int __i2c_get_data(unsigned char *data, int ack, unsigned long timeout)
+{
+	unsigned long t;
+
+	ack ? __i2c_send_ack() : __i2c_send_nack();
+	
+	t = timeout;
+	while (__i2c_check_drf() == 0 && t)
+		t--;
+
+	if (!t) {
+		E("__i2c_check_drf() timeout. timeout: %lu", timeout);
+		return -ETIMEDOUT;
+	}
+
+	*data = __i2c_read();
+
+	__i2c_clear_drf();
+
+	return 0;
+}
+
+static inline int put_data(struct i_i2c_dev *dev, unsigned char data)
+{
+	return	__i2c_put_data(data, dev->timing->timeout);
+}
+
+static inline int get_data(struct i_i2c_dev *dev, unsigned char *data, int ack)
+{
+	return	__i2c_get_data(data, ack, dev->timing->timeout);
+}
+
+static inline void i2c_start(void)
+{
+	__i2c_send_start();
+	
+	udelay(I2C_BUS_TIMING_START_HOLD);
+
+	return;
+}
+
+static inline void i2c_stop(void)
+{
+	__i2c_send_stop();
+	
+	udelay(I2C_BUS_TIMING_STOP_HOLD);	
+
+	return;
+}
+
+static inline int i2c_start_and_send_address(struct i_i2c_dev *dev, off_t off, int dir)
+{
+	unsigned int ra = ((dev->address << 1) & 0xff) | 0x1;
+	unsigned int wa = ((dev->address << 1) & 0xff);
+	
+	int rv;
+
+	i2c_start();
+
+	if (put_data(dev, wa) < 0) {
+		E("Failed to send write address.");
+		rv = -ENODEV;
+		goto err;
+	}
+
+	if (dev->cap & I_I2C_CAP_16BIT_OFFSET_MSB) {
+		if (put_data(dev, (off >> 8) & 0xFF) < 0) {
+			E("Failed to send off >> 8 MSB.");
+			rv = -EINVAL;
+			goto err;
+		}
+	}
+
+	if (put_data(dev, (off & 0xFF)) < 0) {
+		E("Failed to send off.");
+		rv = -EINVAL;
+		goto err;
+	}
+
+	if (dev->cap & I_I2C_CAP_16BIT_OFFSET_LSB) {
+		if (put_data(dev, (off >> 8) & 0xFF) < 0) {
+			E("Failed to send off >> 8 LSB.");
+			rv = -EINVAL;
+			goto err;
+		}
+	}
+
+	if (dir == I_I2C_IO_DIR_READ) {
+		if (dev->flags & I_I2C_FLAG_STOP_BEFORE_RESTART) 
+			i2c_stop();
+
+		i2c_start();
+
+		if (put_data(dev, ra) < 0) {
+			E("Failed to send read address.");
+			rv = -ENODEV;
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	i2c_stop();
+	return rv;
+}
+
+static inline int i2c_read_data(struct i_i2c_dev *dev, char *buf, size_t count)
+{
+	int i, rv;
+	int ack = 1;
+	
+//	D("buf: 0x%p, count: %d.", buf, count);
+
+	for (i = 0; i < count; i++) {
+		if (i == count - 1) {
+//			D("Nack.");
+			ack = 0;
+		}
+
+		rv = get_data(dev, buf + i, ack);
+		if (rv) {
+			E("get_data() failed: rv: %d i: %d.", rv, i);
+			return rv;
+		}
+	}
+	
+	return 0;
+}
+
+static inline int i2c_write_data(struct i_i2c_dev *dev, char *buf, size_t count)
+{
+	unsigned long i;
+	int rv;
+	
+//	D("buf: 0x%p, count: %d.", buf, count);
+
+	for (i = 0; i < count; i++) {
+		rv = put_data(dev, buf[i]);
+		if (rv) {
+			E("put_data() failed: %d.\n", rv);
+			return rv;
+		}
+	}
+	
+	return 0;
+}
+
+static int do_i2c(struct i_i2c_dev *dev, off_t off, char *buf, size_t count, int dir)
+{
+	struct i2c_ctrl *ctrl = &g_i2c_ctrl;
+	struct i_i2c_timing *timing = dev->timing;
+
+	unsigned long flags;
+	unsigned long io_size, size;
+
+	unsigned long i;
+	int rv = 0;
+
+	spin_lock_irqsave(&ctrl->lock, flags);
+	
+	i2c_ctrl_enable();
+	i2c_ctrl_set_clk(timing->clk);
+
+	io_size = dir ? dev->write_size : dev->read_size;
+	size = count < io_size ? count : io_size;
+
+	for (i = 0; i < count; i += io_size) {
+		rv = i2c_start_and_send_address(dev, off + i, dir);
+		if (rv) {
+			E("i2c_start_and_send_address() failed: %d, i: %lu.", rv, i);
+			i2c_stop();
+			goto err;
+		}
+		
+//		D("Pass send address.");
+
+		if (!dir)
+			rv = i2c_read_data(dev, buf + i, size);
+		else
+			rv = i2c_write_data(dev, buf + i, size);
+
+//		D("Pass rw data.");
+
+		if (rv) {
+			E("i2c_read/write_data() failed: %d, i: %lu.", rv, i);
+			i2c_stop();
+			goto err;
+		}
+		
+		i2c_stop();
+		
+		if (dir && timing->t_wr) 
+			mdelay(timing->t_wr);
+	}
+	
+err:
+	i2c_ctrl_disable();
+
+	spin_unlock_irqrestore(&ctrl->lock, flags);
+
+	return rv;
+}
+
+/*
+ * I2C interface
+ */
+int i_i2c_read_dev(struct i_i2c_dev *dev, off_t off, void *buf, size_t count)
+{
+	D("off: %d, buf: 0x%p, count: %d.", off, buf, count);
+
+	return do_i2c(dev, off, buf, count, 0);
+}
+EXPORT_SYMBOL(i_i2c_read_dev);
+
+int i_i2c_write_dev(struct i_i2c_dev *dev, off_t off, void *buf, size_t count)
+{
+	D("off: %d, buf: 0x%p, count: %d.", off, buf, count);
+
+	return do_i2c(dev, off, buf, count, 1);
+}
+EXPORT_SYMBOL(i_i2c_write_dev);
+
+int i_i2c_init_dev(struct i_i2c_dev *dev)
+{
+	struct i_i2c_timing *timing = dev->timing;
+
+	if (!timing) {
+		printk(KERN_ERR PFX": %s(): Please setup the timing of I2C device: 0x%p.\n", __func__, dev);
+		return -EINVAL;
+	}	
+	
+	if (!timing->timeout)
+		timing->timeout = (100 * 1000);
+	
+	if (!timing->clk)
+		timing->clk = (100 * 1000); /* default 100 KHz */
+	
+	if (!(dev->cap & I_I2C_CAP_SEQ_READ))  
+		dev->read_size = 1;
+	
+	if (!(dev->cap & I_I2C_CAP_SEQ_WRITE))
+		dev->write_size = 1;
+
+	return 0;	
+}
+EXPORT_SYMBOL(i_i2c_init_dev);
+
+static int __init i_i2c_init(void)
+{
+	struct i2c_ctrl *ctrl = &g_i2c_ctrl;
+
+	spin_lock_init(&ctrl->lock);
+	
+	__gpio_as_i2c();
+
+	i2c_ctrl_set_clk(100 * 1000);
+
+	printk(KERN_INFO JZ_SOC_NAME": Simple I2C Driver Registered.\n");
+
+	return 0;
+}
+
+module_init(i_i2c_init);
diff --git a/arch/mips/jz4750d/irq.c b/arch/mips/jz4750d/irq.c
new file mode 100644
index 0000000..081170d
--- /dev/null
+++ b/arch/mips/jz4750d/irq.c
@@ -0,0 +1,299 @@
+/*
+ * linux/arch/mips/jz4750d/irq.c
+ *
+ * JZ4750D interrupt routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+/*
+ * INTC irq type
+ */
+
+static void enable_intc_irq(unsigned int irq)
+{
+	__intc_unmask_irq(irq);
+}
+
+static void disable_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+}
+
+static void mask_and_ack_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+	__intc_ack_irq(irq);
+}
+
+static void end_intc_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_intc_irq(irq);
+	}
+}
+
+static unsigned int startup_intc_irq(unsigned int irq)
+{
+	enable_intc_irq(irq);
+	return 0;
+}
+
+static void shutdown_intc_irq(unsigned int irq)
+{
+	disable_intc_irq(irq);
+}
+
+static struct irq_chip intc_irq_type = {
+	.typename = "INTC",
+	.startup = startup_intc_irq,
+	.shutdown = shutdown_intc_irq,
+	.unmask = enable_intc_irq,
+	.mask = disable_intc_irq,
+	.ack = mask_and_ack_intc_irq,
+	.end = end_intc_irq,
+};
+
+/*
+ * GPIO irq type
+ */
+
+static void enable_gpio_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if (irq < (IRQ_GPIO_0 + 32)) {
+		intc_irq = IRQ_GPIO0;
+	}
+	else if (irq < (IRQ_GPIO_0 + 64)) {
+		intc_irq = IRQ_GPIO1;
+	}
+	else if (irq < (IRQ_GPIO_0 + 96)) {
+		intc_irq = IRQ_GPIO2;
+	}
+	else if (irq < (IRQ_GPIO_0 + 128)) {
+		intc_irq = IRQ_GPIO3;
+	}
+	else if (irq < (IRQ_GPIO_0 + 160)) {
+		intc_irq = IRQ_GPIO4;
+	}
+	else {
+		intc_irq = IRQ_GPIO5;
+	}
+
+	enable_intc_irq(intc_irq);
+	__gpio_unmask_irq(irq - IRQ_GPIO_0);
+}
+
+static void disable_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+}
+
+static void mask_and_ack_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+	__gpio_ack_irq(irq - IRQ_GPIO_0);
+}
+
+static void end_gpio_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_gpio_irq(irq);
+	}
+}
+
+static unsigned int startup_gpio_irq(unsigned int irq)
+{
+	enable_gpio_irq(irq);
+	return 0;
+}
+
+static void shutdown_gpio_irq(unsigned int irq)
+{
+	disable_gpio_irq(irq);
+}
+
+static struct irq_chip gpio_irq_type = {
+	.typename = "GPIO",
+	.startup = startup_gpio_irq,
+	.shutdown = shutdown_gpio_irq,
+	.unmask = enable_gpio_irq,
+	.mask = disable_gpio_irq,
+	.ack = mask_and_ack_gpio_irq,
+	.end = end_gpio_irq,
+};
+
+/*
+ * DMA irq type
+ */
+
+static void enable_dma_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if ( irq < (IRQ_DMA_0 + HALF_DMA_NUM) ) 	/* DMAC Group 0 irq */
+		intc_irq = IRQ_DMAC0;
+	else if ( irq < (IRQ_DMA_0 + MAX_DMA_NUM) ) 	/* DMAC Group 1 irq */
+		intc_irq = IRQ_DMAC1;
+	else {
+		printk("%s, unexpected dma irq #%d\n", __FILE__, irq);
+		return;
+	}
+	__intc_unmask_irq(intc_irq);
+	__dmac_channel_enable_irq(irq - IRQ_DMA_0);
+}
+
+static void disable_dma_irq(unsigned int irq)
+{
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void mask_and_ack_dma_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if ( irq < (IRQ_DMA_0 + HALF_DMA_NUM) ) 	/* DMAC Group 0 irq */
+		intc_irq = IRQ_DMAC0;
+	else if ( irq < (IRQ_DMA_0 + MAX_DMA_NUM) ) 	/* DMAC Group 1 irq */
+		intc_irq = IRQ_DMAC1;
+	else {
+		printk("%s, unexpected dma irq #%d\n", __FILE__, irq);
+		return ;
+	}
+	__intc_ack_irq(intc_irq);
+	__dmac_channel_ack_irq(irq-IRQ_DMA_0); /* needed?? add 20080506, Wolfgang */
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void end_dma_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_dma_irq(irq);
+	}
+}
+
+static unsigned int startup_dma_irq(unsigned int irq)
+{
+	enable_dma_irq(irq);
+	return 0;
+}
+
+static void shutdown_dma_irq(unsigned int irq)
+{
+	disable_dma_irq(irq);
+}
+
+static struct irq_chip dma_irq_type = {
+	.typename = "DMA",
+	.startup = startup_dma_irq,
+	.shutdown = shutdown_dma_irq,
+	.unmask = enable_dma_irq,
+	.mask = disable_dma_irq,
+	.ack = mask_and_ack_dma_irq,
+	.end = end_dma_irq,
+};
+
+//----------------------------------------------------------------------
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	clear_c0_status(0xff04); /* clear ERL */
+	set_c0_status(0x0400);   /* set IP2 */
+
+	/* Set up INTC irq
+	 */
+	for (i = 0; i < 32; i++) {
+		disable_intc_irq(i);
+		set_irq_chip_and_handler(i, &intc_irq_type, handle_level_irq);
+	}
+	
+	/* Set up DMAC irq
+	 */
+	for (i = 0; i < NUM_DMA; i++) {
+		disable_dma_irq(IRQ_DMA_0 + i);
+		set_irq_chip_and_handler(IRQ_DMA_0 + i, &dma_irq_type, handle_level_irq);
+	}
+
+	/* Set up GPIO irq
+	 */
+	for (i = 0; i < NUM_GPIO; i++) {
+		disable_gpio_irq(IRQ_GPIO_0 + i);
+		set_irq_chip_and_handler(IRQ_GPIO_0 + i, &gpio_irq_type, handle_level_irq);
+	}
+}
+
+static int plat_real_irq(int irq)
+{
+	switch (irq) {
+	case IRQ_GPIO0:
+		irq = __gpio_group_irq(0) + IRQ_GPIO_0;
+		break;
+	case IRQ_GPIO1:
+		irq = __gpio_group_irq(1) + IRQ_GPIO_0 + 32;
+		break;
+	case IRQ_GPIO2:
+		irq = __gpio_group_irq(2) + IRQ_GPIO_0 + 64;
+		break;
+	case IRQ_GPIO3:
+		irq = __gpio_group_irq(3) + IRQ_GPIO_0 + 96;
+		break;
+	case IRQ_GPIO4:
+		irq = __gpio_group_irq(4) + IRQ_GPIO_0 + 128;
+		break;
+	case IRQ_GPIO5:
+		irq = __gpio_group_irq(5) + IRQ_GPIO_0 + 160;
+		break;
+	case IRQ_DMAC0:
+	case IRQ_DMAC1:
+		irq = __dmac_get_irq() + IRQ_DMA_0;
+		break;
+	}
+
+	return irq;
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	int irq = 0;
+	static unsigned long intc_ipr = 0;
+
+	intc_ipr |= REG_INTC_IPR;
+
+	if (!intc_ipr)	return;
+
+	irq = ffs(intc_ipr) - 1;
+	intc_ipr &= ~(1<<irq);
+
+	irq = plat_real_irq(irq);
+	do_IRQ(irq);
+}
diff --git a/arch/mips/jz4750d/platform.c b/arch/mips/jz4750d/platform.c
new file mode 100644
index 0000000..5a13a54
--- /dev/null
+++ b/arch/mips/jz4750d/platform.c
@@ -0,0 +1,348 @@
+/*
+ * Platform device support for Jz4740 SoC.
+ *
+ * Copyright 2007, <yliu@ingenic.cn>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+
+#include <asm/jzsoc.h>
+#include <linux/spi/spi.h>
+
+extern void __init board_msc_init(void);
+
+int __init jz_add_msc_devices(unsigned int controller, struct jz_mmc_platform_data *plat);
+
+#if 0
+/* OHCI (USB full speed host controller) */
+static struct resource jz_usb_ohci_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UHC_BASE), // phys addr for ioremap
+		.end		= CPHYSADDR(UHC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UHC,
+		.end		= IRQ_UHC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_ohci_device = {
+	.name		= "jz-ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_ohci_resources),
+	.resource	= jz_usb_ohci_resources,
+};
+#endif
+/*** LCD controller ***/
+static struct resource jz_lcd_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(LCD_BASE),
+		.end            = CPHYSADDR(LCD_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_LCD,
+		.end            = IRQ_LCD,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_lcd_dmamask = ~(u32)0;
+
+static struct platform_device jz_lcd_device = {
+	.name           = "jz-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &jz_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_lcd_resources),
+	.resource       = jz_lcd_resources,
+};
+
+/* UDC (USB gadget controller) */
+static struct resource jz_usb_gdt_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UDC_BASE),
+		.end		= CPHYSADDR(UDC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UDC,
+		.end		= IRQ_UDC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 udc_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_gdt_device = {
+	.name		= "jz-udc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &udc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_gdt_resources),
+	.resource	= jz_usb_gdt_resources,
+};
+
+/** MMC/SD controller **/
+#if 0
+/** MMC/SD controller **/
+static struct resource jz_mmc_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(MSC_BASE),
+		.end            = CPHYSADDR(MSC_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_MSC0,
+		.end            = IRQ_MSC0,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_mmc_dmamask =  ~(u32)0;
+
+static struct platform_device jz_mmc_device = {
+	.name = "jz-mmc",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &jz_mmc_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_mmc_resources),
+	.resource       = jz_mmc_resources,
+};
+
+#else
+/** MMC/SD controller MSC0**/
+static struct resource jz_msc0_resources[] = {
+	{
+		.start          = CPHYSADDR(MSC_BASE),
+		.end            = CPHYSADDR(MSC_BASE) + 0x1000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	{
+		.start          = IRQ_MSC0,
+		.end            = IRQ_MSC0,
+		.flags          = IORESOURCE_IRQ,
+	},
+	{
+		.start          = DMA_ID_MSC0_RX,
+		.end            = DMA_ID_MSC0_TX,
+		.flags          = IORESOURCE_DMA,
+	},
+};
+
+static u64 jz_msc0_dmamask =  ~(u32)0;
+
+static struct platform_device jz_msc0_device = {
+	.name = "jz-msc",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &jz_msc0_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_msc0_resources),
+	.resource       = jz_msc0_resources,
+};
+
+/** MMC/SD controller MSC1**/
+static struct resource jz_msc1_resources[] = {
+	{
+		.start          = CPHYSADDR(MSC_BASE) + 0x1000,
+		.end            = CPHYSADDR(MSC_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	{
+		.start          = IRQ_MSC1,
+		.end            = IRQ_MSC1,
+		.flags          = IORESOURCE_IRQ,
+	},
+	{
+		.start          = DMA_ID_MSC1_RX,
+		.end            = DMA_ID_MSC1_TX,
+		.flags          = IORESOURCE_DMA,
+	},
+
+};
+
+static u64 jz_msc1_dmamask =  ~(u32)0;
+
+static struct platform_device jz_msc1_device = {
+	.name = "jz-msc",
+	.id = 1,
+	.dev = {
+		.dma_mask               = &jz_msc1_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_msc1_resources),
+	.resource       = jz_msc1_resources,
+};
+
+static struct platform_device *jz_msc_devices[] __initdata = {
+	&jz_msc0_device,
+	&jz_msc1_device,
+};
+
+int __init jz_add_msc_devices(unsigned int controller, struct jz_mmc_platform_data *plat)
+{
+	struct platform_device	*pdev;
+
+	if (controller < 0 || controller > 1)
+		return -EINVAL;
+
+	pdev = jz_msc_devices[controller];
+
+	pdev->dev.platform_data = plat;
+
+	return platform_device_register(pdev);
+}
+#endif
+
+/** I2C controller **/
+static struct resource jz_i2c_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(I2C_BASE),
+		.end            = CPHYSADDR(I2C_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+#if 0
+	[1] = {
+		.start          = IRQ_I2C,
+		.end            = IRQ_I2C,
+		.flags          = IORESOURCE_IRQ,
+	}
+#endif
+};
+
+static u64 jz_i2c_dmamask =  ~(u32)0;
+static struct platform_device jz_i2c_device = {
+	.name = "jz_i2c",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &jz_i2c_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_i2c_resources),
+	.resource       = jz_i2c_resources,
+};
+
+#define __BUILD_JZ_SPI_PLATFORM_DEV(ssi_id) 	\
+											\
+struct jz47xx_spi_info spi##ssi_id##_info_cfg = {		\
+	.chnl = ssi_id,										\
+	.bus_num = ssi_id,									\
+	.is_pllclk = 1,										\
+	.num_chipselect = MAX_SPI_CHIPSELECT_NUM,		\
+};					\
+static struct resource jz_spi##ssi_id##_resource[] = {	\
+	[0] = {												\
+		.start          = CPHYSADDR(SSI_BASE) + 0x1000*(ssi_id) ,			\
+		.end            = CPHYSADDR(SSI_BASE) + 0x1000*((ssi_id)+1) - 1,	\
+		.flags 			= IORESOURCE_MEM,				\
+	},									\
+	[1] = {								\
+		.start = IRQ_SSI,		\
+		.end   = IRQ_SSI,		\
+		.flags = IORESOURCE_IRQ,		\
+	},									\
+};	\
+static u64 jz_spi##ssi_id##_dmamask =  ~(u32)0;			\
+struct platform_device jz_spi##ssi_id##_device = {		\
+	.name		  = "jz47xx-spi",						\
+	.id		  = ssi_id,									\
+	.num_resources	  = ARRAY_SIZE(jz_spi##ssi_id##_resource),			\
+	.resource	  = jz_spi##ssi_id##_resource,							\
+        .dev              = {											\
+                .dma_mask = &jz_spi##ssi_id##_dmamask,					\
+                .coherent_dma_mask = 0xffffffffUL,						\
+                .platform_data = & spi##ssi_id##_info_cfg,				\
+        },																\
+};
+
+
+#ifdef CONFIG_JZ_SPI0
+__BUILD_JZ_SPI_PLATFORM_DEV(0)
+#endif
+#if 0
+#ifdef CONFIG_JZ_SPI1
+__BUILD_JZ_SPI_PLATFORM_DEV(1)
+#endif
+#endif
+
+static struct platform_device *jz_spi_devices[] __initdata = {
+#ifdef CONFIG_JZ_SPI0
+	&jz_spi0_device,
+#else
+	NULL,
+#endif
+#if 0
+#ifdef CONFIG_JZ_SPI1
+	&jz_spi1_device,
+#else
+	NULL,
+#endif
+#endif
+};
+
+int __init jz_add_spi_devices(unsigned int host_id, struct spi_board_info *board_info,int board_num)
+{
+
+	struct platform_device	*pdev;
+	struct jz47xx_spi_info	*host_info;
+	
+	if (JZ_SPI_ID_INVALID(host_id))
+		return -EINVAL;
+	pdev = jz_spi_devices[host_id];
+	if (NULL == pdev)
+		return -EINVAL;
+
+	host_info = (struct jz47xx_spi_info *)pdev->dev.platform_data;
+	host_info->board_info = board_info;
+	host_info->board_size = board_num;
+#ifndef CONFIG_JZ_SPI_BOARD_INFO_REGISTER
+	spi_register_board_info(board_info,board_num);	
+#endif
+
+	return platform_device_register(pdev);
+}
+
+
+/* All */
+static struct platform_device *jz_platform_devices[] __initdata = {
+//	&jz_usb_ohci_device,
+	&jz_lcd_device,
+	&jz_usb_gdt_device,
+	//&jz_mmc_device,
+	&jz_i2c_device,
+};
+
+extern void __init board_spi_init(void);
+static int __init jz_platform_init(void)
+{
+	board_msc_init();
+	board_spi_init();
+	return platform_add_devices(jz_platform_devices, ARRAY_SIZE(jz_platform_devices));
+}
+
+arch_initcall(jz_platform_init);
diff --git a/arch/mips/jz4750d/pm.c b/arch/mips/jz4750d/pm.c
new file mode 100644
index 0000000..8fc39a3
--- /dev/null
+++ b/arch/mips/jz4750d/pm.c
@@ -0,0 +1,384 @@
+/*
+ * linux/arch/mips/jz4750d/common/pm.c
+ * 
+ * JZ4750D Power Management Routines
+ * 
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ * 
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ * 
+ */
+
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h> 
+#include <linux/sysctl.h>
+#include <linux/suspend.h>
+
+#include <asm/cacheops.h>
+#include <asm/jzsoc.h>
+
+#undef DEBUG
+//#define DEBUG 
+#ifdef DEBUG
+#define dprintk(x...)	printk(x)
+#else
+#define dprintk(x...)
+#endif
+
+#define GPIO_PORT_NUM   6
+
+/* 
+ * __gpio_as_sleep set all pins to pull-disable, and set all pins as input
+ * except sdram and the pins which can be used as CS1_N to CS4_N for chip select. 
+ */
+#define __gpio_as_sleep()	              \
+do {	                                      \
+	REG_GPIO_PXFUNC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXSELC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXDIRC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXPES(1)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(2) = ~0x01e00000;     \
+	REG_GPIO_PXSELC(2) = ~0x01e00000;     \
+	REG_GPIO_PXDIRC(2) = ~0x01e00000;     \
+	REG_GPIO_PXPES(2)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(3) =  0xffffffff;     \
+	REG_GPIO_PXSELC(3) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(3) =  0xffffffff;     \
+	REG_GPIO_PXPES(3)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(4) =  0xffffffff;     \
+	REG_GPIO_PXSELC(4) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(4) =  0xffffffff;     \
+	REG_GPIO_PXPES(4)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(5) =  0xffffffff;     \
+	REG_GPIO_PXSELC(5) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(5) =  0xffffffff;     \
+	REG_GPIO_PXPES(5)  =  0xffffffff;     \
+} while (0)
+
+static int jz_pm_do_hibernate(void)
+{
+	printk("Put CPU into hibernate mode.\n");
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/* 
+	 * RTC Wakeup or 1Hz interrupt can be enabled or disabled 
+	 * through  RTC driver's ioctl (linux/driver/char/rtc_jz.c).
+	 */
+
+	/* Set minimum wakeup_n pin low-level assertion time for wakeup: 100ms */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HWFCR = (100 << RTC_HWFCR_BIT);
+
+	/* Set reset pin low-level assertion time after wakeup: must  > 60ms */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HRCR = (60 << RTC_HRCR_BIT); /* 60 ms */
+
+	/* Scratch pad register to be reserved */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HSPR = 0x12345678;
+
+	/* clear wakeup status register */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HWRSR = 0x0;
+
+	/* Put CPU to power down mode */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HCR = RTC_HCR_PD;
+
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	while(1);
+
+	/* We can't get here */
+	return 0;
+}
+
+/* NOTES:
+ * 1: Pins that are floated (NC) should be set as input and pull-enable.
+ * 2: Pins that are pull-up or pull-down by outside should be set as input 
+ *    and pull-disable.
+ * 3: Pins that are connected to a chip except sdram and nand flash 
+ *    should be set as input and pull-disable, too.
+ */
+static void jz_board_do_sleep(unsigned long *ptr)
+{
+	unsigned char i;
+        
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("run dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",        \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+
+        /* Save GPIO registers */
+	for(i = 1; i < GPIO_PORT_NUM; i++) {
+		*ptr++ = REG_GPIO_PXFUN(i);
+		*ptr++ = REG_GPIO_PXSEL(i);
+		*ptr++ = REG_GPIO_PXDIR(i);
+		*ptr++ = REG_GPIO_PXPE(i);
+		*ptr++ = REG_GPIO_PXIM(i);
+		*ptr++ = REG_GPIO_PXDAT(i);
+		*ptr++ = REG_GPIO_PXTRG(i);
+	}
+
+        /*
+         * Set all pins to pull-disable, and set all pins as input except 
+         * sdram and the pins which can be used as CS1_N to CS4_N for chip select. 
+         */
+        __gpio_as_sleep();
+
+        /*
+	 * Set proper status for GPC21 to GPC24 which can be used as CS1_N to CS4_N.
+	 * Keep the pins' function used for chip select(CS) here according to your   
+         * system to avoid chip select crashing with sdram when resuming from sleep mode.
+         */
+
+#if defined(CONFIG_JZ4750D_APUS)
+        /* GPB25/CS1_N is used as chip select for nand flash, shouldn't be change. */ 
+
+        /* GPB26/CS2_N is connected to nand flash, needn't be changed. */
+
+        /* GPB28/CS3_N is used as cs8900's chip select, shouldn't be changed. */
+ 
+	/* GPB27/CS4_N is used as NOR's chip select, shouldn't be changed. */ 
+#endif
+
+ 	/* 
+         * Enable pull for NC pins here according to your system 
+	 */
+
+#if defined(CONFIG_JZ4750D_APUS)
+#endif
+
+	/* 
+         * If you must set some GPIOs as output to high level or low level,  
+         * you can set them here, using:
+         * __gpio_as_output(n);
+         * __gpio_set_pin(n); or  __gpio_clear_pin(n);
+	 */
+
+#if defined(CONFIG_JZ4750D_APUS)
+	/* GPC7 which is used as AMPEN_N should be set to high to disable audio amplifier */
+	__gpio_as_output(32*2+7);
+	__gpio_set_pin(32*2+7);
+#endif
+
+#ifdef DEBUG
+        /* Keep uart function for printing debug message */
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("sleep dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",      \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+#endif
+}
+
+static void jz_board_do_resume(unsigned long *ptr)
+{
+	unsigned char i;
+
+	/* Restore GPIO registers */
+	for(i = 1; i < GPIO_PORT_NUM; i++) {
+		 REG_GPIO_PXFUNS(i) = *ptr;
+		 REG_GPIO_PXFUNC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXSELS(i) = *ptr;
+		 REG_GPIO_PXSELC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXDIRS(i) = *ptr;
+		 REG_GPIO_PXDIRC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXPES(i) = *ptr;
+		 REG_GPIO_PXPEC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXIMS(i)=*ptr;
+		 REG_GPIO_PXIMC(i)=~(*ptr++);
+	
+		 REG_GPIO_PXDATS(i)=*ptr;
+		 REG_GPIO_PXDATC(i)=~(*ptr++);
+	
+		 REG_GPIO_PXTRGS(i)=*ptr;
+		 REG_GPIO_PXTRGC(i)=~(*ptr++);
+	}
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("resume dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",     \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+}
+
+
+
+static int jz_pm_do_sleep(void)
+{ 
+	unsigned long delta;
+	unsigned long nfcsr = REG_EMC_NFCSR;
+	unsigned long opcr = REG_CPM_OPCR;
+	unsigned long imr = REG_INTC_IMR;
+	unsigned long sadc = REG_SADC_ENA;
+	unsigned long sleep_gpio_save[7*(GPIO_PORT_NUM-1)];
+	
+	unsigned long flags;
+	
+	printk("Put CPU into sleep mode.\n");
+
+	/* Preserve current time */
+	delta = xtime.tv_sec - REG_RTC_RSR;
+	
+	local_irq_save(flags);	
+
+        /* Disable nand flash */
+	REG_EMC_NFCSR = ~0xff;
+
+        /* stop sadc */
+	REG_SADC_ENA &= ~0x7;
+	while((REG_SADC_ENA & 0x7) != 0);
+ 	udelay(100);
+
+        /*stop udc and usb*/
+	__cpm_suspend_uhcphy();
+	__cpm_suspend_udcphy();
+
+	/* Sleep on-board modules */
+	jz_board_do_sleep(sleep_gpio_save);
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/* Just allow following interrupts to wakeup the system.
+	 * Note: modify this according to your system.
+	 */
+
+	/* enable RTC alarm */
+	__intc_unmask_irq(IRQ_RTC);
+
+#if 0
+        /* make system wake up after n seconds by RTC alarm */
+	unsigned int v, n;
+	n = 10;
+	while (!__rtc_write_ready());
+	__rtc_enable_alarm();
+	while (!__rtc_write_ready());
+	__rtc_enable_alarm_irq();
+ 	while (!__rtc_write_ready());
+ 	v = __rtc_get_second();
+ 	while (!__rtc_write_ready());
+ 	__rtc_set_alarm_second(v+n);
+#endif
+
+	/* WAKEUP key */
+	__gpio_as_irq_rise_edge(GPIO_WAKEUP);
+	__gpio_unmask_irq(GPIO_WAKEUP);
+	__intc_unmask_irq(IRQ_GPIO0 - (GPIO_WAKEUP/32));  /* unmask IRQ_GPIOn depends on GPIO_WAKEUP */
+
+	/* disable externel clock Oscillator in sleep mode */
+	__cpm_disable_osc_in_sleep();
+	/* select 32K crystal as RTC clock in sleep mode */
+	__cpm_select_rtcclk_rtc();
+
+ 	/* Enter SLEEP mode */
+	REG_CPM_LCR &= ~CPM_LCR_LPM_MASK;
+	REG_CPM_LCR |= CPM_LCR_LPM_SLEEP;
+	__asm__(".set\tmips3\n\t"
+		"wait\n\t"
+		".set\tmips0");
+
+	/* Restore to IDLE mode */
+	REG_CPM_LCR &= ~CPM_LCR_LPM_MASK;
+	REG_CPM_LCR |= CPM_LCR_LPM_IDLE;
+
+        /* Restore nand flash control register */
+	REG_EMC_NFCSR = nfcsr;
+
+	/* Restore interrupts */
+	REG_INTC_IMSR = imr;
+	REG_INTC_IMCR = ~imr;
+	
+	/* Restore sadc */
+	REG_SADC_ENA = sadc;
+	
+	/* Resume on-board modules */
+	jz_board_do_resume(sleep_gpio_save);
+
+	/* Restore Oscillator and Power Control Register */
+	REG_CPM_OPCR = opcr;
+	
+	local_irq_restore(flags);
+	
+	/* Restore current time */
+	xtime.tv_sec = REG_RTC_RSR + delta;
+
+	return 0;
+}
+
+/* Put CPU to HIBERNATE mode */
+int jz_pm_hibernate(void)
+{
+	return jz_pm_do_hibernate();
+}
+
+/* Put CPU to SLEEP mode */
+int jz_pm_sleep(void)
+{
+	return jz_pm_do_sleep();
+}
+
+/*
+ * valid states, only support mem(sleep)
+ */
+static int jz_pm_valid(suspend_state_t state)
+{
+	return state == PM_SUSPEND_MEM;
+}
+
+/*
+ * Jz CPU enter save power mode
+ */
+static int jz_pm_enter(suspend_state_t state)
+{
+	return jz_pm_sleep();
+}
+
+static struct platform_suspend_ops jz_pm_ops = {
+	.valid		= jz_pm_valid,
+	.enter		= jz_pm_enter,
+};
+
+/*
+ * Initialize power interface
+ */
+int __init jz_pm_init(void)
+{
+	printk(JZ_SOC_NAME ": Power Management Interface Registered.\n");
+
+	suspend_set_ops(&jz_pm_ops);
+
+	return 0;
+}
+
+module_init(jz_pm_init);
diff --git a/arch/mips/jz4750d/proc.c b/arch/mips/jz4750d/proc.c
new file mode 100644
index 0000000..1cd5c98
--- /dev/null
+++ b/arch/mips/jz4750d/proc.c
@@ -0,0 +1,831 @@
+/*
+ * linux/arch/mips/jz4750d/proc.c
+ * 
+ * /proc/jz/ procfs for jz4750d on-chip modules.
+ * 
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/page-flags.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/jzsoc.h>
+
+//#define DEBUG 1
+#undef DEBUG
+
+struct proc_dir_entry *proc_jz_root;
+
+/*
+ * EMC Modules
+ */
+static int emc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += sprintf (page+len, "SMCR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SMCR0, REG_EMC_SMCR1, REG_EMC_SMCR2, REG_EMC_SMCR3, REG_EMC_SMCR4);
+	len += sprintf (page+len, "SACR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SACR0, REG_EMC_SACR1, REG_EMC_SACR2, REG_EMC_SACR3, REG_EMC_SACR4);
+	len += sprintf (page+len, "DMCR:      0x%08x\n", REG_EMC_DMCR);
+	len += sprintf (page+len, "RTCSR:     0x%04x\n", REG_EMC_RTCSR);
+	len += sprintf (page+len, "RTCOR:     0x%04x\n", REG_EMC_RTCOR);
+	return len;
+}
+
+/* 
+ * Power Manager Module
+ */
+static int pmc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned long lcr = REG_CPM_LCR;
+	unsigned long clkgr = REG_CPM_CLKGR;
+
+	len += sprintf (page+len, "Low Power Mode : %s\n", 
+			((lcr & CPM_LCR_LPM_MASK) == (CPM_LCR_LPM_IDLE)) ?
+			"IDLE" : (((lcr & CPM_LCR_LPM_MASK) == (CPM_LCR_LPM_SLEEP)) ? 
+				  "SLEEP" : "HIBERNATE"));
+	len += sprintf (page+len, "Doze Mode      : %s\n", 
+			(lcr & CPM_LCR_DOZE_ON) ? "on" : "off");
+	if (lcr & CPM_LCR_DOZE_ON)
+		len += sprintf (page+len, "     duty      : %d\n", (int)((lcr & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT));
+	len += sprintf (page+len, "AUX_CPU        : %s\n",
+			(clkgr & CPM_CLKGR_AUX_CPU) ? "stopped" : "running");
+	len += sprintf (page+len, "AHB1           : %s\n",
+			(clkgr & CPM_CLKGR_AHB1) ? "stopped" : "running");
+	len += sprintf (page+len, "IDCT           : %s\n",
+			(clkgr & CPM_CLKGR_IDCT) ? "stopped" : "running");
+	len += sprintf (page+len, "DB             : %s\n",
+			(clkgr & CPM_CLKGR_DB) ? "stopped" : "running");
+	len += sprintf (page+len, "ME             : %s\n",
+			(clkgr & CPM_CLKGR_ME) ? "stopped" : "running");
+	len += sprintf (page+len, "MC             : %s\n",
+			(clkgr & CPM_CLKGR_MC) ? "stopped" : "running");
+	len += sprintf (page+len, "TVE            : %s\n",
+			(clkgr & CPM_CLKGR_TVE) ? "stopped" : "running");
+	len += sprintf (page+len, "TSSI           : %s\n",
+			(clkgr & CPM_CLKGR_TSSI) ? "stopped" : "running");
+	len += sprintf (page+len, "IPU            : %s\n",
+			(clkgr & CPM_CLKGR_IPU) ? "stopped" : "running");
+	len += sprintf (page+len, "DMAC           : %s\n",
+			(clkgr & CPM_CLKGR_DMAC) ? "stopped" : "running");
+	len += sprintf (page+len, "UDC            : %s\n",
+			(clkgr & CPM_CLKGR_UDC) ? "stopped" : "running");
+	len += sprintf (page+len, "LCD            : %s\n",
+			(clkgr & CPM_CLKGR_LCD) ? "stopped" : "running");
+	len += sprintf (page+len, "CIM            : %s\n",
+			(clkgr & CPM_CLKGR_CIM) ? "stopped" : "running");
+	len += sprintf (page+len, "SADC           : %s\n",
+			(clkgr & CPM_CLKGR_SADC) ? "stopped" : "running");
+	len += sprintf (page+len, "MSC0           : %s\n",
+			(clkgr & CPM_CLKGR_MSC0) ? "stopped" : "running");
+	len += sprintf (page+len, "MSC1           : %s\n",
+			(clkgr & CPM_CLKGR_MSC1) ? "stopped" : "running");
+	len += sprintf (page+len, "SSI           : %s\n",
+			(clkgr & CPM_CLKGR_SSI) ? "stopped" : "running");
+	len += sprintf (page+len, "I2C            : %s\n",
+			(clkgr & CPM_CLKGR_I2C) ? "stopped" : "running");
+	len += sprintf (page+len, "RTC            : %s\n",
+			(clkgr & CPM_CLKGR_RTC) ? "stopped" : "running");
+	len += sprintf (page+len, "TCU            : %s\n",
+			(clkgr & CPM_CLKGR_TCU) ? "stopped" : "running");
+	len += sprintf (page+len, "UART1          : %s\n",
+			(clkgr & CPM_CLKGR_UART1) ? "stopped" : "running");
+	len += sprintf (page+len, "UART0          : %s\n",
+			(clkgr & CPM_CLKGR_UART0) ? "stopped" : "running");
+	return len;
+}
+
+static int pmc_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CLKGR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+/*
+ * Clock Generation Module
+ */
+#define TO_MHZ(x) (x/1000000),(x%1000000)/10000
+#define TO_KHZ(x) (x/1000),(x%1000)/10
+
+static int cgm_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int cppcr = REG_CPM_CPPCR;  /* PLL Control Register */
+	unsigned int cpccr = REG_CPM_CPCCR;  /* Clock Control Register */
+	unsigned int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int od[4] = {1, 2, 2, 4};
+
+	len += sprintf (page+len, "CPPCR          : 0x%08x\n", cppcr);
+	len += sprintf (page+len, "CPCCR          : 0x%08x\n", cpccr);
+	len += sprintf (page+len, "PLL            : %s\n", 
+			(cppcr & CPM_CPPCR_PLLEN) ? "ON" : "OFF");
+	len += sprintf (page+len, "m:n:o          : %d:%d:%d\n",
+			__cpm_get_pllm() + 2,
+			__cpm_get_plln() + 2,
+			od[__cpm_get_pllod()]
+		);
+	len += sprintf (page+len, "C:H:M:P        : %d:%d:%d:%d\n", 
+			div[__cpm_get_cdiv()],
+			div[__cpm_get_hdiv()],
+			div[__cpm_get_mdiv()],
+			div[__cpm_get_pdiv()]
+		);
+	len += sprintf (page+len, "PLL Freq        : %3d.%02d MHz\n", TO_MHZ(__cpm_get_pllout()));
+	len += sprintf (page+len, "CCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_cclk()));
+	len += sprintf (page+len, "HCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_hclk()));
+	len += sprintf (page+len, "MCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mclk()));
+	len += sprintf (page+len, "PCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_pclk()));
+	len += sprintf (page+len, "H1CLK           : %3d.%02d MHz\n", TO_MHZ(__cpm_get_h1clk()));
+	len += sprintf (page+len, "PIXCLK          : %3d.%02d KHz\n", TO_KHZ(__cpm_get_pixclk()));
+	len += sprintf (page+len, "I2SCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_i2sclk()));
+	len += sprintf (page+len, "USBCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_usbclk()));
+	len += sprintf (page+len, "MSC0CLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mscclk(0)));
+	len += sprintf (page+len, "MSC1CLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mscclk(1)));
+	len += sprintf (page+len, "EXTALCLK0       : %3d.%02d MHz\n", TO_MHZ(__cpm_get_extalclk0()));
+	len += sprintf (page+len, "EXTALCLK(by CPM): %3d.%02d MHz\n", TO_MHZ(__cpm_get_extalclk()));
+	len += sprintf (page+len, "RTCCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_rtcclk()));
+
+	return len;
+}
+
+static int cgm_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CPCCR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+extern void local_flush_tlb_all(void);
+
+/* CP0 hazard avoidance. */
+#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
+				     "nop; nop; nop; nop; nop; nop;\n\t" \
+				     ".set reorder\n\t")
+void show_tlb(void)
+{
+#define ASID_MASK 0xFF
+
+        unsigned long flags;
+        unsigned int old_ctx;
+	unsigned int entry;
+	unsigned int entrylo0, entrylo1, entryhi;
+	unsigned int pagemask;
+
+	local_irq_save(flags);
+
+	/* Save old context */
+	old_ctx = (read_c0_entryhi() & 0xff);
+
+	printk("TLB content:\n");
+	entry = 0;
+	while(entry < 32) {
+		write_c0_index(entry);
+		BARRIER;
+		tlb_read();
+		BARRIER;
+		entryhi = read_c0_entryhi();
+		entrylo0 = read_c0_entrylo0();
+		entrylo1 = read_c0_entrylo1();
+		pagemask = read_c0_pagemask();
+		printk("%02d: ASID=%02d%s VA=0x%08x ", entry, entryhi & ASID_MASK, (entrylo0 & entrylo1 & 1) ? "(G)" : "   ", entryhi & ~ASID_MASK);
+		printk("PA0=0x%08x C0=%x %s%s%s\n", (entrylo0>>6)<<12, (entrylo0>>3) & 7, (entrylo0 & 4) ? "Dirty " : "", (entrylo0 & 2) ? "Valid " : "Invalid ", (entrylo0 & 1) ? "Global" : "");
+		printk("\t\t\t     PA1=0x%08x C1=%x %s%s%s\n", (entrylo1>>6)<<12, (entrylo1>>3) & 7, (entrylo1 & 4) ? "Dirty " : "", (entrylo1 & 2) ? "Valid " : "Invalid ", (entrylo1 & 1) ? "Global" : "");
+
+		printk("\t\tpagemask=0x%08x", pagemask);
+		printk("\tentryhi=0x%08x\n", entryhi);
+		printk("\t\tentrylo0=0x%08x", entrylo0);
+		printk("\tentrylo1=0x%08x\n", entrylo1);
+
+		entry++;
+	}
+	BARRIER;
+	write_c0_entryhi(old_ctx);
+
+	local_irq_restore(flags);
+}
+
+/*
+ * UDC hotplug
+ */
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+extern int jz_udc_active;	/* defined in drivers/char/jzchar/jz_udc_hotplug.c */
+#endif
+
+#ifndef GPIO_UDC_HOTPLUG
+#define GPIO_UDC_HOTPLUG 86
+#endif
+
+static int udc_read_proc(char *page, char **start, off_t off,
+			 int count, int *eof, void *data)
+{
+        int len = 0;
+
+	if (__gpio_get_pin(GPIO_UDC_HOTPLUG)) {
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+
+		/* Cable has connected, wait for disconnection. */
+		__gpio_as_irq_fall_edge(GPIO_UDC_HOTPLUG);
+
+		if (jz_udc_active)
+			len += sprintf (page+len, "CONNECT_CABLE\n");
+		else
+			len += sprintf (page+len, "CONNECT_POWER\n");
+#else
+		len += sprintf (page+len, "CONNECT\n");
+#endif
+	}
+	else {
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+		/* Cable has disconnected, wait for connection. */
+		__gpio_as_irq_rise_edge(GPIO_UDC_HOTPLUG);
+#endif
+
+		len += sprintf (page+len, "REMOVE\n");
+	}
+
+        return len;
+}
+
+/*
+ * MMC/SD hotplug
+ */
+
+#ifndef MSC_HOTPLUG_PIN
+#define MSC_HOTPLUG_PIN 90
+#endif
+
+static int mmc_read_proc (char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+        int len = 0;
+
+        if (__gpio_get_pin(MSC_HOTPLUG_PIN))
+                len += sprintf (page+len, "REMOVE\n");
+        else
+                len += sprintf (page+len, "INSERT\n");
+
+        return len;
+}
+
+/***********************************************************************
+ * IPU memory management (used by mplayer and other apps)
+ *
+ * We reserved 4MB memory for IPU
+ * The memory base address is jz_ipu_framebuf
+ */
+
+/* Usage:
+ *
+ * echo n  > /proc/jz/imem 		// n = [0,...,10], allocate memory, 2^n pages
+ * echo xxxxxxxx > /proc/jz/imem	// free buffer which addr is xxxxxxxx
+ * echo FF > /proc/jz/ipu 		// FF, free all buffers
+ * od -X /proc/jz/imem 			// return the allocated buffer address and the max order of free buffer
+ */
+
+//#define DEBUG_IMEM 1
+
+#define IMEM0_MAX_ORDER 12		/* max 2^12 * 4096 = 16MB */
+static unsigned int jz_imem0_base;	/* physical base address of ipu memory */
+static unsigned int allocated_phys_addr0 = 0;
+
+/* 
+ * Allocated buffer list
+ */
+typedef struct imem_list {
+	unsigned int phys_start;	/* physical start addr */
+	unsigned int phys_end;		/* physical end addr */
+	struct imem_list *next;
+} imem_list_t;
+
+static struct imem_list *imem0_list_head = NULL; /* up sorted by phys_start */
+
+#define IMEM1_MAX_ORDER 11		/* max 2^11 * 4096 = 8MB */
+static unsigned int jz_imem1_base;	/* physical base address of ipu memory */
+static unsigned int allocated_phys_addr1 = 0;
+static struct imem_list *imem1_list_head = NULL; /* up sorted by phys_start */
+
+#ifdef DEBUG_IMEM
+static void dump_imem_list(void)
+{
+	struct imem_list *imem;
+
+	printk("*** dump_imem_list 0x%x ***\n", (u32)imem0_list_head);
+	imem = imem0_list_head;
+	while (imem) {
+		printk("imem=0x%x phys_start=0x%x phys_end=0x%x next=0x%x\n", (u32)imem, imem->phys_start, imem->phys_end, (u32)imem->next);
+		imem = imem->next;
+	}
+
+
+	printk("*** dump_imem_list 0x%x ***\n", (u32)imem1_list_head);
+	imem = imem1_list_head;
+	while (imem) {
+		printk("imem=0x%x phys_start=0x%x phys_end=0x%x next=0x%x\n", (u32)imem, imem->phys_start, imem->phys_end, (u32)imem->next);
+		imem = imem->next;
+	}
+
+}
+#endif
+
+/* allocate 2^order pages inside the 4MB memory */
+
+static int imem0_alloc(unsigned int order)
+{
+	int alloc_ok = 0;
+	unsigned int start, end;
+	unsigned int size = (1 << order) * PAGE_SIZE;
+	struct imem_list *imem, *imemn, *imemp;
+
+	allocated_phys_addr0 = 0;
+
+	start = jz_imem0_base;
+	end = start + (1 << IMEM0_MAX_ORDER) * PAGE_SIZE;
+
+	imem = imem0_list_head;
+	while (imem) {
+		if ((imem->phys_start - start) >= size) {
+			/* we got a valid address range */
+			alloc_ok = 1;
+			break;
+		}
+
+		start = imem->phys_end + 1;
+		imem = imem->next;
+	}
+
+	if (!alloc_ok) {
+		if ((end - start) >= size)
+			alloc_ok = 1;
+	}
+
+	if (alloc_ok) {
+		end = start + size - 1;
+		allocated_phys_addr0 = start;
+
+		/* add to imem_list, up sorted by phys_start */
+		imemn = kmalloc(sizeof(struct imem_list), GFP_KERNEL);
+		if (!imemn) {
+			return -ENOMEM;
+		}
+		imemn->phys_start = start;
+		imemn->phys_end = end;
+		imemn->next = NULL;
+
+		if (!imem0_list_head)
+			imem0_list_head = imemn;
+		else {
+			imem = imemp = imem0_list_head;
+			while (imem) {
+				if (start < imem->phys_start) {
+					break;
+				}
+
+				imemp = imem;
+				imem = imem->next;
+			}
+
+			if (imem == imem0_list_head) {
+				imem0_list_head = imemn;
+				imemn->next = imem;
+			}
+			else {
+				imemn->next = imemp->next;
+				imemp->next = imemn;
+			}
+		}
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+	return 0;
+}
+
+/* allocate 2^order pages inside the 4MB memory */
+static int imem1_alloc(unsigned int order)
+{
+	int alloc_ok = 0;
+	unsigned int start, end;
+	unsigned int size = (1 << order) * PAGE_SIZE;
+	struct imem_list *imem, *imemn, *imemp;
+
+	allocated_phys_addr1 = 0;
+
+	start = jz_imem1_base;
+	end = start + (1 << IMEM1_MAX_ORDER) * PAGE_SIZE;
+
+	imem = imem1_list_head;
+	while (imem) {
+		if ((imem->phys_start - start) >= size) {
+			/* we got a valid address range */
+			alloc_ok = 1;
+			break;
+		}
+
+		start = imem->phys_end + 1;
+		imem = imem->next;
+	}
+
+	if (!alloc_ok) {
+		if ((end - start) >= size)
+			alloc_ok = 1;
+	}
+
+	if (alloc_ok) {
+		end = start + size - 1;
+		allocated_phys_addr1 = start;
+
+		/* add to imem_list, up sorted by phys_start */
+		imemn = kmalloc(sizeof(struct imem_list), GFP_KERNEL);
+		if (!imemn) {
+			return -ENOMEM;
+		}
+		imemn->phys_start = start;
+		imemn->phys_end = end;
+		imemn->next = NULL;
+
+		if (!imem1_list_head)
+			imem1_list_head = imemn;
+		else {
+			imem = imemp = imem1_list_head;
+			while (imem) {
+				if (start < imem->phys_start) {
+					break;
+				}
+
+				imemp = imem;
+				imem = imem->next;
+			}
+
+			if (imem == imem1_list_head) {
+				imem1_list_head = imemn;
+				imemn->next = imem;
+			}
+			else {
+				imemn->next = imemp->next;
+				imemp->next = imemn;
+			}
+		}
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+	return 0;
+}
+
+
+static void imem_free(unsigned int phys_addr)
+{
+	struct imem_list *imem, *imemp;
+
+	imem = imemp = imem0_list_head;
+	while (imem) {
+		if (phys_addr == imem->phys_start) {
+			if (imem == imem0_list_head) {
+				imem0_list_head = imem->next;
+			}
+			else {
+				imemp->next = imem->next;
+			}
+
+			kfree(imem);
+			break;
+		}
+
+		imemp = imem;
+		imem = imem->next;
+	}
+
+
+	imem = imemp = imem1_list_head;
+	while (imem) {
+		if (phys_addr == imem->phys_start) {
+			if (imem == imem1_list_head) {
+				imem1_list_head = imem->next;
+			}
+			else {
+				imemp->next = imem->next;
+			}
+
+			kfree(imem);
+			break;
+		}
+
+		imemp = imem;
+		imem = imem->next;
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+}
+
+static void imem_free_all(void)
+{
+	struct imem_list *imem;
+
+	imem = imem0_list_head;
+	while (imem) {
+		kfree(imem);
+		imem = imem->next;
+	}
+
+	imem0_list_head = NULL;
+
+	allocated_phys_addr0 = 0;
+
+
+
+	imem = imem1_list_head;
+	while (imem) {
+		kfree(imem);
+		imem = imem->next;
+	}
+
+	imem1_list_head = NULL;
+
+	allocated_phys_addr1 = 0;
+
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+}
+
+/*
+ * Return the allocated buffer address and the max order of free buffer
+ */
+static int imem0_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int start_addr, end_addr, max_order, max_size;
+	struct imem_list *imem;
+
+	unsigned int *tmp = (unsigned int *)(page + len);
+
+	start_addr = jz_imem0_base;
+	end_addr = start_addr + (1 << IMEM0_MAX_ORDER) * PAGE_SIZE;
+
+	if (!imem0_list_head)
+		max_size = end_addr - start_addr;
+	else {
+		max_size = 0;
+		imem = imem0_list_head;
+		while (imem) {
+			if (max_size < (imem->phys_start - start_addr))
+				max_size = imem->phys_start - start_addr;
+
+			start_addr = imem->phys_end + 1;
+			imem = imem->next;
+		}
+
+		if (max_size < (end_addr - start_addr))
+			max_size = end_addr - start_addr;
+	}
+
+	if (max_size > 0) {
+		max_order = get_order(max_size);
+		if (((1 << max_order) * PAGE_SIZE) > max_size)
+		    max_order--;
+	}
+	else {
+		max_order = 0xffffffff;	/* No any free buffer */
+	}
+
+	*tmp++ = allocated_phys_addr0;	/* address allocated by 'echo n > /proc/jz/imem' */
+	*tmp = max_order;		/* max order of current free buffers */
+
+	len += 2 * sizeof(unsigned int);
+
+	return len;
+}
+
+static int imem0_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int val;
+
+	val = simple_strtoul(buffer, 0, 16);
+
+	if (val == 0xff) {
+		/* free all memory */
+		imem_free_all();
+	} else if ((val >= 0) && (val <= IMEM0_MAX_ORDER)) {
+		/* allocate 2^val pages */
+		imem0_alloc(val);
+	} else {
+		/* free buffer which phys_addr is val */
+		imem_free(val);
+	}
+
+	return count;
+}
+
+/*
+ * Return the allocated buffer address and the max order of free buffer
+ */
+static int imem1_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int start_addr, end_addr, max_order, max_size;
+	struct imem_list *imem;
+
+	unsigned int *tmp = (unsigned int *)(page + len);
+
+	start_addr = jz_imem1_base;
+	end_addr = start_addr + (1 << IMEM1_MAX_ORDER) * PAGE_SIZE;
+
+	if (!imem1_list_head)
+		max_size = end_addr - start_addr;
+	else {
+		max_size = 0;
+		imem = imem1_list_head;
+		while (imem) {
+			if (max_size < (imem->phys_start - start_addr))
+				max_size = imem->phys_start - start_addr;
+
+			start_addr = imem->phys_end + 1;
+			imem = imem->next;
+		}
+
+		if (max_size < (end_addr - start_addr))
+			max_size = end_addr - start_addr;
+	}
+
+	if (max_size > 0) {
+		max_order = get_order(max_size);
+		if (((1 << max_order) * PAGE_SIZE) > max_size)
+		    max_order--;
+	}
+	else {
+		max_order = 0xffffffff;	/* No any free buffer */
+	}
+
+	*tmp++ = allocated_phys_addr1;	/* address allocated by 'echo n > /proc/jz/imem' */
+	*tmp = max_order;		/* max order of current free buffers */
+
+	len += 2 * sizeof(unsigned int);
+
+	return len;
+}
+
+static int imem1_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int val;
+
+	val = simple_strtoul(buffer, 0, 16);
+
+	if (val == 0xff) {
+		/* free all memory */
+		imem_free_all();
+	} else if ((val >= 0) && (val <= IMEM1_MAX_ORDER)) {
+		/* allocate 2^val pages */
+		imem1_alloc(val);
+	} else {
+		/* free buffer which phys_addr is val */
+		imem_free(val);
+	}
+
+	return count;
+}
+
+/*
+ * /proc/jz/xxx entry
+ *
+ */
+static int __init jz_proc_init(void)
+{
+	struct proc_dir_entry *res;
+	unsigned int virt_addr, i;
+
+	proc_jz_root = proc_mkdir("jz", 0);
+
+	/* External Memory Controller */
+	res = create_proc_entry("emc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = emc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* Power Management Controller */
+	res = create_proc_entry("pmc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = pmc_read_proc;
+		res->write_proc = pmc_write_proc;
+		res->data = NULL;
+	}
+
+	/* Clock Generation Module */
+	res = create_proc_entry("cgm", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = cgm_read_proc;
+		res->write_proc = cgm_write_proc;
+		res->data = NULL;
+	}
+
+	/* udc hotplug */
+	res = create_proc_entry("udc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = udc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* mmc hotplug */
+	res = create_proc_entry("mmc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = mmc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+#ifdef CONFIG_JZ4750_IPU_MM
+	/*
+	 * Reserve a 16MB memory for IPU on JZ4750D.
+	 */
+	jz_imem0_base = (unsigned int)__get_free_pages(GFP_KERNEL, IMEM0_MAX_ORDER);
+	if (jz_imem0_base) {
+		/* imem (IPU memory management) */
+		res = create_proc_entry("imem", 0644, proc_jz_root);
+		if (res) {
+			res->read_proc = imem0_read_proc;
+			res->write_proc = imem0_write_proc;
+			res->data = NULL;
+		}
+
+		/* Set page reserved */
+		virt_addr = jz_imem0_base;
+		for (i = 0; i < (1 << IMEM0_MAX_ORDER); i++) {
+			SetPageReserved(virt_to_page((void *)virt_addr));
+			virt_addr += PAGE_SIZE;
+		}
+
+		/* Convert to physical address */
+		jz_imem0_base = virt_to_phys((void *)jz_imem0_base);
+
+		printk("Total %dMB memory at 0x%x was reserved for IPU\n", 
+		       (unsigned int)((1 << IMEM0_MAX_ORDER) * PAGE_SIZE)/1000000, jz_imem0_base);
+	} else
+		printk("NOT enough memory for imem\n");
+
+
+	jz_imem1_base = (unsigned int)__get_free_pages(GFP_KERNEL, IMEM1_MAX_ORDER);
+	if (jz_imem1_base) {
+		/* imem (IPU memory management) */
+		res = create_proc_entry("imem1", 0644, proc_jz_root);
+		if (res) {
+			res->read_proc = imem1_read_proc;
+			res->write_proc = imem1_write_proc;
+			res->data = NULL;
+		}
+
+		/* Set page reserved */
+		virt_addr = jz_imem1_base;
+		for (i = 0; i < (1 << IMEM1_MAX_ORDER); i++) {
+			SetPageReserved(virt_to_page((void *)virt_addr));
+			virt_addr += PAGE_SIZE;
+		}
+
+		/* Convert to physical address */
+		jz_imem1_base = virt_to_phys((void *)jz_imem1_base);
+
+		printk("Total %dMB memory1 at 0x%x was reserved for IPU\n", 
+		       (unsigned int)((1 << IMEM1_MAX_ORDER) * PAGE_SIZE)/1000000, jz_imem1_base);
+	} else
+		printk("NOT enough memory for imem1\n");
+#else
+	jz_imem0_base = jz_imem1_base = NULL;
+#endif
+
+	return 0;
+}
+
+__initcall(jz_proc_init);
diff --git a/arch/mips/jz4750d/prom.c b/arch/mips/jz4750d/prom.c
new file mode 100644
index 0000000..3c173d6e
--- /dev/null
+++ b/arch/mips/jz4750d/prom.c
@@ -0,0 +1,198 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *    PROM library initialisation code, supports YAMON and U-Boot.
+ *
+ * Copyright 2000, 2001, 2006 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * This file was derived from Carsten Langgaard's
+ * arch/mips/mips-boards/xx files.
+ *
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/jzsoc.h>
+
+/* #define DEBUG_CMDLINE */
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+
+char * prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void  prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+	while(actr < prom_argc) {
+	        strcpy(cp, prom_argv[actr]);
+		cp += strlen(prom_argv[actr]);
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	if (prom_argc > 1)
+		*cp = '\0';
+
+}
+
+
+char *prom_getenv(char *envname)
+{
+#if 0
+	/*
+	 * Return a pointer to the given environment variable.
+	 * YAMON uses "name", "value" pairs, while U-Boot uses "name=value".
+	 */
+
+	char **env = prom_envp;
+	int i = strlen(envname);
+	int yamon = (*env && strchr(*env, '=') == NULL);
+
+	while (*env) {
+		if (yamon) {
+			if (strcmp(envname, *env++) == 0)
+				return *env;
+		} else {
+			if (strncmp(envname, *env, i) == 0 && (*env)[i] == '=')
+				return *env + i + 1;
+		}
+		env++;
+	}
+#endif
+	return NULL;
+}
+
+inline unsigned char str2hexnum(unsigned char c)
+{
+	if(c >= '0' && c <= '9')
+		return c - '0';
+	if(c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if(c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return 0; /* foo */
+}
+
+inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+        char *ethaddr_str;
+
+        ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+	        printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+
+#if 0
+	{
+		int i;
+
+	printk("get_ethernet_addr: ");
+	for (i=0; i<5; i++)
+		printk("%02x:", (unsigned char)*(ethernet_addr+i));
+	printk("%02x\n", *(ethernet_addr+i));
+	}
+#endif
+
+	return 0;
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void __init prom_init(void)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = (int) fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+
+	mips_machtype = MACH_INGENIC_JZ4750D;
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x04000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
+
+/* used by early printk */
+void prom_putchar(char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART1_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART1_BASE + OFF_TDR);
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UARTLSR_TDRQ | UARTLSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+const char *get_system_type(void)
+{
+	return "JZ4750D";
+}
+
+EXPORT_SYMBOL(prom_getcmdline);
+EXPORT_SYMBOL(get_ethernet_addr);
+EXPORT_SYMBOL(str2eaddr);
diff --git a/arch/mips/jz4750d/reset.c b/arch/mips/jz4750d/reset.c
new file mode 100644
index 0000000..baf38aa
--- /dev/null
+++ b/arch/mips/jz4750d/reset.c
@@ -0,0 +1,42 @@
+/*
+ * linux/arch/mips/jz4750/reset.c
+ *
+ * JZ4750 reset routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <yliu@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+void jz_restart(char *command)
+{
+	printk("Restarting after 4 ms\n");
+	REG_WDT_TCSR = WDT_TCSR_PRESCALE4 | WDT_TCSR_EXT_EN;
+	REG_WDT_TCNT = 0;
+	REG_WDT_TDR = JZ_EXTAL/1000;   /* reset after 4ms */
+	REG_TCU_TSCR = TCU_TSCR_WDTSC; /* enable wdt clock */
+	REG_WDT_TCER = WDT_TCER_TCEN;  /* wdt start */
+	while (1);
+}
+
+void jz_halt(void)
+{
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+
+	while (1)
+		__asm__(".set\tmips3\n\t"
+	                "wait\n\t"
+			".set\tmips0");
+}
+
diff --git a/arch/mips/jz4750d/setup.c b/arch/mips/jz4750d/setup.c
new file mode 100644
index 0000000..4919e3f
--- /dev/null
+++ b/arch/mips/jz4750d/setup.c
@@ -0,0 +1,161 @@
+/*
+ * linux/arch/mips/jz4750d/common/setup.c
+ * 
+ * JZ4750D common setup routines.
+ * 
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+jz_clocks_t jz_clocks;
+
+extern char * __init prom_getcmdline(void);
+extern void __init jz_board_setup(void);
+extern void jz_restart(char *);
+extern void jz_pm_hibernate(void);
+extern void jz_halt(void);
+extern void jz_time_init(void);
+
+static void __init sysclocks_setup(void)
+{
+	jz_clocks.cclk = __cpm_get_cclk();
+	jz_clocks.hclk = __cpm_get_hclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.h1clk = __cpm_get_h1clk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.mscclk = __cpm_get_mscclk(0);
+	jz_clocks.extalclk = __cpm_get_extalclk();
+	jz_clocks.rtcclk = __cpm_get_rtcclk();
+
+	printk("CPU clock: %dMHz, System clock: %dMHz, Peripheral clock: %dMHz, Memory clock: %dMHz\n",
+	       (jz_clocks.cclk + 500000) / 1000000,
+	       (jz_clocks.hclk + 500000) / 1000000,
+	       (jz_clocks.pclk + 500000) / 1000000,
+	       (jz_clocks.mclk + 500000) / 1000000);
+}
+
+static void __init soc_cpm_setup(void)
+{
+	/* Start all module clocks
+	 */
+	__cpm_start_all();
+
+	/* Enable CKO to external memory */
+	__cpm_enable_cko();
+
+	/* CPU enters IDLE mode when executing 'wait' instruction */
+	__cpm_idle_mode();
+
+	/* Setup system clocks */
+	sysclocks_setup();
+}
+
+static void __init soc_harb_setup(void)
+{
+//	__harb_set_priority(0x00);  /* CIM>LCD>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x03);  /* LCD>CIM>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x0a);  /* ETH>LCD>CIM>DMA>PCI>USB>CBB */
+}
+
+static void __init soc_emc_setup(void)
+{
+}
+
+static void __init soc_dmac_setup(void)
+{
+	__dmac_enable_module(0);
+	__dmac_enable_module(1);
+}
+
+static void __init jz_soc_setup(void)
+{
+	soc_cpm_setup();
+	soc_harb_setup();
+	soc_emc_setup();
+	soc_dmac_setup();
+}
+
+static void __init jz_serial_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	struct uart_port s;
+	REG8(UART0_FCR) |= UARTFCR_UUE; /* enable UART module */
+	memset(&s, 0, sizeof(s));
+	s.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	s.iotype = SERIAL_IO_MEM;
+	s.regshift = 2;
+	s.uartclk = jz_clocks.extalclk ;
+
+	s.line = 0;
+	s.membase = (u8 *)UART0_BASE;
+	s.irq = IRQ_UART0;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS0 setup failed!\n");
+	}
+
+	s.line = 1;
+	s.membase = (u8 *)UART1_BASE;
+	s.irq = IRQ_UART1;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS1 setup failed!\n");
+	}
+#endif
+}
+
+void __init plat_mem_setup(void)
+{
+	char *argptr;
+
+	argptr = prom_getcmdline();
+
+	/* IO/MEM resources. Which will be the addtion value in `inX' and
+	 * `outX' macros defined in asm/io.h */
+	set_io_port_base(0);
+	ioport_resource.start	= 0x00000000;
+	ioport_resource.end	= 0xffffffff;
+	iomem_resource.start	= 0x00000000;
+	iomem_resource.end	= 0xffffffff;
+
+	_machine_restart = jz_restart;
+	_machine_halt = jz_halt;
+	pm_power_off = jz_pm_hibernate;
+
+	jz_soc_setup();
+	jz_serial_setup();
+	jz_board_setup();
+}
diff --git a/arch/mips/jz4750d/time.c b/arch/mips/jz4750d/time.c
new file mode 100644
index 0000000..0d997d1
--- /dev/null
+++ b/arch/mips/jz4750d/time.c
@@ -0,0 +1,214 @@
+/*
+ * linux/arch/mips/jz4750/time.c
+ * 
+ * Setting up the clock on the JZ4750 boards.
+ * 
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/clockchips.h>
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+/* This is for machines which generate the exact clock. */
+
+#define JZ_TIMER_TCU_CH  5
+#define JZ_TIMER_IRQ  IRQ_TCU1
+#define JZ_TIMER_CLOCK (JZ_EXTAL>>4) /* Jz timer clock frequency */
+
+static struct clocksource clocksource_jz; /* Jz clock source */
+static struct clock_event_device jz_clockevent_device; /* Jz clock event */
+
+void (*jz_timer_callback)(void);
+
+static irqreturn_t jz_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *cd = dev_id;
+	__tcu_clear_full_match_flag(JZ_TIMER_TCU_CH);
+	if (jz_timer_callback)
+		jz_timer_callback();
+
+	cd->event_handler(cd);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction jz_irqaction = {
+	.handler	= jz_timer_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU | IRQF_TIMER,
+	.name		= "jz-timerirq",
+};
+
+static unsigned int current_cycle_high = 0;
+union clycle_type
+{
+  cycle_t cycle64;
+  unsigned int cycle32[2];
+};
+
+cycle_t jz_get_cycles(struct clocksource *cs)
+{
+	/* convert jiffes to jz timer cycles */
+	unsigned int ostcount;
+	unsigned long cpuflags;
+	unsigned int current_cycle;
+	unsigned int flag;
+	union clycle_type old_cycle;
+	local_irq_save(cpuflags);
+	current_cycle = current_cycle_high;
+	ostcount = REG_TCU_OSTCNT;
+	flag = (REG_TCU_TFR & TCU_TFCR_OSTFCL) ? 1: 0;
+	if(flag)
+		ostcount = REG_TCU_OSTCNT;	  
+	local_irq_restore(cpuflags);
+
+	old_cycle.cycle32[0] = ostcount;
+	old_cycle.cycle32[1] = current_cycle + flag;
+
+	return (old_cycle.cycle64);
+}
+
+
+
+static struct clocksource clocksource_jz = {
+	.name 		= "jz_clocksource",
+	.rating		= 300,
+	.read		= jz_get_cycles,
+	.mask		= 0xFFFFFFFF,
+	.shift 		= 10,
+	.flags		= CLOCK_SOURCE_WATCHDOG,
+};
+
+
+
+static irqreturn_t jzclock_handler(int irq, void *dev_id)
+{
+  REG_TCU_TFCR = TCU_TFCR_OSTFCL; /* ACK timer */
+  current_cycle_high++;
+  return IRQ_HANDLED;
+}
+
+static struct irqaction jz_clockaction = {
+	.handler	= jzclock_handler,
+	.flags		= IRQF_DISABLED  | IRQF_TIMER,
+	.name		= "jz-clockcycle",
+};
+static int __init jz_clocksource_init(void)
+{
+	unsigned int latch;
+
+	/* Init timer */
+	latch = (JZ_TIMER_CLOCK + (HZ>>1)) / HZ;
+
+	clocksource_jz.mult = clocksource_hz2mult(JZ_TIMER_CLOCK, clocksource_jz.shift);
+	clocksource_register(&clocksource_jz);
+	//---------------------init sys clock -----------------
+	
+	REG_TCU_OSTCSR = TCU_OSTCSR_PRESCALE16 | TCU_OSTCSR_EXT_EN;
+
+	REG_TCU_OSTCNT = 0;
+	REG_TCU_OSTDR = 0xffffffff;
+	
+	jz_clockaction.dev_id = &clocksource_jz;
+
+	setup_irq(IRQ_TCU0, &jz_clockaction);
+	REG_TCU_TMCR = TCU_TMCR_OSTMCL; /* unmask match irq */
+	REG_TCU_TSCR = TCU_TSCR_OSTSC;  /* enable timer clock */
+	REG_TCU_TESR = TCU_TESR_OSTST;  /* start counting up */
+
+	//---------------------endif init sys clock -----------------
+	return 0;
+}
+
+static int jz_set_next_event(unsigned long evt,
+				  struct clock_event_device *unused)
+{
+	return 0;
+}
+
+static void jz_set_mode(enum clock_event_mode mode,
+			struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+                break;
+        case CLOCK_EVT_MODE_ONESHOT:
+        case CLOCK_EVT_MODE_UNUSED:
+        case CLOCK_EVT_MODE_SHUTDOWN:
+                break;
+        case CLOCK_EVT_MODE_RESUME:
+                break;
+        }
+}
+
+static struct clock_event_device jz_clockevent_device = {
+	.name		= "jz-clockenvent",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+//	.features	= CLOCK_EVT_FEAT_ONESHOT, /* Jz4740 not support dynamic clock now */
+
+	/* .mult, .shift, .max_delta_ns and .min_delta_ns left uninitialized */
+	.mult           = 1,
+	.rating		= 300,
+	.irq		= JZ_TIMER_IRQ,
+	.set_mode	= jz_set_mode,
+	.set_next_event	= jz_set_next_event,
+};
+
+static void __init jz_clockevent_init(void)
+{
+	struct clock_event_device *cd = &jz_clockevent_device;
+	unsigned int cpu = smp_processor_id();
+	cd->cpumask = cpumask_of(cpu);
+	clockevents_register_device(cd);
+}
+
+static void __init jz_timer_setup(void)
+{
+  	unsigned int latch;
+	
+	jz_clocksource_init();	/* init jz clock source */
+	jz_clockevent_init();	/* init jz clock event */
+	//---------------------init sys tick -----------------
+	/* Init timer */
+	__tcu_stop_counter(JZ_TIMER_TCU_CH);
+	__cpm_start_tcu();
+	latch = (JZ_TIMER_CLOCK + (HZ>>1)) / HZ;
+	
+	REG_TCU_TMSR = ((1 << JZ_TIMER_TCU_CH) | (1 << (JZ_TIMER_TCU_CH + 16))); 
+
+	REG_TCU_TCSR(JZ_TIMER_TCU_CH) = TCU_TCSR_PRESCALE16 | TCU_TCSR_EXT_EN;
+	REG_TCU_TDFR(JZ_TIMER_TCU_CH) = latch - 1;
+	REG_TCU_TDHR(JZ_TIMER_TCU_CH) = latch + 1;
+	REG_TCU_TCNT(JZ_TIMER_TCU_CH) = 0;
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	jz_irqaction.dev_id = &jz_clockevent_device;
+	setup_irq(JZ_TIMER_IRQ, &jz_irqaction);
+	__tcu_clear_full_match_flag(JZ_TIMER_TCU_CH);
+	__tcu_unmask_full_match_irq(JZ_TIMER_TCU_CH);
+	__tcu_start_counter(JZ_TIMER_TCU_CH);
+}
+
+
+void __init plat_time_init(void)
+{
+	jz_timer_setup();
+}
diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index be5bb16..4ed1283 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -163,6 +163,7 @@ void __init check_wait(void)
 	case CPU_BCM6358:
 	case CPU_CAVIUM_OCTEON:
 	case CPU_CAVIUM_OCTEON_PLUS:
+	case CPU_JZRISC:
 		cpu_wait = r4k_wait;
 		break;
 
@@ -282,7 +283,7 @@ static inline unsigned long cpu_get_fpu_id(void)
  */
 static inline int __cpu_has_fpu(void)
 {
-	return ((cpu_get_fpu_id() & 0xff00) != FPIR_IMP_NONE);
+	return 0;
 }
 
 static inline void cpu_probe_vmbits(struct cpuinfo_mips *c)
@@ -932,6 +933,27 @@ platform:
 	}
 }
 
+static inline void cpu_probe_ingenic(struct cpuinfo_mips *c, unsigned int cpu)
+{
+	decode_configs(c);
+
+	c->options &= ~MIPS_CPU_COUNTER; /* JZRISC does not implement the CP0 counter. */
+	switch (c->processor_id & 0xff00) {
+	case PRID_IMP_JZRISC:
+
+		c->cputype = CPU_JZRISC;
+		c->isa_level = MIPS_CPU_ISA_M32R1;
+		c->tlbsize = 32;
+
+		__cpu_name[cpu] = "Ingenic JZRISC";
+
+		break;
+	default:
+		panic("Unknown Ingenic Processor ID!");
+		break;
+	}
+}
+
 const char *__cpu_name[NR_CPUS];
 const char *__elf_platform;
 
@@ -970,6 +992,9 @@ __cpuinit void cpu_probe(void)
 	case PRID_COMP_CAVIUM:
 		cpu_probe_cavium(c, cpu);
 		break;
+	case PRID_COMP_INGENIC:
+		cpu_probe_ingenic(c, cpu);
+		break;
 	}
 
 	BUG_ON(!__cpu_name[cpu]);
diff --git a/arch/mips/kernel/cpufreq/Kconfig b/arch/mips/kernel/cpufreq/Kconfig
index 58c601e..9875d6d 100644
--- a/arch/mips/kernel/cpufreq/Kconfig
+++ b/arch/mips/kernel/cpufreq/Kconfig
@@ -20,6 +20,15 @@ if CPU_FREQ
 
 comment "CPUFreq processor drivers"
 
+config CPU_FREQ_JZ
+        tristate "CPUfreq driver for JZ CPUs"
+        depends on JZSOC
+        default n
+        help
+          This enables the CPUfreq driver for JZ CPUs.
+
+          If in doubt, say N.
+
 config LOONGSON2_CPUFREQ
 	tristate "Loongson2 CPUFreq Driver"
 	select CPU_FREQ_TABLE
diff --git a/arch/mips/kernel/entry.S b/arch/mips/kernel/entry.S
index ffa3310..b8461e1 100644
--- a/arch/mips/kernel/entry.S
+++ b/arch/mips/kernel/entry.S
@@ -38,6 +38,11 @@ FEXPORT(ret_from_irq)
 FEXPORT(__ret_from_irq)
 	LONG_L	t0, PT_STATUS(sp)		# returning to kernel mode?
 	andi	t0, t0, KU_USER
+	bnez	t0, resume_userspace
+        nop
+	LONG_L	t0, PT_STATUS(sp)		# returning to kernel mode?
+        srl     t0, t0, 27
+	andi	t0, t0, 1
 	beqz	t0, resume_kernel
 
 resume_userspace:
@@ -79,6 +84,11 @@ FEXPORT(syscall_exit)
 
 FEXPORT(restore_all)			# restore full frame
 #ifdef CONFIG_MIPS_MT_SMTC
+/* Detect and execute deferred IPI "interrupts" */
+	LONG_L	s0, TI_REGS($28)
+	LONG_S	sp, TI_REGS($28)
+	jal	deferred_smtc_ipi
+	LONG_S	s0, TI_REGS($28)
 #ifdef CONFIG_MIPS_MT_SMTC_IM_BACKSTOP
 /* Re-arm any temporarily masked interrupts not explicitly "acked" */
 	mfc0	v0, CP0_TCSTATUS
@@ -107,11 +117,6 @@ FEXPORT(restore_all)			# restore full frame
 	xor	t0, t0, t3
 	mtc0	t0, CP0_TCCONTEXT
 #endif /* CONFIG_MIPS_MT_SMTC_IM_BACKSTOP */
-/* Detect and execute deferred IPI "interrupts" */
-	LONG_L	s0, TI_REGS($28)
-	LONG_S	sp, TI_REGS($28)
-	jal	deferred_smtc_ipi
-	LONG_S	s0, TI_REGS($28)
 #endif /* CONFIG_MIPS_MT_SMTC */
 	.set	noat
 	RESTORE_TEMP
diff --git a/arch/mips/kernel/irq.c b/arch/mips/kernel/irq.c
index c6345f5..cda7d48 100644
--- a/arch/mips/kernel/irq.c
+++ b/arch/mips/kernel/irq.c
@@ -73,10 +73,17 @@ void free_irqno(unsigned int irq)
  * 'what should we do if we get a hw irq event on an illegal vector'.
  * each architecture has to answer this themselves.
  */
+void (*ack_bad_irq_callback)(unsigned int irq) = 0;
+
 void ack_bad_irq(unsigned int irq)
 {
+	if (ack_bad_irq_callback) {
+		ack_bad_irq_callback(irq);
+	}
 	smtc_im_ack_irq(irq);
 	printk("unexpected IRQ # %d\n", irq);
+
+	while (1);
 }
 
 atomic_t irq_err_count;
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index d612c6d..265f1f4 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -716,7 +716,8 @@ static void do_trap_or_bp(struct pt_regs *regs, unsigned int code,
 	switch (code) {
 	case BRK_OVERFLOW:
 	case BRK_DIVZERO:
-		scnprintf(b, sizeof(b), "%s instruction in kernel code", str);
+		scnprintf(b, sizeof(b), "%s(%d) instruction in kernel code"
+			  , str, code);
 		die_if_kernel(b, regs);
 		if (code == BRK_DIVZERO)
 			info.si_code = FPE_INTDIV;
@@ -747,7 +748,8 @@ static void do_trap_or_bp(struct pt_regs *regs, unsigned int code,
 		force_sig(SIGTRAP, current);
 		break;
 	default:
-		scnprintf(b, sizeof(b), "%s instruction in kernel code", str);
+		scnprintf(b, sizeof(b), "%s(%d) instruction in kernel code"
+			  , str, code);
 		die_if_kernel(b, regs);
 		force_sig(SIGTRAP, current);
 	}
diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c
index 6721ee2..9f29730 100644
--- a/arch/mips/mm/c-r4k.c
+++ b/arch/mips/mm/c-r4k.c
@@ -551,6 +551,22 @@ static void r4k_flush_data_cache_page(unsigned long addr)
 			        1);
 }
 
+void (*flush_insn_cache_page)(unsigned long addr);
+
+static inline void local_r4k_flush_insn_cache_page(void * addr)
+{
+	r4k_blast_icache_page((unsigned long) addr);
+}
+
+static void r4k_flush_insn_cache_page(unsigned long addr)
+{
+	if (in_atomic())
+		local_r4k_flush_insn_cache_page((void *)addr);
+	else
+		r4k_on_each_cpu(local_r4k_flush_insn_cache_page, (void *) addr,
+			        1);
+}
+
 struct flush_icache_range_args {
 	unsigned long start;
 	unsigned long end;
@@ -928,6 +944,35 @@ static void __cpuinit probe_pcache(void)
 		c->dcache.waybit = 0;
 		break;
 
+	case CPU_JZRISC:
+		config1 = read_c0_config1();
+		config1 = (config1 >> 22) & 0x07;
+		if (config1 == 0x07)
+			config1 = 10;
+		else
+			config1 = config1 + 11;
+		config1 += 2;
+		icache_size = (1 << config1);
+		c->icache.linesz = 32;
+		c->icache.ways = 4;
+		c->icache.waybit = __ffs(icache_size / c->icache.ways);
+
+		config1 = read_c0_config1();
+		config1 = (config1 >> 13) & 0x07;
+		if (config1 == 0x07)
+			config1 = 10;
+		else
+			config1 = config1 + 11;
+		config1 += 2;
+		dcache_size = (1 << config1);
+		c->dcache.linesz = 32;
+		c->dcache.ways = 4;
+		c->dcache.waybit = __ffs(dcache_size / c->dcache.ways);
+
+		c->dcache.flags = 0;
+		c->options |= MIPS_CPU_PREFETCH;
+
+		break;
 	default:
 		if (!(config & MIPS_CONF_M))
 			panic("Don't know how to probe P-caches on this cpu.");
@@ -1200,7 +1245,9 @@ static void __cpuinit setup_scache(void)
 		loongson2_sc_init();
 		return;
 #endif
-
+	case CPU_JZRISC:
+		sc_present = 0;
+		return;
 	default:
 		if (c->isa_level == MIPS_CPU_ISA_M32R1 ||
 		    c->isa_level == MIPS_CPU_ISA_M32R2 ||
@@ -1407,6 +1454,7 @@ void __cpuinit r4k_cache_init(void)
 	flush_data_cache_page	= r4k_flush_data_cache_page;
 	flush_icache_range	= r4k_flush_icache_range;
 	local_flush_icache_range	= local_r4k_flush_icache_range;
+	flush_insn_cache_page	= r4k_flush_insn_cache_page;
 
 #if defined(CONFIG_DMA_NONCOHERENT)
 	if (coherentio) {
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index 12af739..82c632d 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -52,6 +52,8 @@ void (*_dma_cache_wback)(unsigned long start, unsigned long size);
 void (*_dma_cache_inv)(unsigned long start, unsigned long size);
 
 EXPORT_SYMBOL(_dma_cache_wback_inv);
+EXPORT_SYMBOL(_dma_cache_wback);
+EXPORT_SYMBOL(_dma_cache_inv);
 
 #endif /* CONFIG_DMA_NONCOHERENT */
 
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 86f004d..4510e61 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -409,6 +409,11 @@ static void __cpuinit build_tlb_write_entry(u32 **p, struct uasm_label **l,
 		tlbw(p);
 		break;
 
+	case CPU_JZRISC:
+		tlbw(p);
+		uasm_i_nop(p);
+		break;
+
 	default:
 		panic("No TLB refill handler yet (CPU type: %d)",
 		      current_cpu_data.cputype);
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 3141dd3..244656f 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -793,6 +793,12 @@ config NVRAM
 	  To compile this driver as a module, choose M here: the
 	  module will be called nvram.
 
+config RTC_JZ
+	bool 'Jz47XX On-Chip Real Time Clock'
+	depends on SOC_JZ4750 || SOC_JZ4750D
+	help
+	  Jz47XX On-Chip Real Time Clock
+
 #
 # These legacy RTC drivers just cause too many conflicts with the generic
 # RTC framework ... let's not even try to coexist any more.
@@ -1111,7 +1117,10 @@ config DEVPORT
 	depends on ISA || PCI
 	default y
 
+
+
 source "drivers/s390/char/Kconfig"
+source "drivers/char/jzchar/Kconfig"
 
 endmenu
 
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index f957edf..8b5f97a 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -98,6 +98,9 @@ obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
 
+obj-$(CONFIG_RTC_JZ)		+= rtc_jz.o
+obj-$(CONFIG_JZCHAR)		+= jzchar/
+
 obj-$(CONFIG_MWAVE)		+= mwave/
 obj-$(CONFIG_AGP)		+= agp/
 obj-$(CONFIG_PCMCIA)		+= pcmcia/
diff --git a/drivers/char/jzchar/Kconfig b/drivers/char/jzchar/Kconfig
new file mode 100644
index 0000000..9a79de4
--- /dev/null
+++ b/drivers/char/jzchar/Kconfig
@@ -0,0 +1,24 @@
+#
+# JzSOC char devices configuration
+#
+
+menu "JZSOC char device support"
+	depends on SOC_JZ4750D
+
+config JZCHAR
+	tristate 'JzSOC char device support'
+	depends on SOC_JZ4750D
+
+config JZ_SIMPLE_I2C
+	tristate 'Ingenic Simple I2C Userspace Driver'
+	depends on JZCHAR
+
+config JZ_OW
+	tristate 'JZ One-wire bus support'
+	depends on JZCHAR
+
+config JZ_TCSM
+	tristate 'JZ TCSM support'
+	depends on JZCHAR
+
+endmenu
diff --git a/drivers/char/jzchar/Makefile b/drivers/char/jzchar/Makefile
new file mode 100644
index 0000000..078720c0
--- /dev/null
+++ b/drivers/char/jzchar/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for jzchar
+#
+obj-$(CONFIG_JZCHAR)		+= jzchars.o
+
+obj-$(CONFIG_JZ_OW)	+= jz_ow.o
+obj-$(CONFIG_JZ_TCSM)	+= tcsm.o
+
+obj-$(CONFIG_JZ_SIMPLE_I2C) += i_i2c.o
diff --git a/drivers/char/jzchar/example/i_i2c_tool.c b/drivers/char/jzchar/example/i_i2c_tool.c
new file mode 100644
index 0000000..62ee255
--- /dev/null
+++ b/drivers/char/jzchar/example/i_i2c_tool.c
@@ -0,0 +1,81 @@
+/*
+ * JZ4750 Simple I2C Userspace Example.
+ *
+ * Copyright (c) 2005-2010  Ingenic Semiconductor Inc.
+ * Author: River <zwang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+
+#include "../i_i2c_abi.h"
+
+#define I2C_DEV "/dev/i_i2c"
+#define SZ_BUF	2048
+
+int main(int argc, char **argv)
+{
+	struct i_i2c_control control;
+	
+	unsigned char buf[SZ_BUF];
+	
+	int fd;
+	int count = 64;
+
+	int i;
+	int rv;
+
+	fd = open(I2C_DEV, O_RDWR);
+	if (fd == -1) {
+		perror("open():");
+		exit(EXIT_FAILURE);
+	}
+	
+	control.id = I_I2C_ID_AT24C16B;
+	control.offset = 0;
+	control.buf = buf;
+	control.count = count;
+	
+	rv = ioctl(fd, I_I2C_IOC_READ_DEV, &control);
+	if (rv)	{
+		perror("ioctl():");
+		exit(EXIT_FAILURE);
+	}
+	
+	for (i = 0; i < count; i++)
+		fprintf(stderr, "%x ", buf[i]);
+
+	fprintf(stderr, "\n", buf[i]);
+	
+	if (argc != 1)
+		for (i = 0; i < count; i++)
+			buf[i] = i;
+	else
+		for (i = 0; i < count; i++)
+			buf[i] = 0;
+
+	control.id = I_I2C_ID_AT24C16B;
+	control.offset = 0;
+	control.buf = buf;
+	control.count = count;
+
+	rv = ioctl(fd, I_I2C_IOC_WRITE_DEV, &control);	
+	if (rv)	{
+		perror("ioctl():");
+		exit(EXIT_FAILURE);
+	}
+	
+	close(fd);
+
+	return 0;
+}
diff --git a/drivers/char/jzchar/i_i2c.c b/drivers/char/jzchar/i_i2c.c
new file mode 100644
index 0000000..a254851
--- /dev/null
+++ b/drivers/char/jzchar/i_i2c.c
@@ -0,0 +1,190 @@
+/*
+ * JZ4750 Simple I2C Userspace Driver.
+ *
+ * Copyright (c) 2005-2010  Ingenic Semiconductor Inc.
+ * Author: River <zwang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+
+#include <asm/uaccess.h>
+#include <asm/jzsoc.h>
+
+#include "i_i2c_abi.h"
+
+/* ------------- CUSTOM: Add your own devices/timings here. -------------*/
+static struct i_i2c_dev i_i2c_devs[] = {
+	{
+		.id = I_I2C_ID_AT24C16B,
+
+		.name = "AT24C16B",
+		.address = 0x50,	/* 7 bit device address. */
+		.cap = I_I2C_CAP_SEQ_READ | I_I2C_CAP_SEQ_WRITE, /* Device capabilites. */
+		.size = 16 * 1024,	/* The range of offset will be checked when set. */
+		.read_size = 16 * 1024, /* SEQ Read size. */
+		.write_size = 16,	/* SEQ Write size. */
+	},
+};
+
+static struct i_i2c_timing i_i2c_timings[] = {
+	{
+		.id = I_I2C_ID_AT24C16B,
+
+		.clk = 100 * 1000,	/* I2C Device clock - Default: 100K. */
+		.timeout = 100 * 1000,	/* MAX allowed timeout in loops */
+		.t_wr = 5,		/* tWR / t(Stop - Next Start) in ms */
+	},
+};
+/*--------------------------------------------------------------------*/
+
+#define DRV_NAME "Simple I2C Userspace Driver"
+#define DRV_VERSION "0.1"
+
+static struct i_i2c_dev *find_dev(int id)
+{
+	struct i_i2c_dev *dev;
+	unsigned int i;
+
+	dev = i_i2c_devs;
+	for (i = 0; i < sizeof(i_i2c_devs) / sizeof(struct i_i2c_dev); i++, dev++) 
+		if (dev->id == id)
+			return dev;
+
+	return NULL;
+}
+
+static struct i_i2c_timing *find_timing(int id)
+{
+	struct i_i2c_timing *timing;
+	unsigned int i;
+
+	timing = i_i2c_timings;
+	for (i = 0; i < sizeof(i_i2c_timings) / sizeof(struct i_i2c_timing); i++, timing++) 
+		if (timing->id == id)
+			return timing;
+
+	return NULL;
+}
+
+static void prepare_device_and_timing(void)
+{
+	struct i_i2c_dev *dev;
+	struct i_i2c_timing *timing;
+
+	unsigned int i;
+	
+	dev = i_i2c_devs;
+
+	for (i = 0; i < sizeof(i_i2c_devs) / sizeof(struct i_i2c_dev); i++, dev++) {
+		if (!dev->timing_id)
+			timing = find_timing(dev->id);
+		else
+			timing = find_timing(dev->timing_id);
+
+		if (!timing) {
+			printk(KERN_ERR "%s(): Cannot find timing for device: %s.\n", __func__, dev->name);
+			continue;
+		}
+		
+		dev->timing = timing;
+		dev->timing_id = timing->id;
+		
+		i_i2c_init_dev(dev);
+		
+		printk("Found I2C Device: %s - Address: 0x%x.\n", dev->name, dev->address);
+	}
+	
+	return;
+}
+
+static int i_i2c_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct i_i2c_dev *dev;
+	struct i_i2c_control control;
+	
+	if (copy_from_user(&control, (void __user *)arg, sizeof(control))) {
+		return -EFAULT;
+	}
+
+	dev = find_dev(control.id);
+	if (!dev || !dev->timing) {
+		printk(KERN_ERR "%s(): ID %d not found or not timing attached.\n", __func__, control.id);
+		return -ENODEV;
+	}
+
+	if (dev->size && control.offset + control.count > dev->size) {
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+		case I_I2C_IOC_READ_DEV:
+			if (!access_ok(VERIFY_WRITE, control.buf, control.count)) {
+				return -EFAULT;
+			}
+			
+			return i_i2c_read_dev(dev, control.offset, control.buf, control.count);
+
+		case I_I2C_IOC_WRITE_DEV:
+			if (!access_ok(VERIFY_READ, control.buf, control.count)) {
+				return -EFAULT;
+			}
+
+			return i_i2c_write_dev(dev, control.offset, control.buf, control.count);		
+		default:
+			return -EINVAL;
+	}
+	
+	return 0;
+}
+
+static const struct file_operations i_i2c_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = i_i2c_ioctl,
+};
+
+static struct miscdevice i_i2c_misc_device = {
+        .minor          = MISC_DYNAMIC_MINOR,
+        .name           = "i_i2c",
+        .fops           = &i_i2c_fops,
+};
+
+static int __init i_i2c_init(void)
+{
+	int rv;
+
+	printk(KERN_INFO JZ_SOC_NAME": %s - %s.\n", DRV_NAME, DRV_VERSION);
+
+	prepare_device_and_timing();
+	
+	rv = misc_register(&i_i2c_misc_device);
+	if (rv) {
+		printk(KERN_ERR "%s(): Failed to register misc device.\n", __func__);
+		return rv;
+	}
+	
+	printk(KERN_INFO JZ_SOC_NAME": %s Registered.\n", DRV_NAME);
+
+	return 0;
+}
+
+static void __exit i_i2c_exit(void)
+{
+	misc_deregister(&i_i2c_misc_device);
+}
+
+MODULE_AUTHOR("River Wang <zwang@ingenic.cn>");
+MODULE_DESCRIPTION("Ingenic Simple I2C Userspace Driver");
+MODULE_LICENSE("GPL");
+
+module_init(i_i2c_init);
+module_exit(i_i2c_exit);
diff --git a/drivers/char/jzchar/i_i2c_abi.h b/drivers/char/jzchar/i_i2c_abi.h
new file mode 100644
index 0000000..c54fa1a
--- /dev/null
+++ b/drivers/char/jzchar/i_i2c_abi.h
@@ -0,0 +1,33 @@
+/*
+ * JZ4750 Simple I2C Userspace Driver ABI Definations.
+ *
+ * Copyright (c) 2005-2010  Ingenic Semiconductor Inc.
+ * Author: River <zwang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef __I_I2C_ABI_H__
+#define __I_I2C_ABI_H__
+
+/* -------------- CUSTOM: Add your device/timing ID here. --------------*/
+/* Device ID */
+enum {
+	I_I2C_ID_AT24C16B = 1,	/* ID must start from 1. */
+};
+/* ---------------------------------------------------------------------*/
+
+struct i_i2c_control {
+	int id;			/* Device ID. */
+	off_t offset;		/* Offset. */
+	void *buf;		/* IO buffer. */
+	size_t count;		/* IO count. */
+};
+
+#define I_I2C_IOC_READ_DEV	_IOW('I', 1, struct i_i2c_control)
+#define I_I2C_IOC_WRITE_DEV	_IOR('I', 2, struct i_i2c_control)
+
+#endif
diff --git a/drivers/char/jzchar/jz_ow.c b/drivers/char/jzchar/jz_ow.c
new file mode 100644
index 0000000..7ea6fd4
--- /dev/null
+++ b/drivers/char/jzchar/jz_ow.c
@@ -0,0 +1,497 @@
+/*
+ * linux/drivers/char/jzchar/jz_ow.c
+ *
+ * One Wire Bus test driver
+ *
+ * Copyright (C) 2006  Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/spinlock.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/jzsoc.h>
+#include "jzchars.h"
+
+#define OW_CPU_READ_ROM           1
+#define OW_INTC_READ_ROM         1
+#define OW_CPU_SEARCH_ROM       0
+#define OW_INTC_SEARCH_ROM     0
+
+#define OW_DEBUG  0
+#if OW_DEBUG
+#define OWI_MAX   10
+static char CFG[OWI_MAX];
+static char CTL[OWI_MAX];
+static char STS[OWI_MAX];
+static char DAT[OWI_MAX];
+static char DIV[OWI_MAX];
+static void owi_register_dump(int i)
+{
+	CFG[i]=	REG_OWI_CFG;
+	CTL[i]= REG_OWI_CTL;
+	STS[i]= REG_OWI_STS;
+	DAT[i]= REG_OWI_DAT;
+	DIV[i]= REG_OWI_DIV;
+}
+static void owi_register_print(int i)
+{
+	printk(" REG_OWI_CFG: 0x%08x\n", CFG[i]);
+	printk(" REG_OWI_CTL: 0x%08x\n", CTL[i]);
+	printk(" REG_OWI_STS: 0x%08x\n", STS[i]);
+	printk(" REG_OWI_DAT: 0x%08x\n", DAT[i]);
+	printk(" REG_OWI_DIV: 0x%08x\n", DIV[i]);
+}
+#endif
+
+static DECLARE_WAIT_QUEUE_HEAD (ow_wait_queue);
+
+/*
+ * fops routines
+ */
+static int ow_open(struct inode *inode, struct file *filp);
+static int ow_release(struct inode *inode, struct file *filp);
+static ssize_t ow_read(struct file *filp, char *buf, size_t size, loff_t *l);
+static ssize_t ow_write(struct file *filp, const char *buf, size_t size, loff_t *l);
+static int ow_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);
+
+static void do_ow_rddata(void);
+static void do_ow_wrdata(void);
+static void do_ow_wr1rd(void);
+static void do_ow_wr0(void);
+static void do_ow_rst(void);
+
+static void do_interrupt_mode_test(void);
+static void do_cpu_mode_test(void);
+
+static struct file_operations ow_fops = 
+{
+	open:		ow_open,
+	release:	ow_release,
+	read:		ow_read,
+	write:		ow_write,
+	ioctl:		ow_ioctl,
+};
+
+static int ow_open(struct inode *inode, struct file *filp)
+{
+	try_module_get(THIS_MODULE);
+ 	return 0;
+}
+
+static int ow_release(struct inode *inode, struct file *filp)
+{
+	module_put(THIS_MODULE);
+	return 0;	
+}
+
+static ssize_t ow_read(struct file *filp, char *buf, size_t size, loff_t *l)
+{
+	printk("OW: read is not implemented\n");
+	return -1;
+}
+
+static ssize_t ow_write(struct file *filp, const char *buf, size_t size, loff_t *l)
+{
+	printk("ow: write is not implemented\n");
+	return -1;
+}
+
+static int ow_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	switch (cmd) {
+
+	default:
+		printk("Not supported command: 0x%x\n", cmd);
+		return -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static void do_ow_rddata(void)
+{
+	__owi_clr_sts();
+	__owi_set_rddata();
+	__owi_enable_ow_ops();
+}
+
+static void do_ow_wrdata(void)
+{
+	__owi_clr_sts();
+	__owi_set_wrdata();
+	__owi_enable_ow_ops();
+}
+
+static void do_ow_wr1rd(void)
+{
+	__owi_clr_sts();
+	__owi_set_wr1rd();
+	__owi_enable_ow_ops();
+}
+
+static void do_ow_wr0(void)
+{
+	__owi_clr_sts();
+	__owi_set_wr0();
+	__owi_enable_ow_ops();
+}
+
+static void do_ow_rst(void)
+{
+	__owi_clr_sts();
+	__owi_set_rst();
+	__owi_enable_ow_ops();
+}
+
+static irqreturn_t ow_interrupt(int irq, void *dev_id)
+{
+	__owi_clr_sts();
+	wake_up(&ow_wait_queue);
+
+	return IRQ_HANDLED;
+}
+
+static void ow_intcm_read_rom(char *rom)
+{
+	int i; 
+	
+	__owi_select_regular_mode();
+	REG_OWI_DIV = 23;
+	__owi_clr_sts();
+	__intc_unmask_irq(IRQ_OWI);
+	__owi_enable_all_interrupts();
+
+	do_ow_rst();
+	sleep_on(&ow_wait_queue);
+
+	REG_OWI_DAT = 0x33;
+	do_ow_wrdata();
+	sleep_on(&ow_wait_queue);
+	
+	for(i=0; i<8; i++){
+		do_ow_rddata();
+		sleep_on(&ow_wait_queue);
+		rom[i] = REG_OWI_DAT;
+	}	
+	__intc_mask_irq(IRQ_OWI);
+}
+
+static void ow_intcm_search_rom(void)
+{
+	int i, j; 
+	int normal, reverse;
+#if 1
+	unsigned char rom[8]={0x01, 0xf9, 0x35, 0x53, 0x11, 0x00, 0x00, 0x3e};
+#else
+	unsigned char rom[8]={0x01, 0xd8, 0x10, 0x02, 0x10, 0x00, 0x00, 0x22};
+#endif
+	__owi_select_regular_mode(); 	
+	REG_OWI_DIV =  __cpm_get_extalclk()/1000000 - 1;
+	__owi_clr_sts();
+	__intc_unmask_irq(IRQ_OWI);
+	__owi_enable_all_interrupts();
+	
+        /* reset */
+	do_ow_rst();
+	sleep_on(&ow_wait_queue);
+	
+	/* send search ROM command */
+	REG_OWI_DAT = 0xf0;
+	do_ow_wrdata();
+	sleep_on(&ow_wait_queue);
+
+	for( i=0; i<8; i++){
+		for (j=0; j<8; j++){
+			do_ow_wr1rd();
+			sleep_on(&ow_wait_queue);
+			normal = ( __owi_get_rdst() !=0);
+			printk("normal: %d\n",normal);
+
+			do_ow_wr1rd();
+			sleep_on(&ow_wait_queue);
+			reverse = ( __owi_get_rdst() !=0);
+			printk("reverse: %d\n",reverse);
+
+			if(normal ==1 && reverse ==1){
+				printk("Search rom INTC mode: 11  NO device found\n");
+				__intc_mask_irq(IRQ_OWI);
+				return;
+			}
+#if 1
+			if ( (rom[i]>>j) & 1 ){
+				printk("write 1\n");
+				do_ow_wr1rd();
+				sleep_on(&ow_wait_queue);
+			}
+			else{
+				printk("write 0\n");
+				do_ow_wr0();
+				sleep_on(&ow_wait_queue);
+			}				
+			
+#else
+			if(normal ==0 && reverse ==0){
+				if (!((rom[i]>>j) & 1) ){
+					printk("write 1\n");
+					do_ow_wr1rd();
+					sleep_on(&ow_wait_queue);
+				}
+				else{
+					printk("write 0\n");
+					do_ow_wr0();
+					sleep_on(&ow_wait_queue);
+				}			
+			}else{
+			
+				if(normal ==0){
+					printk("write 0\n");
+					do_ow_wr0();
+					sleep_on(&ow_wait_queue);
+				}
+				if(normal ==1){
+					printk("write 1\n");
+					do_ow_wr1rd();
+					sleep_on(&ow_wait_queue);
+				}
+			}
+#endif
+
+		}
+		printk("\n\n");
+	}
+
+	printk("\nSearch rom INTC mode: device found SUCCESSFULLY\n");
+	__intc_mask_irq(IRQ_OWI);
+       
+}
+
+static void ow_cpum_read_rom(char *rom)
+{
+	int i; 
+	
+	__owi_select_regular_mode(); 
+	REG_OWI_DIV =  __cpm_get_extalclk()/1000000 - 1;
+	__owi_clr_sts();
+	__owi_disable_all_interrupts();
+
+	do_ow_rst();
+	__owi_wait_ops_rdy();
+
+	if(!__owi_get_sts_pst())
+		printk("read rom no device found\n");
+	 
+	REG_OWI_DAT = 0x33;
+	do_ow_wrdata();
+	__owi_wait_ops_rdy();
+	
+	for(i=0; i<8; i++){
+		do_ow_rddata();
+		__owi_wait_ops_rdy();
+		rom[i] = REG_OWI_DAT;
+	}	
+}
+
+
+static void ow_comm_bit(unsigned comm)
+{
+	int i;
+	for(i=0; i<8; i++){
+		if ( comm & (1<<i) ) 
+			do_ow_wr1rd();
+		else
+			do_ow_wr0();
+		while(!__owi_get_sts_bit_rdy());
+	}
+}
+
+static void ow_cpum_search_rom(void)
+{
+	int i, j; 
+	int normal, reverse;
+#if 1
+	unsigned char rom[8]={0x01, 0xf9, 0x35, 0x53, 0x11, 0x00, 0x00, 0x3e};
+#else
+	unsigned char rom[8]={0x01, 0xd8, 0x10, 0x02, 0x10, 0x00, 0x00, 0x22};
+#endif
+
+	__owi_select_regular_mode(); 
+	REG_OWI_DIV = 23;
+	__owi_clr_sts();
+	__owi_disable_all_interrupts();
+	
+	do_ow_rst();
+	while(!__owi_get_sts_pst_rdy()) ;
+	
+	if(!__owi_get_sts_pst())
+		printk("search rom: no device found\n");
+#if 1	
+	REG_OWI_DAT = 0xf0;
+	do_ow_wrdata();
+	while(! __owi_get_sts_byte_rdy()) ;
+#else
+	ow_comm_bit(0xf0);
+#endif
+
+	for( i=0; i<8; i++){
+		for (j=0; j<8; j++){
+			do_ow_wr1rd();
+			while(!__owi_get_sts_bit_rdy()) ;
+			normal = ( __owi_get_rdst() !=0);
+			printk("normal: %d\n",normal);
+
+			do_ow_wr1rd();
+			while(!__owi_get_sts_bit_rdy()) ;
+			reverse = ( __owi_get_rdst() !=0);
+			printk("reverse: %d\n",reverse);
+
+			if(normal ==1 && reverse ==1){
+				printk("Search rom CPU mode: 11  NO device found\n");
+				return;
+			}
+
+#if 1
+			if ( (rom[i]>>j) & 1 ){
+				printk("write 1\n");
+				do_ow_wr1rd();
+				while(!__owi_get_sts_bit_rdy()) ;
+			}
+			else{
+				printk("write 0\n");
+				do_ow_wr0();
+				while(!__owi_get_sts_bit_rdy()) ;
+			}				
+			
+#else
+			if(normal ==0 && reverse ==0){
+				if (!((rom[i]>>j) & 1) ){
+					printk("write 1\n");
+					do_ow_wr1rd();
+					while(!__owi_get_sts_bit_rdy()) ;
+				}
+				else{
+					printk("write 0\n");
+					do_ow_wr0();
+					while(!__owi_get_sts_bit_rdy()) ;
+				}			
+			}else{
+			
+				if(normal ==0){
+					printk("write 0\n");
+					do_ow_wr0();
+					while(!__owi_get_sts_bit_rdy()) ;
+				}
+				if(normal ==1){
+					printk("write 1\n");
+					do_ow_wr1rd();
+					while(!__owi_get_sts_bit_rdy()) ;
+				}
+			}
+#endif
+
+		}
+		printk("\n\n");
+	}
+	printk("\nSearch rom CPU mode: device found SUCCESSFULLY\n");
+}
+	
+static void do_interrupt_mode_test(void)
+{
+	int ret, i;
+	unsigned char rom[8];
+	
+	/* interrupt mode */
+	ret = request_irq(IRQ_OWI, ow_interrupt, IRQF_DISABLED, 
+			  "JZ_OWI", NULL); 
+	if(ret)
+		printk("failed irq \n");
+
+#if OW_INTC_READ_ROM
+	ow_intcm_read_rom(rom);
+	printk("\n\nAfter intc mode read ROM ops: \n");
+	printk("ROM: ");
+	for(i=0; i<8; i++)
+		printk("0x%02x,",rom[i]);
+#endif
+
+#if OW_INTC_SEARCH_ROM
+	ow_intcm_search_rom();
+#endif
+
+}
+
+static void do_cpu_mode_test(void)
+{
+	
+#if OW_CPU_READ_ROM
+	int i;
+	unsigned char rom[8];
+
+	ow_cpum_read_rom(rom);
+	printk("\n\nAfter CPU mode read ROM ops: \n");
+	printk("ROM: ");
+	for(i=0; i<8; i++)
+		printk("0x%02x,",rom[i]);
+#endif
+
+#if OW_CPU_SEARCH_ROM
+	ow_cpum_search_rom();	
+#endif
+}
+
+/*
+ * Module init and exit
+ */
+static int __init ow_init(void)
+{
+	int ret;
+
+	ret = jz_register_chrdev(OW_MINOR, "ow", &ow_fops, NULL);
+	if (ret < 0) {
+		return ret;
+	}
+	__gpio_as_func1(153);
+
+	REG_OWI_CFG=0;
+	REG_OWI_CTL=0;
+	REG_OWI_STS=0;
+	REG_OWI_DAT=0;
+	REG_OWI_DIV=0;
+
+	do_interrupt_mode_test();
+	do_cpu_mode_test();
+	
+	printk(JZ_SOC_NAME": OW driver registered.\n");
+
+	return 0;
+}
+
+static void __exit ow_exit(void)
+{
+	free_irq(IRQ_OWI, NULL);
+	jz_unregister_chrdev(OW_MINOR, "ow");
+}
+
+module_init(ow_init);
+module_exit(ow_exit);
+
+MODULE_AUTHOR("Yurong Tan<yrtan@ingenic.cn>");
+MODULE_DESCRIPTION("One Wire Bus test Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/char/jzchar/jzchars.c b/drivers/char/jzchar/jzchars.c
new file mode 100644
index 0000000..de2a313
--- /dev/null
+++ b/drivers/char/jzchar/jzchars.c
@@ -0,0 +1,168 @@
+/*
+ *  linux/drivers/char/jzchar/jzchars.c
+ *
+ *  JzSOC char device family common layer.
+ */
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+
+#include <asm/jzsoc.h>
+#include "jzchars.h"
+
+LIST_HEAD(jz_char_devs);
+
+int jz_register_chrdev(unsigned char minor, const char *name,
+			 struct file_operations *fops, void *private)
+{
+	struct list_head *p;
+	jz_char_dev_t *new;
+	list_for_each(p, &jz_char_devs) {
+		jz_char_dev_t *dev = (jz_char_dev_t *)p;
+		if (minor == dev->dev_minor)
+			return -EBUSY;
+	}
+	new = (jz_char_dev_t *)kmalloc(sizeof(jz_char_dev_t), GFP_KERNEL);
+	new->dev_minor = minor;
+	new->name = (char *)name;
+	new->fops = fops;
+	new->private = private;
+	list_add_tail((struct list_head *)new, &jz_char_devs);
+	return 0;
+}
+
+int jz_unregister_chrdev(unsigned char minor, const char *name)
+{
+	struct list_head *p;
+	jz_char_dev_t *dev = NULL;
+	list_for_each(p, &jz_char_devs) {
+		jz_char_dev_t *one = (jz_char_dev_t *)p;
+		if (minor == one->dev_minor) {
+			dev = one;
+			break;
+		}
+	}
+	if (dev == NULL)
+		return -EINVAL;
+	list_del((struct list_head *)dev);
+	kfree(dev);
+	return 0;
+}
+
+static ssize_t jz_char_read(struct file *, char *, size_t, loff_t *);
+static ssize_t jz_char_write(struct file *, const char *, size_t, loff_t *);
+static ssize_t jz_char_mmap(struct file *filp,  struct vm_area_struct *vma);
+static int jz_char_open(struct inode *, struct file *);
+static int jz_char_release(struct inode *, struct file *);
+static int jz_char_ioctl(struct inode *, struct file *,
+			   unsigned int, unsigned long);
+
+static struct file_operations jz_char_fops =
+{
+	read:    jz_char_read,
+	write:   jz_char_write,
+	mmap:    jz_char_mmap,
+	ioctl:   jz_char_ioctl,
+	open:    jz_char_open,
+	release: jz_char_release
+};
+
+static int __init jz_char_family_init(void)
+{
+	printk(JZ_SOC_NAME": Char device core registered.\n");
+	return register_chrdev(JZ_CHAR_MAJOR, "JzChar", &jz_char_fops);
+}
+
+static void __exit jz_char_family_exit(void)
+{
+	printk(JZ_SOC_NAME": Char device core registered.\n");
+	unregister_chrdev(JZ_CHAR_MAJOR, "JzChar");
+}
+
+module_init(jz_char_family_init);
+module_exit(jz_char_family_exit);
+
+static int jz_char_open(struct inode *inode, struct file *filp)
+{
+	jz_char_dev_t *dev = NULL;
+	unsigned int minor = iminor(inode);       //minor extend to 20bit!
+	struct list_head *p;
+	list_for_each(p, &jz_char_devs) {
+		jz_char_dev_t *one = (jz_char_dev_t *)p;
+		if (one->dev_minor == minor) {
+			dev = one;
+			filp->private_data = dev;
+			return dev->fops->open(inode, filp);
+		}
+	}
+	printk("JzChar: No such device\n");
+	return -EINVAL;
+}
+
+static int jz_char_release(struct inode *inode, struct file *filp)
+{
+	jz_char_dev_t *dev = (jz_char_dev_t *)filp->private_data;
+	if (dev->fops->release)
+		return dev->fops->release(inode, filp);
+	return 0;
+}
+
+static int jz_char_ioctl(struct inode *inode, struct file *filp,
+			  unsigned int cmd, unsigned long arg)
+{
+	jz_char_dev_t *dev = (jz_char_dev_t *)filp->private_data;
+	if (dev->fops->ioctl)
+		return dev->fops->ioctl(inode, filp, cmd, arg);
+	return 0;
+}
+
+static ssize_t jz_char_read(struct file *filp, char *buf,
+			      size_t count, loff_t *ppos)
+{
+	jz_char_dev_t *dev = (jz_char_dev_t *)filp->private_data;
+	if (dev->fops->read)
+		return dev->fops->read(filp, buf, count, ppos);
+	return 0;
+}
+
+static ssize_t jz_char_write(struct file *filp, const char *buf,
+			      size_t count, loff_t *ppos)
+{
+	jz_char_dev_t *dev = (jz_char_dev_t *)filp->private_data;
+	if (dev->fops->write)
+		return dev->fops->write(filp, buf, count, ppos);
+	return 0;
+}
+
+static ssize_t jz_char_mmap(struct file *filp,  struct vm_area_struct *vma)
+{
+	jz_char_dev_t *dev = (jz_char_dev_t *)filp->private_data;
+	if (dev->fops->mmap)
+		return dev->fops->mmap(filp, vma);
+	return 0;
+}
+EXPORT_SYMBOL(jz_register_chrdev);
+EXPORT_SYMBOL(jz_unregister_chrdev);
diff --git a/drivers/char/jzchar/jzchars.h b/drivers/char/jzchar/jzchars.h
new file mode 100644
index 0000000..a76f2ae
--- /dev/null
+++ b/drivers/char/jzchar/jzchars.h
@@ -0,0 +1,47 @@
+#ifndef __JZ_CHARS_H__
+#define __JZ_CHARS_H__
+
+#include <linux/list.h>
+#include <linux/fs.h>
+
+#define JZ_CHAR_MAJOR		238
+
+#define UPRT_MINOR		0  // Micro printer
+#define CIM_MINOR		1  // Camera interface module
+#define TPANEL_MINOR		2  // Touchpanel
+#define KEYPAD_MINOR		3  // Keypad
+#define MEMCARD_MINOR		4  // Memory card
+#define MAGCARD_MINOR		5  // Magcard
+#define VFD_MINOR		6  // VFD
+#define POWERFAIL_MINOR		7  // Powerfail
+#define EJTAG_MINOR		8  // EJTAG emulation
+#define REMR0_MINOR		9  // Remote output receive 0
+#define REMR1_MINOR		10 // Remote output receive 1
+#define USPI_MINOR		11 // Ultra-speed SPI device
+#define SADC_MINOR		12 // SAR-ADC
+#define SLCD_MINOR		13 // Smart LCD
+
+// 32 to 47 are reserved for SCC
+#define SCC_MINOR		32
+// 48 to 63 are reserved for Camera sensor
+#define SENSOR_MINOR		48
+// 64 to 71 are for EEPROM
+#define EEPROM_MINOR_BASE       64
+// 72 for OWI
+#define OW_MINOR                72
+// 73 for TCSM_MINOR
+#define TCSM_MINOR              73
+
+typedef struct {
+	struct list_head list;
+	char *name;
+	struct file_operations *fops;
+	void *private;
+	unsigned short dev_minor;
+} jz_char_dev_t;
+
+extern int jz_register_chrdev(unsigned char minor, const char *name,
+			      struct file_operations *fops, void * private);
+extern int jz_unregister_chrdev(unsigned char minor, const char *name);
+
+#endif /*  __JZ_CHARS_H__  */
diff --git a/drivers/char/jzchar/tcsm.c b/drivers/char/jzchar/tcsm.c
new file mode 100644
index 0000000..3b524cc
--- /dev/null
+++ b/drivers/char/jzchar/tcsm.c
@@ -0,0 +1,123 @@
+/*
+ * linux/drivers/char/jzchar/tcsm.c
+ *
+ * Virtual device driver with tricky appoach to manage TCSM 
+ *
+ * Copyright (C) 2006  Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/spinlock.h>
+
+#include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
+
+#include <asm/irq.h>
+#include <asm/thread_info.h>
+#include <asm/uaccess.h>
+#include <asm/jzsoc.h>
+
+#include "jzchars.h"
+
+MODULE_AUTHOR("Jianli Wei<jlwei@ingenic.cn>");
+MODULE_DESCRIPTION("Virtual Driver of TCSM");
+MODULE_LICENSE("GPL");
+
+/*
+ * fops routines
+ */
+
+static int tcsm_open(struct inode *inode, struct file *filp);
+static int tcsm_release(struct inode *inode, struct file *filp);
+static ssize_t tcsm_read(struct file *filp, char *buf, size_t size, loff_t *l);
+static ssize_t tcsm_write(struct file *filp, const char *buf, size_t size, loff_t *l);
+static int tcsm_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);
+
+static struct file_operations tcsm_fops = 
+{
+	open:		tcsm_open,
+	release:	tcsm_release,
+	read:		tcsm_read,
+	write:		tcsm_write,
+	ioctl:		tcsm_ioctl,
+};
+
+static int tcsm_open(struct inode *inode, struct file *filp)
+{
+  struct pt_regs *info = task_pt_regs(current);
+
+  info->cp0_status &= ~0x10;// clear UM bit
+  info->cp0_status |= 0x08000000; // set RP bit   a tricky
+
+  return 0;
+}
+
+static int tcsm_release(struct inode *inode, struct file *filp)
+{
+  struct pt_regs *info = task_pt_regs(current);
+
+  info->cp0_status |= 0x10;// set UM bit
+  info->cp0_status &= ~0x08000000; // clear RP bit  a tricky
+
+  return 0;
+}
+
+static ssize_t tcsm_read(struct file *filp, char *buf, size_t size, loff_t *l)
+{
+	printk("tcsm: read is not implemented\n");
+	return -1;
+}
+
+static ssize_t tcsm_write(struct file *filp, const char *buf, size_t size, loff_t *l)
+{
+	printk("tcsm: write is not implemented\n");
+	return -1;
+}
+
+static int tcsm_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	printk("tcsm: ioctl is not implemented\n");
+	return ret;
+}
+
+/*
+ * Module init and exit
+ */
+
+static int __init tcsm_init(void)
+{
+	int ret;
+
+	ret = jz_register_chrdev(TCSM_MINOR, "tcsm", &tcsm_fops, NULL);
+	if (ret < 0) {
+		return ret;
+	}
+
+	printk(JZ_SOC_NAME": Virtual Driver of TCSM registered.\n");
+	return 0;
+}
+
+static void __exit tcsm_exit(void)
+{
+	jz_unregister_chrdev(TCSM_MINOR, "tcsm");
+}
+
+module_init(tcsm_init);
+module_exit(tcsm_exit);
diff --git a/drivers/char/rtc_jz.c b/drivers/char/rtc_jz.c
new file mode 100644
index 0000000..60f7479
--- /dev/null
+++ b/drivers/char/rtc_jz.c
@@ -0,0 +1,619 @@
+/*
+ * Jz OnChip Real Time Clock interface for Linux
+ *
+ * NOTE: we need to wait rtc write ready before read or write RTC registers.
+ *
+ */
+
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+
+#include <linux/rtc.h>			/* get the user-level API */
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+#include "rtc_jz.h"
+
+
+char sbin_rtc_alarm_handler_path[] = "/sbin/rtcalarm";
+//call_usermodehelper(char *path, char **argv, char **envp, int wait)
+//extern int call_usermodehelper(char *path, char **argv, char **envp);
+
+extern spinlock_t rtc_lock;
+
+static int rtc_ioctl(struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg);
+
+
+static void get_rtc_time (struct rtc_time *rtc_tm);
+static int  set_rtc_time (struct rtc_time *rtc_tm);
+static void get_rtc_alm_time (struct rtc_time *alm_tm);
+static int  set_rtc_alm_time (struct rtc_time *alm_tm);
+
+static void set_rtc_irq_bit(int bit);
+static void mask_rtc_irq_bit(int bit);
+
+static unsigned int rtc_status = 0;
+static unsigned int epoch = 1900;
+
+static void get_rtc_time(struct rtc_time *rtc_tm)
+{
+	unsigned long lval;
+	struct rtc_time ltm;
+
+	spin_lock_irq(&rtc_lock);
+	while ( !__rtc_write_ready() ) ;
+	lval = REG_RTC_RSR;
+	rtc_time_to_tm(lval, &ltm);
+	if(rtc_valid_tm(&ltm) == 0) {
+		/* is valid */
+		rtc_tm->tm_sec = ltm.tm_sec;
+		rtc_tm->tm_min = ltm.tm_min;
+		rtc_tm->tm_hour = ltm.tm_hour;
+		rtc_tm->tm_mday = ltm.tm_mday;
+		rtc_tm->tm_wday = ltm.tm_wday;
+		rtc_tm->tm_mon = ltm.tm_mon;
+		rtc_tm->tm_year = ltm.tm_year;
+	} else {
+		printk("invlaid data / time!\n");
+	}
+	spin_unlock_irq(&rtc_lock);
+}
+
+static int set_rtc_time(struct rtc_time *rtc_tm)
+{
+	unsigned long lval;
+
+	rtc_tm_to_time(rtc_tm, &lval);
+
+	spin_lock_irq(&rtc_lock);
+	while ( !__rtc_write_ready() ) ;
+	REG_RTC_RSR = lval;
+
+	spin_unlock_irq(&rtc_lock);
+
+	return 0;
+
+}
+
+static void get_rtc_alm_time(struct rtc_time *alm_tm)
+{ 
+	unsigned long lval;
+	struct rtc_time altm;
+
+	spin_lock_irq(&rtc_lock);
+	while ( !__rtc_write_ready() ) ;
+	lval = REG_RTC_RSAR;
+	rtc_time_to_tm(lval, &altm);
+	if(rtc_valid_tm(&altm) == 0) {
+		/* is valid */
+		alm_tm->tm_sec = altm.tm_sec;
+		alm_tm->tm_min = altm.tm_min;
+		alm_tm->tm_hour = altm.tm_hour;
+		alm_tm->tm_mday = altm.tm_mday;
+		alm_tm->tm_wday = altm.tm_wday;
+		alm_tm->tm_mon = altm.tm_mon;
+		alm_tm->tm_year = altm.tm_year;
+	} else {
+		printk("invlaid data / time in Line:%d!\n",__LINE__);
+	}
+	spin_unlock_irq(&rtc_lock);
+}
+
+static int set_rtc_alm_time(struct rtc_time *alm_tm)
+{
+	unsigned long lval;
+
+	rtc_tm_to_time(alm_tm, &lval);
+
+	spin_lock_irq(&rtc_lock);
+	while ( !__rtc_write_ready() ) ;
+	REG_RTC_RSAR = lval;
+
+	while ( !__rtc_write_ready() ) ; /* set alarm function */
+	if ( !((REG_RTC_RCR>>2) & 0x1) ) {
+		while ( !__rtc_write_ready() ) ;
+		__rtc_enable_alarm();
+	}
+
+	while ( !__rtc_write_ready() ) ;
+	if ( !(REG_RTC_RCR & RTC_RCR_AIE) ) { /* Enable alarm irq */
+		__rtc_enable_alarm_irq();
+	}
+
+	spin_unlock_irq(&rtc_lock);
+
+	return 0;
+}
+
+static void get_rtc_wakeup_alarm(struct rtc_wkalrm *wkalm)
+{
+	int enabled, pending;
+
+	get_rtc_alm_time(&wkalm->time);
+
+	spin_lock_irq(&rtc_lock);
+	while ( !__rtc_write_ready() ) ;
+	enabled = (REG_RTC_HWCR & 0x1);
+	pending = 0;
+	if ( enabled ) {
+		if ( (u32)REG_RTC_RSAR > (u32)REG_RTC_RSR ) /* 32bit val */
+			pending = 1;
+	}
+
+	wkalm->enabled = enabled;
+	wkalm->pending = pending;
+	spin_unlock_irq(&rtc_lock);
+}
+
+static int set_rtc_wakeup_alarm(struct rtc_wkalrm *wkalm)
+{
+	int enabled;
+	//int pending;
+
+	enabled = wkalm->enabled;
+	//pending = wkalm->pending; /* Fix me, what's pending mean??? */
+
+	while ( !__rtc_write_ready() ) ; /* set wakeup alarm enable */
+	if ( enabled != (REG_RTC_HWCR & 0x1) ) {
+		while ( !__rtc_write_ready() ) ;
+		REG_RTC_HWCR = (REG_RTC_HWCR & ~0x1) | enabled;
+	}
+	while ( !__rtc_write_ready() ) ; /* set alarm function */
+	if ( enabled != ((REG_RTC_RCR>>2) & 0x1) ) {
+		while ( !__rtc_write_ready() ) ;
+		REG_RTC_RCR = (REG_RTC_RCR & ~(1<<2)) | (enabled<<2);
+	}
+
+	if ( !enabled )		/* if disabled wkalrm, rturn.  */
+	{
+		return 0;
+	}
+
+	while ( !__rtc_write_ready() ) ;
+	if ( !(REG_RTC_RCR & RTC_RCR_AIE) ) { /* Enable alarm irq */
+		__rtc_enable_alarm_irq();
+	}
+
+	set_rtc_alm_time(&wkalm->time);
+
+	return 0;
+}
+
+
+static void set_rtc_irq_bit( int bit )
+{
+	spin_lock_irq(&rtc_lock);
+
+	while ( !__rtc_write_ready() ) ;
+	REG_RTC_RCR |= (1<<bit);
+
+	spin_unlock_irq(&rtc_lock);
+}
+
+static void mask_rtc_irq_bit( int bit )
+{
+	spin_lock_irq(&rtc_lock);
+
+	while ( !__rtc_write_ready() ) ;
+	REG_RTC_RCR &= ~(1<<bit);
+
+
+	spin_unlock_irq(&rtc_lock);
+}
+
+static int rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		     unsigned long arg)
+{
+	struct rtc_time wtime; 
+
+	switch (cmd) {
+	case RTC_AIE_OFF:	/* Mask alarm int. enab. bit	*/
+	{
+		mask_rtc_irq_bit(RTC_AIE);
+		return 0;
+	}
+	case RTC_AIE_ON:	/* Allow alarm interrupts.	*/
+	{
+		__rtc_clear_alarm_flag();
+		set_rtc_irq_bit(RTC_AIE);
+		return 0;
+	}
+	case RTC_1HZIE_OFF:	/* Mask 1Hz int. enab. bit	*/
+	{
+		mask_rtc_irq_bit(RTC_1HZIE);
+		return 0;
+	}
+	case RTC_1HZIE_ON:	/* Allow 1Hz interrupts.	*/
+	{
+		__rtc_clear_1Hz_flag();
+		set_rtc_irq_bit(RTC_1HZIE);
+		return 0;
+	}
+	case RTC_ALM_OFF:	/* Disable rtc function, this may not be used any time.*/
+	{
+		mask_rtc_irq_bit(RTC_ALM_EN);
+		return 0;
+	}
+	case RTC_ALM_ON:	/* Enable rtc function, this may not be used any time.*/
+	{
+		set_rtc_irq_bit(RTC_ALM_EN);
+		return 0;
+	}
+	case RTC_DISABLED:	/* Disable rtc function, this may not be used any time.*/
+	{
+		mask_rtc_irq_bit(RTC_EN);
+		return 0;
+	}
+	case RTC_ENABLED:	/* Enable rtc function, this may not be used any time.*/
+	{
+		set_rtc_irq_bit(RTC_EN);
+		return 0;
+	}
+
+	case RTC_ALM_READ:	/* Read the present alarm time */
+		/*
+		 * This returns a struct rtc_time. Reading >= 0xc0
+		 * means "don't care" or "match all". Only the tm_hour,
+		 * tm_min, and tm_sec values are filled in.
+		 */
+		
+		get_rtc_alm_time(&wtime);
+		return copy_to_user((void *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;
+
+	case RTC_ALM_SET:	/* Store a time into the alarm */
+	{
+		struct rtc_time alm_tm;
+
+		if (copy_from_user(&alm_tm, (struct rtc_time*)arg,
+				   sizeof(struct rtc_time)))
+			return -EFAULT;
+		if(rtc_valid_tm(&alm_tm) != 0) {
+			printk("invalid time set in Line:%d! \n",__LINE__);
+			return -EFAULT;
+		}
+		
+		return set_rtc_alm_time(&alm_tm);
+	}
+	case RTC_RD_TIME:	/* Read the time/date from RTC	*/
+		get_rtc_time(&wtime);
+		return copy_to_user((void *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;
+	case RTC_SET_TIME:	/* Set the RTC */
+	{
+		struct rtc_time rtc_tm;
+
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		if (copy_from_user(&rtc_tm, (struct rtc_time*)arg,
+				   sizeof(struct rtc_time)))
+			return -EFAULT;
+		if(rtc_valid_tm(&rtc_tm) != 0) {
+			printk("invalid time set in Line:%d! \n",__LINE__);
+			return -EFAULT;
+		}
+	      
+		return set_rtc_time(&rtc_tm);
+	}
+	case RTC_EPOCH_READ:	/* Read the epoch.	*/
+		return put_user (epoch, (unsigned long *)arg);
+	case RTC_EPOCH_SET:	/* Set the epoch.	*/
+		/* 
+		 * There were no RTC clocks before 1900.
+		 */
+		if (arg < 1900)
+			return -EINVAL;
+
+		if (!capable(CAP_SYS_TIME))
+			return -EACCES;
+
+		epoch = arg;
+		return 0;
+	case RTC_WKALM_SET:	/* Wake alarm set.	*/
+	{
+		struct rtc_wkalrm wkalrm;
+
+		if (copy_from_user(&wkalrm, (struct rtc_wkalrm*)arg,
+				   sizeof(struct rtc_wkalrm)))
+			return -EFAULT;
+		return set_rtc_wakeup_alarm(&wkalrm);
+	}
+	case RTC_WKALM_RD:	/* Wake alarm read.	*/
+	{
+		struct rtc_wkalrm wkalrm;
+		get_rtc_wakeup_alarm(&wkalrm);
+		return copy_to_user((void *)arg, &wkalrm, sizeof(struct rtc_wkalrm)) ? -EFAULT : 0;
+	}
+	/* set power down: shut down the machine. */
+	case RTC_POWER_DOWN:	/* enter HIBERNATE mode */
+		dprintk("Power down. Bye....\n");
+		while ( !__rtc_write_ready() ) ;
+		REG_RTC_HCR = 0x1;
+		return 0;
+#ifdef DEBUG
+	case RTC_PRINT_REG:	/* Print RTC registers */
+		print_rtc_registers();
+		return 0;
+#endif
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ *	We enforce only one user at a time here with the open/close.
+ *	Also clear the previous interrupt data on an open, and clean
+ *	up things on a close.
+ */
+
+/* We use rtc_lock to protect against concurrent opens. So the BKL is not
+ * needed here. Or anywhere else in this driver. */
+static int rtc_open(struct inode *inode, struct file *file)
+{
+	spin_lock_irq (&rtc_lock);
+
+	if(rtc_status)
+		goto out_busy;
+
+	rtc_status = 1;
+
+	spin_unlock_irq (&rtc_lock);
+	return 0;
+
+out_busy:
+	spin_unlock_irq (&rtc_lock);
+	return -EBUSY;
+}
+
+static int rtc_release(struct inode *inode, struct file *file)
+{
+
+	rtc_status = 0;
+	/* No need for locking -- nobody else can do anything until this rmw is
+	 * committed, and no timer is running. */
+	return 0;
+}
+
+/*
+ *	The various file operations we support.
+ */
+
+static struct file_operations rtc_fops = {
+	owner:		THIS_MODULE,
+	llseek:		no_llseek,
+	ioctl:		rtc_ioctl,
+	open:		rtc_open,
+	release:	rtc_release,
+};
+
+
+static void run_sbin_rtc_alarm( void )
+{
+	int i;
+	char *argv[2], *envp[3];
+
+	if (!sbin_rtc_alarm_handler_path[0])
+		return;
+
+	print_dbg(": sbin_rtc_alarm_handler_path=%s\n", sbin_rtc_alarm_handler_path);
+
+	i = 0;
+	argv[i++] = sbin_rtc_alarm_handler_path;
+	argv[i] = 0;
+
+	/* minimal command environment */
+	i = 0;
+	envp[i++] = "HOME=/";
+	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	
+	/* other stuff we want to pass to /sbin/hotplug */
+
+	envp[i] = 0;
+
+	call_usermodehelper (argv [0], argv, envp, 0);
+}
+
+static void rtc_alarm_task_handler(struct work_struct *work)
+{
+	run_sbin_rtc_alarm();
+}
+
+static struct work_struct rtc_alarm_task;
+
+static irqreturn_t jz_rtc_interrupt(int irq, void *dev_id)
+{
+	REG_RTC_HCR = 0x0;
+	printk("%s:%s:%d\n",__FILE__,__FUNCTION__,__LINE__);
+	spin_lock_irq(&rtc_lock);
+
+	if ( __rtc_get_1Hz_flag() ) {
+		while ( !__rtc_write_ready() ) ;
+		__rtc_clear_1Hz_flag();
+		dprintk("RTC 1Hz interrupt occur.\n");
+	}
+
+	if ( __rtc_get_alarm_flag() ) {	/* rtc alarm interrupt */
+		while ( !__rtc_write_ready() ) ;
+		__rtc_clear_alarm_flag();
+		dprintk("RTC alarm interrupt occur.\n");
+		//schedule_task( &rtc_alarm_task );
+		schedule_work( &rtc_alarm_task );
+	}
+	spin_unlock_irq(&rtc_lock);
+
+	return IRQ_HANDLED;
+}
+
+
+#define RTC_MINOR   135
+
+static struct miscdevice rtc_dev=
+{
+	RTC_MINOR,
+	"rtc",
+	&rtc_fops
+};
+
+/* The divider is decided by the RTC clock frequency. */
+#define RTC_FREQ_DIVIDER	(32768 - 1)
+#define ms2clycle(x)  (((x) * RTC_FREQ_DIVIDER) / 1000)
+
+#define RTC_CFG (((unsigned int)('R') << 24) | ((unsigned int)('T') << 16) | ((unsigned int)('C') << 8))
+#define CAL_RTC_CFG(x)				\
+  ({						\
+    unsigned int x1,x2,x3;			\
+    x1 = ((x) >> 24) & 0xff;			\
+    x2 = ((x) >> 16) & 0xff;			\
+    x3 = ((x) >> 8) & 0xff;			\
+  ((x & (~0xff)) | (x1 + x2 + x3));		\
+  })
+#define SET_RTC_REG(reg,x)				\
+  do{							\
+    unsigned int rcr;					\
+    do{							\
+      rcr = reg;					\
+    }while(rcr != reg);					\
+    rcr |= (x);						\
+    while ( !__rtc_write_ready());			\
+    reg = rcr;						\
+  }while(0);
+
+#define CLR_RTC_REG(reg,x)				\
+  do{							\
+    unsigned int rcr;					\
+    do{							\
+      rcr = reg;					\
+    }while(rcr != reg);					\
+    rcr &= ~(x);					\
+    while ( !__rtc_write_ready());			\
+    reg = rcr;						\
+  }while(0);
+
+#define OUT_RTC_REG(reg,x)				\
+  do{							\
+    while ( !__rtc_write_ready());			\
+    reg = x;						\
+  }while(0);
+
+#define IN_RTC_REG(reg)					\
+  ({							\
+    unsigned int dat;					\
+    do{							\
+      dat = reg;					\
+    }while(reg != dat);					\
+    dat;						\
+  })
+
+
+ /* Default time for the first-time power on */
+static struct rtc_time default_tm = {
+	.tm_year = (2009 - 1900), // year 2009
+	.tm_mon = (10 - 1),       // month 10
+	.tm_mday = 1,             // day 1
+	.tm_hour = 12,
+	.tm_min = 0,
+	.tm_sec = 0
+}; 
+static void rtc_first_power_on()
+{
+	unsigned int rcr,cfc,hspr,rgr_1hz;
+	/*
+	 * When we are powered on for the first time, init the rtc and reset time.
+	 *
+	 * For other situations, we remain the rtc status unchanged.
+	 */
+	 
+	__cpm_select_rtcclk_rtc();
+
+	//unsigned int ppr = IN_RTC_REG(REG_RTC_HWRSR);   
+	cfc = 0x12345678;//CAL_RTC_CFG(RTC_CFG);
+	hspr = IN_RTC_REG(REG_RTC_HSPR);
+	rgr_1hz  = IN_RTC_REG(REG_RTC_RGR) & RTC_RGR_NC1HZ_MASK;
+	
+	if((hspr != cfc) || (rgr_1hz != RTC_FREQ_DIVIDER))
+	{
+	//if ((ppr >> RTC_HWRSR_PPR) & 0x1) {
+		/* We are powered on for the first time !!! */
+
+		printk("jz4750-rtc: rtc status reset by power-on\n");
+
+		/* init rtc status */
+		
+		rcr = IN_RTC_REG(REG_RTC_RCR);
+		rcr &= ~(RTC_RCR_1HZ | RTC_RCR_1HZIE | RTC_RCR_AF | RTC_RCR_AE | RTC_RCR_AIE);
+		
+
+		/* Set 32768 rtc clocks per seconds */
+		OUT_RTC_REG(REG_RTC_RGR,RTC_FREQ_DIVIDER);
+
+		/* Set minimum wakeup_n pin low-level assertion time for wakeup: 100ms */
+
+		OUT_RTC_REG(REG_RTC_HWFCR,ms2clycle(100) << RTC_HWFCR_BIT);
+
+		//REG_RTC_HWFCR = (100 << RTC_HWFCR_BIT);
+		//while ( !__rtc_write_ready());
+	
+		/* Set reset pin low-level assertion time after wakeup: must  > 60ms */
+		//REG_RTC_HRCR = (60 << RTC_HRCR_BIT);
+		//while ( !__rtc_write_ready());
+
+		OUT_RTC_REG(REG_RTC_HRCR,ms2clycle(60) <<  RTC_HRCR_BIT);
+                /* Reset to the default time */
+		set_rtc_time( &default_tm);
+		/* start rtc */
+		rcr |= RTC_RCR_RTCE;
+		OUT_RTC_REG(REG_RTC_RCR,rcr);
+		OUT_RTC_REG(REG_RTC_HSPR,cfc);
+		/* select external 32K crystal as RTC clock */
+	}
+}
+int __init Jz_rtc_init(void)
+{
+
+	printk("jz4750-rtc: Jz_rtc_init\n");
+	rtc_first_power_on();
+	INIT_WORK(&rtc_alarm_task, rtc_alarm_task_handler);
+
+	/* Enabled rtc function, enable rtc alarm function */
+	while ( !__rtc_write_ready() ) ; /* need we wait for WRDY??? */
+	if ( !(REG_RTC_RCR & RTC_RCR_RTCE) || !(REG_RTC_RCR &RTC_RCR_AE) ) {
+		REG_RTC_RCR |= RTC_RCR_AE | RTC_RCR_RTCE;
+	}
+	/* clear irq flags */
+	__rtc_clear_1Hz_flag();
+	/* In a alarm reset, we expect a alarm interrupt. 
+	 * We can do something in the interrupt handler.
+	 * So, do not clear alarm flag.
+	 */
+/*	__rtc_clear_alarm_flag(); */
+
+	if (request_irq(IRQ_RTC, jz_rtc_interrupt, 0, "rtc", NULL) < 0)
+		return -EBUSY;
+
+	misc_register(&rtc_dev);
+
+	printk("JzSOC onchip RTC installed !!!\n");
+	return 0;
+
+}
+
+void __exit Jz_rtc_exit (void)
+{
+	misc_deregister(&rtc_dev);
+	free_irq (IRQ_RTC, NULL);
+}
+
+module_init(Jz_rtc_init);
+module_exit(Jz_rtc_exit);
+
diff --git a/drivers/char/rtc_jz.h b/drivers/char/rtc_jz.h
new file mode 100644
index 0000000..6c754d6
--- /dev/null
+++ b/drivers/char/rtc_jz.h
@@ -0,0 +1,74 @@
+#ifndef __RTC_JZ_H__
+#define __RTC_JZ_H__
+
+//#define DEBUG 		1
+#undef DEBUG
+
+#ifdef DEBUG
+#define dprintk(x...)	printk(x)
+#define print_dbg(f, arg...) \
+		printk("%s, %s[%d]:" f , __FUNCTION__, __FILE__, __LINE__ , ##arg )
+#else
+#define dprintk(x...)
+#define print_dbg(n, arg...)
+#endif
+
+
+#ifdef DEBUG
+
+static void print_rtc_time( struct rtc_time * tm )
+{
+	printk("%02d%02d-%02d:%02d:%02d-%d\n", tm->tm_mon, tm->tm_mday, 
+	       tm->tm_hour, tm->tm_min, tm->tm_sec, tm->tm_year);
+	printk("sec:\t%d\n", tm->tm_sec);
+	printk("min:\t%d\n", tm->tm_min);
+	printk("hour:\t%d\n", tm->tm_hour);
+	printk("mday:\t%d\n", tm->tm_mday);
+	printk("mon:\t%d\n", tm->tm_mon);
+	printk("year:\t%d\n", tm->tm_year);
+	printk("wday:\t%d\n", tm->tm_wday);
+	printk("yday:\t%d\n", tm->tm_yday);
+	printk("isdst:\t%d\n", tm->tm_isdst);
+
+}
+
+static void print_rtc_registers( void )
+{
+	while ( !__rtc_write_ready() ) ; 
+	printk("REG_RTC_RCR:\t 0x%8.8x\n", REG_RTC_RCR );
+	printk("REG_RTC_RSR:\t 0x%8.8x\n", REG_RTC_RSR );
+	printk("REG_RTC_RSAR:\t 0x%8.8x\n", REG_RTC_RSAR );
+	printk("REG_RTC_RGR:\t 0x%8.8x\n", REG_RTC_RGR );
+	printk("REG_RTC_HCR:\t 0x%8.8x\n", REG_RTC_HCR );
+	printk("REG_RTC_HWFCR:\t 0x%8.8x\n", REG_RTC_HWFCR );
+	printk("REG_RTC_HRCR:\t 0x%8.8x\n", REG_RTC_HRCR );
+	printk("REG_RTC_HWCR:\t 0x%8.8x\n", REG_RTC_HWCR );
+	printk("REG_RTC_HWRSR:\t 0x%8.8x\n", REG_RTC_HWRSR );
+	printk("REG_RTC_HSPR:\t 0x%8.8x\n", REG_RTC_HSPR );
+}
+
+#define RTC_PRINT_REG	_IOR('p', 0x12, unsigned long)/* Set power down */
+#endif /* #ifdef DEBUG */
+
+
+/*
+ * JZSOC ioctl calls that are permitted to the /dev/rtc interface
+ */
+
+#define RTC_ENABLED	_IO('p', 0x11)	/* enable rtc			*/
+#define RTC_DISABLED	_IO('p', 0x12)	/* disable rtc			*/
+#define RTC_ALM_ON	_IO('p', 0x13)	/* enable rtc			*/
+#define RTC_ALM_OFF	_IO('p', 0x14)	/* disable rtc			*/
+#define RTC_1HZIE_ON	_IO('p', 0x15)	/* 1Hz int. enable on		*/
+#define RTC_1HZIE_OFF	_IO('p', 0x16)	/* ... off			*/
+
+#define RTC_POWER_DOWN	_IOR('p', 0x11, unsigned long)/* Set power down */
+
+/* Registers define */
+/* RTC Control register */
+#define RTC_AIE 	3	/* jz4740_06_rtc_spec.pdf, RTC Control Register */
+#define RTC_1HZIE 	5	/* ... */
+#define RTC_ALM_EN 	2	/* ... */
+#define RTC_EN		0	/* ... */
+
+#endif /* #define __RTC_JZ_H__ */
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index fee678f..f105b3c 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -26,7 +26,7 @@ config ARCH_REQUIRE_GPIOLIB
 
 menuconfig GPIOLIB
 	bool "GPIO Support"
-	depends on ARCH_WANT_OPTIONAL_GPIOLIB || ARCH_REQUIRE_GPIOLIB
+	depends on ARCH_WANT_OPTIONAL_GPIOLIB || ARCH_REQUIRE_GPIOLIB || JZSOC
 	select GENERIC_GPIO
 	help
 	  This enables GPIO support through the generic GPIO library.
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index cb9fbc8..b3b6eea 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -258,8 +258,25 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 		memset(&brq, 0, sizeof(struct mmc_blk_request));
 		brq.mrq.cmd = &brq.cmd;
 		brq.mrq.data = &brq.data;
+		brq.cmd.arg = blk_rq_pos(req);
+
+#if 0
+		if(!strcmp(mmc_hostname(card->host) ,"mmc0")){
+#if defined(CONFIG_JZ_BOOT_FROM_MSC0)
+			brq.cmd.arg = blk_rq_pos(req) + 16384;			
+#else
+			brq.cmd.arg = blk_rq_pos(req);
+#endif   
+		}
+		else
+			brq.cmd.arg = blk_rq_pos(req);
 
+#if defined( CONFIG_JZ_BOOT_FROM_MSC0)
+		brq.cmd.arg = blk_rq_pos(req) + 16384;
+#else
 		brq.cmd.arg = blk_rq_pos(req);
+#endif
+#endif
 		if (!mmc_card_blockaddr(card))
 			brq.cmd.arg <<= 9;
 		brq.cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
@@ -397,6 +414,7 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 				 * so make sure to check both the busy
 				 * indication and the card state.
 				 */
+
 			} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
 				(R1_CURRENT_STATE(cmd.resp[0]) == 7));
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 3168ebd..a913838 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1065,8 +1065,6 @@ void mmc_rescan(struct work_struct *work)
 		host->bus_ops->detect(host);
 
 	mmc_bus_put(host);
-
-
 	mmc_bus_get(host);
 
 	/* if there still is a card present, stop here */
@@ -1135,7 +1133,11 @@ out:
 void mmc_start_host(struct mmc_host *host)
 {
 	mmc_power_off(host);
+#if defined(CONFIG_JZ_SYSTEM_AT_CARD)
+	mmc_rescan(&host->detect.work);
+#else
 	mmc_detect_change(host, 0);
+#endif
 }
 
 void mmc_stop_host(struct mmc_host *host)
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 89f7a25..e5b2262 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -122,7 +122,7 @@ static int mmc_decode_csd(struct mmc_card *card)
 	 * v1.2 has extra information in bits 15, 11 and 10.
 	 */
 	csd_struct = UNSTUFF_BITS(resp, 126, 2);
-	if (csd_struct != 1 && csd_struct != 2) {
+	if (csd_struct != 1 && csd_struct != 2 && csd_struct != 3) {
 		printk(KERN_ERR "%s: unrecognised CSD structure version %d\n",
 			mmc_hostname(card->host), csd_struct);
 		return -EINVAL;
@@ -141,8 +141,20 @@ static int mmc_decode_csd(struct mmc_card *card)
 
 	e = UNSTUFF_BITS(resp, 47, 3);
 	m = UNSTUFF_BITS(resp, 62, 12);
-	csd->capacity	  = (1 + m) << (e + 2);
 
+#if 0
+	if(!strcmp(mmc_hostname(card->host) ,"mmc0")){
+#if defined(CONFIG_JZ_BOOT_FROM_MSC0)
+		csd->capacity	  = (1 + m) << (e + 2);
+		csd->capacity	  -= 16384;
+#else
+		csd->capacity	  = (1 + m) << (e + 2);			
+#endif			
+	}
+	else
+		csd->capacity	  = (1 + m) << (e + 2);			
+#endif
+	csd->capacity	  = (1 + m) << (e + 2);			
 	csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
 	csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
 	csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
@@ -222,7 +234,7 @@ static int mmc_read_ext_csd(struct mmc_card *card)
 			ext_csd[EXT_CSD_SEC_CNT + 1] << 8 |
 			ext_csd[EXT_CSD_SEC_CNT + 2] << 16 |
 			ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
-		if (card->ext_csd.sectors)
+		if (card->ext_csd.sectors > (2u * 1024 * 1024 * 1024) / 512)
 			mmc_card_set_blockaddr(card);
 	}
 
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5eac21d..e045f4a 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -110,8 +110,20 @@ static int mmc_decode_csd(struct mmc_card *card)
 
 		e = UNSTUFF_BITS(resp, 47, 3);
 		m = UNSTUFF_BITS(resp, 62, 12);
-		csd->capacity	  = (1 + m) << (e + 2);
 
+#if 0
+		if(!strcmp(mmc_hostname(card->host) ,"mmc0")){
+#if defined(CONFIG_JZ_BOOT_FROM_MSC0)
+			csd->capacity	  = (1 + m) << (e + 2);
+			csd->capacity	  -= 16384;
+#else
+			csd->capacity	  = (1 + m) << (e + 2);			
+#endif			
+		}
+		else
+			csd->capacity	  = (1 + m) << (e + 2);			
+#endif
+		csd->capacity	  = (1 + m) << (e + 2);			
 		csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
 		csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
 		csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
@@ -138,7 +150,13 @@ static int mmc_decode_csd(struct mmc_card *card)
 		csd->cmdclass	  = UNSTUFF_BITS(resp, 84, 12);
 
 		m = UNSTUFF_BITS(resp, 48, 22);
+
+#if defined(CONFIG_JZ_BOOT_FROM_MSC0)
+		csd->capacity     = (1 + m) << 10;
+		csd->capacity	 -= 16384;
+#else
 		csd->capacity     = (1 + m) << 10;
+#endif
 
 		csd->read_blkbits = 9;
 		csd->read_partial = 0;
@@ -269,9 +287,11 @@ static int mmc_switch_hs(struct mmc_card *card)
 		goto out;
 
 	if ((status[16] & 0xF) != 1) {
+#if 0
 		printk(KERN_WARNING "%s: Problem switching card "
 			"into high-speed mode!\n",
 			mmc_hostname(card->host));
+#endif
 	} else {
 		mmc_card_set_highspeed(card);
 		mmc_set_timing(card->host, MMC_TIMING_SD_HS);
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 2e13b94..f31a6da 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -4,6 +4,119 @@
 
 comment "MMC/SD/SDIO Host Controller Drivers"
 
+config MMC_JZSOC
+	tristate "Ingenic MMC/SD/SDIO controller support"
+	depends on SOC_JZ4750D
+	default y
+	help
+	  this selects Ingenic MMC/SD/SDIO controller support, it was automatically selected
+
+config JZ_MSC0
+	tristate "JZ SOC Multimedia/SD/SDIO host controller 0 support"
+	depends on (SOC_JZ4750D && (!MTD_NAND))
+	help
+	  this selects the Ingenic Multimedia/SD/SDIO host controller 0.
+	  If you have a Ingenic platform with a Multimedia Card slot,
+	  Say Y or M here.
+
+	  If unsure, say N.
+
+choice
+	depends on JZ_MSC0
+	prompt "Multimedia/SD/SDIO controller 0 Bus Width"
+	default JZ_MSC0_BUS_4
+	help
+	  This defines the bus width of the Ingenic Multimedia/SD/SDIO host controller
+
+config JZ_MSC0_BUS_1
+	bool "1-bit Bus"
+	help
+	  1-bit Multimedia/SD/SDIO Card Bus
+
+config JZ_MSC0_BUS_4
+	bool "4-bit Bus"
+	help
+	  4-bit Multimedia/SD/SDIO Card Bus
+
+config JZ_MSC0_BUS_8
+	bool "8-bit Bus"
+	help
+	  8-bit Multimedia/SD/SDIO Card Bus
+	  If the controller support 8-bit bus, select this.
+
+	  If unsure, use the default(4-bit) maybe the best choice
+endchoice
+
+config JZ_MSC0_SDIO_SUPPORT
+	bool "SDIO support for Multimedia/SD/SDIO controller 0"
+	depends on JZ_MSC0
+	depends on !JZ_SYSTEM_AT_CARD
+	help
+	  SDIO support for MSC0.
+
+	  If unsure,say N.
+
+config JZ_MSC1
+	tristate "JZ SOC Multimedia/SD/SDIO host controller 1 support"
+	depends on MMC_JZSOC
+	help
+	  this selects the Ingenic Multimedia/SD/SDIO host controller 1.
+	  If you have a Ingenic platform with a Multimedia Card slot,
+	  Say Y or M here.
+
+	  If unsure, say N.
+
+choice
+	depends on JZ_MSC1
+	prompt "Multimedia/SD/SDIO controller 1 Bus Width"
+	default JZ_MSC1_BUS_4
+	help
+	  This defines the bus width of the Ingenic Multimedia/SD/SDIO host controller
+
+config JZ_MSC1_BUS_1
+	bool "1-bit Bus"
+	help
+	  1-bit Multimedia/SD/SDIO Card Bus
+
+config JZ_MSC1_BUS_4
+	bool "4-bit Bus"
+	help
+	  4-bit Multimedia/SD/SDIO Card Bus
+
+config JZ_MSC1_BUS_8
+	bool "8-bit Bus"
+	help
+	  8-bit Multimedia/SD/SDIO Card Bus
+	  If the controller support 8-bit bus, select this.
+
+	  If unsure, use the default(4-bit) maybe the best choice
+endchoice
+
+config JZ_MSC1_SDIO_SUPPORT
+	bool "SDIO support for Multimedia/SD/SDIO controller 1"
+	depends on JZ_MSC1
+	help
+	  SDIO support for MSC1.
+
+	  If unsure,say N.
+
+config JZ_SYSTEM_AT_CARD
+	bool "System at MMC/SD  support"
+	depends on SOC_JZ4750D
+	depends on JZ_MSC0
+	help
+	  This selects uboot kernel fs at the Multimedia/SD/SDIO Card.
+
+	  If unsure,say N.
+
+config JZ_RECOVERY_SUPPORT
+    tristate "Ingenic Liunx Recovery tool support for card system"
+    depends on SOC_JZ4750D
+    depends on JZ_SYSTEM_AT_CARD
+    default n
+    help
+      This selects Ingenic Liunx Recovery tool support.
+
 config MMC_ARMMMCI
 	tristate "ARM AMBA Multimedia Card Interface support"
 	depends on ARM_AMBA
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index f480397..133f877 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -6,6 +6,8 @@ ifeq ($(CONFIG_MMC_DEBUG),y)
 	EXTRA_CFLAGS		+= -DDEBUG
 endif
 
+obj-$(CONFIG_MMC_JZSOC)       += jzmmc/
+
 obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
 obj-$(CONFIG_MMC_IMX)		+= imxmmc.o
diff --git a/drivers/mmc/host/jzmmc/Makefile b/drivers/mmc/host/jzmmc/Makefile
new file mode 100644
index 0000000..dbc06a6
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for MMC/SD host controller drivers
+#
+
+obj-$(CONFIG_MMC_JZSOC) += jz_mmc_main.o \
+			jz_mmc_controller.o \
+			jz_mmc_msc.o \
+			jz_mmc_dma.o \
+			jz_mmc_pio.o \
+			jz_mmc_gpio.o
diff --git a/drivers/mmc/host/jzmmc/include/jz_mmc_controller.h b/drivers/mmc/host/jzmmc/include/jz_mmc_controller.h
new file mode 100644
index 0000000..19eba31
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/include/jz_mmc_controller.h
@@ -0,0 +1,42 @@
+/*
+ *  drivers/mmc/host/jz_mmc_controller.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#ifndef __JZ_MMC_CONTROLLER_H__
+#define __JZ_MMC_CONTROLLER_H__
+
+#include "jz_mmc_host.h"
+#include "jz_mmc_gpio.h"
+#include "jz_mmc_msc.h"
+#include "jz_mmc_dma.h"
+
+struct jz_mmc_functions {
+	void (*deinit) (struct jz_mmc_host *, struct platform_device *);
+	int (*transmit_data) (struct jz_mmc_host *);
+	void (*execute_cmd) (struct jz_mmc_host *);
+	void (*set_clock) (struct jz_mmc_host *, int);
+	void (*msc_deinit) (struct jz_mmc_host *);
+	void (*gpio_deinit) (struct jz_mmc_host *, struct platform_device *);
+	void (*dma_deinit) (struct jz_mmc_host *);
+};
+
+struct jz_mmc_controller {
+
+	struct jz_mmc_msc msc;		// msc
+	struct jz_mmc_dma dma;		// dma
+	struct jz_mmc_gpio gpio;	// gpio
+
+	int (*init) (struct jz_mmc_controller *, struct jz_mmc_host *,
+				struct platform_device *);
+	struct jz_mmc_functions functions;
+};
+
+int controller_register(struct jz_mmc_controller *, struct jz_mmc_host *);
+
+#endif /* __JZ_MMC_CONTROLLER_H__ */
diff --git a/drivers/mmc/host/jzmmc/include/jz_mmc_dma.h b/drivers/mmc/host/jzmmc/include/jz_mmc_dma.h
new file mode 100644
index 0000000..431d94e
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/include/jz_mmc_dma.h
@@ -0,0 +1,31 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/dma/jz_mmc_dma.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#ifndef __JZ_MMC_DMA_H__
+#define __JZ_MMC_DMA_H__
+
+#include "jz_mmc_host.h"
+
+struct jz_mmc_dma {
+
+	int (*init) (struct jz_mmc_host *);
+	void (*deinit) (struct jz_mmc_host *);
+};
+
+int jz_mmc_dma_register(struct jz_mmc_dma *dma);
+
+void jz_mmc_start_dma(struct jz_mmc_host *host);
+void jz_mmc_stop_dma(struct jz_mmc_host *host);
+
+void jz_mmc_start_normal_dma(struct jz_mmc_host *host, unsigned long phyaddr, int count, int mode, int ds);
+void jz_mmc_start_scatter_dma(int chan, struct jz_mmc_host *host,
+			      struct scatterlist *sg, unsigned int sg_len, int mode);
+
+#endif /* __JZ_MMC_DMA_H__ */
diff --git a/drivers/mmc/host/jzmmc/include/jz_mmc_gpio.h b/drivers/mmc/host/jzmmc/include/jz_mmc_gpio.h
new file mode 100644
index 0000000..faeefd5
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/include/jz_mmc_gpio.h
@@ -0,0 +1,33 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/gpio/jz_mmc_gpio.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#ifndef __JZ_MMC_GPIO_H__
+#define __JZ_MMC_GPIO_H__
+
+#include "jz_mmc_host.h"
+#include <linux/platform_device.h>
+
+#ifndef __JZ_MMC_HOST_H__
+#error "!!!!!!!!!!!!!"
+#endif
+
+//struct jz_mmc_host test;
+//int t = test.dma.len;
+
+struct jz_mmc_gpio {
+
+	int (*init) (struct jz_mmc_host *, struct platform_device *);
+	void (*deinit) (struct jz_mmc_host *, struct platform_device *);
+};
+
+int jz_mmc_gpio_register(struct jz_mmc_gpio *);
+
+#endif /* __JZ_MMC_GPIO_H__ */
+
diff --git a/drivers/mmc/host/jzmmc/include/jz_mmc_host.h b/drivers/mmc/host/jzmmc/include/jz_mmc_host.h
new file mode 100644
index 0000000..8cf7e99
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/include/jz_mmc_host.h
@@ -0,0 +1,110 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/jz_mmc_host.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#ifndef __JZ_MMC_HOST_H__
+#define __JZ_MMC_HOST_H__
+
+#include <linux/semaphore.h>
+#include <asm/jzsoc.h>
+#include <linux/device.h>
+
+#define JZ_MSC_USE_DMA 1
+//#define JZ_MSC_USE_PIO 1
+
+#ifdef JZ_MSC_USE_DMA
+#ifdef JZ_MSC_USE_PIO
+#error "MSC: You must chose one of DMA and PIO, but not both!"
+#endif
+#endif
+
+#ifdef JZ_MSC_USE_PIO
+#ifdef JZ_MSC_USE_DMA
+#error "MSC: You must chose one of DMA and PIO, but not both!"
+#endif
+#endif
+
+#define USE_DMA_DESC
+//#define USE_DMA_UNCACHE
+//#define MSC_DEBUG_DMA
+
+#define JZ_MSC_DMA_DESC jz_dma_desc_8word
+
+#define MMC_CLOCK_SLOW    400000      /* 400 kHz for initial setup */
+#define MMC_CLOCK_FAST  20000000      /* 20 MHz for maximum for normal operation */
+#define SD_CLOCK_HIGH   48000000      /* 24 MHz for SD Cards */
+#define SD_CLOCK_FAST   24000000      /* 24 MHz for SD Cards */
+#define MMC_NO_ERROR  0
+
+#define NR_SG	1
+
+#define MSC_1BIT_BUS 0
+#define MSC_4BIT_BUS 1
+#define MSC_8BIT_BUS 2
+
+#define SZ_4K                           0x00001000
+
+struct jz_mmc_host {
+	struct mmc_host *mmc;
+	struct semaphore mutex;
+
+	/* host resources */
+	//void __iomem *base;
+	unsigned int pdev_id;
+	int irq;
+	int dma_id;
+	struct jz_mmc_platform_data *plat;
+
+	/* mmc request related */
+	unsigned int cmdat;
+	struct mmc_request *curr_mrq;
+	int curr_res_type;
+
+	/* data transter related */
+	struct {
+		int len;
+		int dir;
+		int channel;
+	} dma;
+#ifdef USE_DMA_DESC
+#ifdef MSC_DEBUG_DMA
+	int num_desc;
+	int last_direction;
+#endif
+	JZ_MSC_DMA_DESC *dma_desc;
+#endif
+	wait_queue_head_t data_wait_queue;
+	volatile int data_ack;
+	volatile int data_err;
+
+#ifdef JZ_MSC_USE_PIO
+	volatile int transfer_end;
+#endif
+#if 0
+	wait_queue_head_t status_check_queue;
+	struct timer_list status_check_timer;
+	u32 status;
+	u32 st_mask;
+	int st_check_timeout;
+	int st_check_interval;
+	int en_usr_intr;
+#endif
+
+	/* card detect related */
+	volatile unsigned int eject;
+	volatile unsigned int oldstat;
+	struct delayed_work gpio_jiq_work;
+	atomic_t detect_refcnt;
+	struct timer_list timer;
+	volatile int sleeping;
+};
+
+void jz_mmc_finish_request(struct jz_mmc_host *host, struct mmc_request *mrq);
+
+#endif /* __JZ_MMC_HOST_H__ */
diff --git a/drivers/mmc/host/jzmmc/include/jz_mmc_msc.h b/drivers/mmc/host/jzmmc/include/jz_mmc_msc.h
new file mode 100644
index 0000000..4911e09
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/include/jz_mmc_msc.h
@@ -0,0 +1,32 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/msc/jz_mmc_msc.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#ifndef __JZ_MMC_MSC_H__
+#define __JZ_MMC_MSC_H__
+
+#include "jz_mmc_host.h"
+#include "jz_mmc_dma.h"
+
+#define RSP_TYPE(x)	((x) & ~(MMC_RSP_BUSY|MMC_RSP_OPCODE))
+
+struct jz_mmc_msc {
+
+	int (*init) (struct jz_mmc_host *);
+	void (*deinit) (struct jz_mmc_host *);
+	void (*set_clock) (struct jz_mmc_host *, int);
+	void (*execute_cmd) (struct jz_mmc_host *);
+};
+
+int jz_mmc_msc_register(struct jz_mmc_msc *msc);
+
+void jz_mmc_data_start(struct jz_mmc_host *host);
+
+void jz_mmc_reset(struct jz_mmc_host *host);
+#endif /* __JZ_MMC_MSC_H__ */
diff --git a/drivers/mmc/host/jzmmc/include/jz_mmc_pio.h b/drivers/mmc/host/jzmmc/include/jz_mmc_pio.h
new file mode 100644
index 0000000..ee8a302
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/include/jz_mmc_pio.h
@@ -0,0 +1,7 @@
+#ifndef __JZ_MMC_PIO_H__
+#define __JZ_MMC_PIO_H__
+
+extern void jz_mmc_stop_pio(struct jz_mmc_host *host);
+extern void jz_mmc_start_pio(struct jz_mmc_host *host);
+
+#endif /* __JZ_MMC_PIO_H__ */
diff --git a/drivers/mmc/host/jzmmc/jz_mmc_controller.c b/drivers/mmc/host/jzmmc/jz_mmc_controller.c
new file mode 100644
index 0000000..c43d43a
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/jz_mmc_controller.c
@@ -0,0 +1,91 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/controller/jz_mmc_controller.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sdio.h>
+#include <linux/scatterlist.h>
+
+#include <asm/jzsoc.h>
+#include "include/jz_mmc_msc.h"
+#include "include/jz_mmc_controller.h"
+
+
+static int data_transmit_dma(struct jz_mmc_host *host)
+{
+	jz_mmc_data_start(host);
+
+	return 0;
+}
+
+static int controller_init(struct jz_mmc_controller *controller, struct jz_mmc_host *host,
+				struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = controller->msc.init(host);
+	if(ret) {
+		return ret;
+	}
+
+	ret = controller->gpio.init(host, pdev);
+	if(ret) {
+		goto gpio_failed;
+	}
+
+	ret = controller->dma.init(host);
+	if(ret) {
+		goto dma_failed;
+	}
+
+	return 0;
+
+dma_failed:
+	controller->gpio.deinit(host, pdev);
+gpio_failed:
+	controller->msc.deinit(host);
+	return ret;
+}
+
+static void controller_deinit(struct jz_mmc_host *host, struct platform_device *pdev)
+{
+	struct jz_mmc_functions *functions = host->plat->driver_data;
+
+	functions->gpio_deinit(host, pdev);
+	functions->msc_deinit(host);
+	functions->dma_deinit(host);
+}
+
+int controller_register(struct jz_mmc_controller *controller, struct jz_mmc_host *host)
+{
+	if(controller == NULL)
+		return -ENOMEM;
+
+	jz_mmc_gpio_register(&(controller->gpio));
+	jz_mmc_msc_register(&(controller->msc));
+	jz_mmc_dma_register(&(controller->dma));
+
+	controller->init = controller_init;
+	controller->functions.deinit = controller_deinit;
+	controller->functions.transmit_data = data_transmit_dma;
+	controller->functions.execute_cmd = controller->msc.execute_cmd;
+	controller->functions.set_clock = controller->msc.set_clock;
+	controller->functions.msc_deinit = controller->msc.deinit;
+	controller->functions.gpio_deinit = controller->gpio.deinit;
+	controller->functions.dma_deinit = controller->dma.deinit;
+
+	host->plat->driver_data = &(controller->functions);
+
+	// struct jz_mmc_functions *functions = host->plat->driver_data;
+
+//	printk("%s: host->plat->driver_data->set_clock = %x\n", __FUNCTION__, functions->set_clock);
+
+	return 0;
+}
diff --git a/drivers/mmc/host/jzmmc/jz_mmc_dma.c b/drivers/mmc/host/jzmmc/jz_mmc_dma.c
new file mode 100644
index 0000000..69679e2
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/jz_mmc_dma.c
@@ -0,0 +1,550 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/dma/jz_mmc_dma.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <asm/jzsoc.h>
+#include "include/jz_mmc_dma.h"
+#include "include/jz_mmc_host.h"
+
+#define JZMMC_BUFFER_NEEDS_BOUNCE(buffer)  (((unsigned long)(buffer) & 0x3) || !virt_addr_valid((buffer)))
+
+void jz_mmc_stop_dma(struct jz_mmc_host *host)
+{
+	u32 old_counter = REG_DMAC_DTCR(host->dma.channel);
+	u32 cur_counter;
+
+	//WARN(1, "mmc%d called %s\n", host->pdev_id, __FUNCTION__);
+	/* wait for the counter not change */
+	while (1) {		     /* wait forever, even when the card is removed */
+		schedule_timeout(3); /* 30ms */
+		cur_counter = REG_DMAC_DTCR(host->dma.channel);
+		if (cur_counter == old_counter)
+			break;
+		old_counter = cur_counter;
+	}
+
+	// Stop all
+	REG_DMAC_DCCSR(host->dma.channel) = 0;
+
+	// Clear all
+	REG_DMAC_DCMD(host->dma.channel) = 0;
+	REG_DMAC_DSAR(host->dma.channel) = 0;
+	REG_DMAC_DTAR(host->dma.channel) = 0;
+	REG_DMAC_DTCR(host->dma.channel) = 0;
+	REG_DMAC_DRSR(host->dma.channel) = 0;
+	REG_DMAC_DDA(host->dma.channel) = 0;
+}
+
+static inline int best_burst_size(unsigned int dma_len) {
+#ifdef USE_DMA_BUSRT_64
+	if (dma_len % 64 == 0)
+		return 64;
+#endif
+
+	if (dma_len % 32 == 0)
+		return 32;
+
+	if (dma_len % 16 == 0)
+		return 16;
+
+#ifdef USE_DMA_BUSRT_64
+	if (dma_len > 64)
+		return 64;
+#endif
+
+	if (dma_len > 32)
+		return 32;
+
+	if (dma_len > 16)
+		return 16;
+
+	return 4;
+}
+
+#ifndef DMAC_DRSR_RS_MSC2OUT
+#define DMAC_DRSR_RS_MSC2OUT 0
+#endif
+
+#ifndef DMAC_DRSR_RS_MSC2IN
+#define DMAC_DRSR_RS_MSC2IN 0
+#endif
+
+#define MSC_SET_OUT_REQ_SRC(ctrler_id, dst)				\
+	do {								\
+		switch((ctrler_id)) {					\
+		case 0:							\
+			(dst) = DMAC_DRSR_RS_MSC0OUT;			\
+			break;						\
+		case 1:							\
+			(dst) = DMAC_DRSR_RS_MSC1OUT;			\
+			break;						\
+		case 2:							\
+			(dst) = DMAC_DRSR_RS_MSC2OUT;			\
+			break;						\
+		default:						\
+			BUG();						\
+		}							\
+	} while(0)
+
+
+#define MSC_SET_IN_REQ_SRC(ctrler_id, dst)				\
+	do {								\
+		switch((ctrler_id)) {					\
+		case 0:							\
+			(dst) = DMAC_DRSR_RS_MSC0IN;			\
+			break;						\
+		case 1:							\
+			(dst) = DMAC_DRSR_RS_MSC1IN;			\
+			break;						\
+		case 2:							\
+			(dst) = DMAC_DRSR_RS_MSC2IN;			\
+			break;						\
+		default:						\
+			BUG();						\
+		}							\
+	} while (0)
+
+#ifdef USE_DMA_DESC
+static void sg_to_desc(struct scatterlist *sgentry, JZ_MSC_DMA_DESC *first_desc,
+		       int *desc_pos /* IN OUT */, int mode, int ctrl_id,
+		       struct jz_mmc_host *host) {
+	JZ_MSC_DMA_DESC *desc = NULL;
+	int pos = *desc_pos;
+	unsigned int ds = 32; /* ehh, 32byte is the best */
+	unsigned int next;
+	dma_addr_t dma_addr;
+	unsigned int dma_len;
+	unsigned int head_unalign_size = 0; /* ds = 4byte */
+	unsigned int aligned_size = 0;
+	unsigned int tail_unalign_size = 0; /* ds = 4byte */
+	dma_addr_t best_dma_addr = 0;
+	dma_addr_t last_best_dma_addr = 0;
+	dma_addr_t dma_desc_phys_addr = CPHYSADDR((unsigned long)first_desc);
+
+	BUG_ON(JZMMC_BUFFER_NEEDS_BOUNCE(sg_virt(sgentry)));
+
+	dma_addr = sg_dma_address(sgentry);
+	dma_len = sg_dma_len(sgentry);
+
+	BUG_ON(dma_len % 4); /* we do NOT support transfer size < 4byte */
+
+	ds = best_burst_size(dma_len);
+	best_dma_addr = (dma_addr + ds - 1) & ~(ds - 1);
+	last_best_dma_addr = (dma_addr + dma_len) & ~(ds - 1);
+
+	head_unalign_size = best_dma_addr - dma_addr;
+	tail_unalign_size = dma_addr + dma_len - last_best_dma_addr;
+	aligned_size = dma_len - head_unalign_size - tail_unalign_size;
+
+#if 0
+	/* just for test */
+	if (aligned_size > 2 * ds) {
+		aligned_size -= 2 * ds;
+		head_unalign_size += ds;
+		best_dma_addr += ds;
+
+		tail_unalign_size += ds;
+		last_best_dma_addr -= ds;
+	} else if (aligned_size > ds) {
+		aligned_size -= ds;
+		head_unalign_size += ds;
+		best_dma_addr += ds;
+	}
+#endif
+
+	BUG_ON(head_unalign_size % 4);
+	BUG_ON(tail_unalign_size % 4);
+
+	if (head_unalign_size) {
+		desc = first_desc + pos;
+		next = (dma_desc_phys_addr + (pos + 1) * (sizeof(JZ_MSC_DMA_DESC))) >> 4;
+		desc->dcmd = DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_LINK;
+		if (DMA_MODE_WRITE == mode) {
+			desc->dcmd |= DMAC_DCMD_SAI;
+			desc->dsadr = (unsigned int)dma_addr;      /* DMA source address */
+			desc->dtadr = CPHYSADDR(MSC_TXFIFO(ctrl_id));      /* DMA target address */
+			MSC_SET_OUT_REQ_SRC(ctrl_id, desc->dreqt);
+		} else {
+			desc->dcmd |= DMAC_DCMD_DAI;
+			desc->dsadr = CPHYSADDR(MSC_RXFIFO(ctrl_id));
+			desc->dtadr = (unsigned int)dma_addr;
+			MSC_SET_IN_REQ_SRC(ctrl_id, desc->dreqt);
+		}
+		desc->ddadr = (next << 24) | (head_unalign_size >> 2) ;
+
+		pos ++;
+	}
+
+	if (aligned_size) {
+		desc = first_desc + pos;
+		next = (dma_desc_phys_addr + (pos + 1) * (sizeof(JZ_MSC_DMA_DESC))) >> 4;
+
+		desc->dcmd = DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_LINK;
+		switch (ds) {
+#ifdef USE_DMA_BUSRT_64
+		case 64:
+			desc->dcmd |= DMAC_DCMD_DS_64BYTE;
+			break;
+#endif
+
+		case 32:
+			desc->dcmd |= DMAC_DCMD_DS_32BYTE;
+			break;
+
+		case 16:
+			desc->dcmd |= DMAC_DCMD_DS_16BYTE;
+			break;
+
+		case 4:
+			desc->dcmd |= DMAC_DCMD_DS_32BIT;
+			break;
+
+		default:
+			;
+		}
+
+		if (DMA_MODE_WRITE == mode) {
+			desc->dcmd |= DMAC_DCMD_SAI;
+			desc->dsadr = (unsigned int)best_dma_addr;      /* DMA source address */
+			desc->dtadr = CPHYSADDR(MSC_TXFIFO(ctrl_id));      /* DMA target address */
+			MSC_SET_OUT_REQ_SRC(ctrl_id, desc->dreqt);
+		} else {
+			desc->dcmd |= DMAC_DCMD_DAI;
+			desc->dsadr = CPHYSADDR(MSC_RXFIFO(ctrl_id));
+			desc->dtadr = (unsigned int)best_dma_addr;
+			MSC_SET_IN_REQ_SRC(ctrl_id, desc->dreqt);
+		}
+		desc->ddadr = (next << 24) | (aligned_size  / ds) ;
+
+		pos ++;
+	}
+
+
+	if (tail_unalign_size) {
+		desc = first_desc + pos;
+		next = (dma_desc_phys_addr + (pos + 1) * (sizeof(JZ_MSC_DMA_DESC))) >> 4;
+
+		desc->dcmd = DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BIT |   DMAC_DCMD_RDIL_IGN | DMAC_DCMD_LINK;
+		if (DMA_MODE_WRITE == mode) {
+			desc->dcmd |= DMAC_DCMD_SAI;
+			desc->dsadr = (unsigned int)last_best_dma_addr;      /* DMA source address */
+			desc->dtadr = CPHYSADDR(MSC_TXFIFO(ctrl_id));      /* DMA target address */
+			MSC_SET_OUT_REQ_SRC(ctrl_id, desc->dreqt);
+		} else {
+			desc->dcmd |= DMAC_DCMD_DAI;
+			desc->dsadr = CPHYSADDR(MSC_RXFIFO(ctrl_id));
+			desc->dtadr = (unsigned int)last_best_dma_addr;
+			MSC_SET_IN_REQ_SRC(ctrl_id, desc->dreqt);
+		}
+		desc->ddadr = (next << 24) | (tail_unalign_size >> 2) ;
+
+		pos ++;
+
+	}
+
+	*desc_pos = pos;
+}
+
+#ifdef MSC_DEBUG_DMA
+#define JZ_MSC_RECORD_DESC_NUM(num)	host->num_desc = (num)
+#else
+#define JZ_MSC_RECORD_DESC_NUM(num)	do {  } while(0)
+#endif
+
+void jz_mmc_start_scatter_dma(int chan, struct jz_mmc_host *host,
+			      struct scatterlist *sg, unsigned int sg_len, int mode) {
+	int i = 0;
+	int desc_pos = 0;
+	dma_addr_t dma_desc_phy_addr = 0;
+	struct mmc_data *data = host->curr_mrq->data;
+	struct scatterlist *sgentry;
+	JZ_MSC_DMA_DESC *desc;
+	JZ_MSC_DMA_DESC *desc_first;
+	unsigned long flags;
+	unsigned long start_time = jiffies;
+
+	while (REG_DMAC_DMACR(chan / HALF_DMA_NUM) & (DMAC_DMACR_HLT | DMAC_DMACR_AR)) {
+		if (jiffies - start_time > 10) { /* 100ms */
+			printk("DMAC unavailable! REG_DMAC_DMACR(%d) = 0x%08x\n", chan / HALF_DMA_NUM, REG_DMAC_DMACR(chan / HALF_DMA_NUM));
+			jz_mmc_stop_dma(host);
+			break;
+		}
+	}
+
+	start_time = jiffies;
+	while (REG_DMAC_DCCSR(chan) & (DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR)) {
+		if (jiffies - start_time > 10) { /* 100ms */
+			printk("DMA channel %d unavailable! REG_DMAC_DCCSR(%d) = 0x%08x\n", chan, chan, REG_DMAC_DCCSR(chan));
+			jz_mmc_stop_dma(host);
+			break;
+		}
+	}
+
+	REG_DMAC_DCCSR(chan) |= DMAC_DCCSR_DES8;
+	REG_DMAC_DCCSR(chan) &= ~DMAC_DCCSR_NDES;
+
+	/* Setup request source */
+	if (DMA_MODE_WRITE == mode) {
+		MSC_SET_OUT_REQ_SRC(host->pdev_id, REG_DMAC_DRSR(chan));
+	} else {
+		MSC_SET_IN_REQ_SRC(host->pdev_id, REG_DMAC_DRSR(chan));
+	}
+
+#ifdef MSC_DEBUG_DMA
+	if (DMA_MODE_WRITE == mode) {
+		host->last_direction = 1;
+	} else {
+		host->last_direction = 0;
+	}
+#endif
+
+	desc = host->dma_desc;
+	JZ_MSC_RECORD_DESC_NUM(desc_pos);
+	desc_first = desc;
+
+	dma_desc_phy_addr  = CPHYSADDR((unsigned long)desc);
+
+	memset(desc, 0, PAGE_SIZE);
+
+	desc_pos = 0;
+	flags = claim_dma_lock();
+	for_each_sg(data->sg, sgentry, host->dma.len, i) {
+		sg_to_desc(sgentry, desc, &desc_pos, mode, host->pdev_id, host);
+	}
+
+	desc = desc + (desc_pos - 1);
+	desc->dcmd |= DMAC_DCMD_TIE;
+	desc->dcmd &= ~DMAC_DCMD_LINK;
+	desc->ddadr &= ~0xff000000;
+
+	dma_cache_wback_inv((unsigned long)desc_first, PAGE_SIZE);
+
+        /* Setup DMA descriptor address */
+	REG_DMAC_DDA(chan) = dma_desc_phy_addr;
+
+	/* DMA doorbell set -- start DMA now ... */
+	REG_DMAC_DMADBSR(chan / HALF_DMA_NUM) = 1 << (chan - (chan / HALF_DMA_NUM) * HALF_DMA_NUM) ;
+
+	/* Enable DMA */
+	REG_DMAC_DMACR(chan / HALF_DMA_NUM) |= DMAC_DMACR_DMAE;
+
+	REG_DMAC_DCCSR(chan) |= DMAC_DCCSR_EN;
+
+	release_dma_lock(flags);
+
+}
+#else
+void jz_mmc_start_normal_dma(struct jz_mmc_host *host, unsigned long phyaddr, int count, int mode, int ds)
+{
+	unsigned long flags;
+	unsigned long start_time = jiffies;
+	int chan = host->dma.channel;
+	u32 dma_cmd = 0;
+	u32 src_addr = 0;
+	u32 dst_addr = 0;
+	u32 req_src = 0;
+
+	while (REG_DMAC_DMACR(chan / HALF_DMA_NUM) & (DMAC_DMACR_HLT | DMAC_DMACR_AR)) {
+		if (jiffies - start_time > 10) { /* 100ms */
+			printk("DMAC unavailable! REG_DMAC_DMACR(%d) = 0x%08x\n", chan / HALF_DMA_NUM, REG_DMAC_DMACR(chan / HALF_DMA_NUM));
+			jz_mmc_stop_dma(host);
+			break;
+		}
+	}
+
+	start_time = jiffies;
+	while (REG_DMAC_DCCSR(chan) & (DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR)) {
+		if (jiffies - start_time > 10) { /* 100ms */
+			printk("DMA channel %d unavailable! REG_DMAC_DCCSR(%d) = 0x%08x\n", chan, chan, REG_DMAC_DCCSR(chan));
+			jz_mmc_stop_dma(host);
+			break;
+		}
+	}
+
+	flags = claim_dma_lock();
+	dma_cmd = DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_TIE;
+	switch (ds) {
+#ifdef USE_DMA_BUSRT_64
+	case 64:
+		dma_cmd |= DMAC_DCMD_DS_64BYTE;
+		break;
+#endif
+
+	case 32:
+		dma_cmd |= DMAC_DCMD_DS_32BYTE;
+		break;
+
+	case 16:
+		dma_cmd |= DMAC_DCMD_DS_16BYTE;
+		break;
+
+	case 4:
+		dma_cmd |= DMAC_DCMD_DS_32BIT;
+		break;
+
+	default:
+		;
+	}
+	if (DMA_MODE_WRITE == mode) {
+		dma_cmd |= DMAC_DCMD_SAI;
+		src_addr = (unsigned int)phyaddr;      /* DMA source address */
+		dst_addr = CPHYSADDR(MSC_TXFIFO(host->pdev_id));      /* DMA target address */
+		MSC_SET_OUT_REQ_SRC(host->pdev_id, req_src);
+	} else {
+		dma_cmd |= DMAC_DCMD_DAI;
+		src_addr = CPHYSADDR(MSC_RXFIFO(host->pdev_id));
+		dst_addr = (unsigned int)phyaddr;
+		MSC_SET_IN_REQ_SRC(host->pdev_id, req_src);
+	}
+
+	REG_DMAC_DCCSR(chan) |= DMAC_DCCSR_NDES; /* No-descriptor transfer */
+	REG_DMAC_DSAR(chan) = src_addr;
+	REG_DMAC_DTAR(chan) = dst_addr;
+	REG_DMAC_DTCR(chan) = (count + ds - 1) / ds;
+	REG_DMAC_DCMD(chan) = dma_cmd;
+	REG_DMAC_DRSR(chan) = req_src;
+
+	REG_DMAC_DMACR(chan / HALF_DMA_NUM) |= DMAC_DMACR_DMAE;
+	REG_DMAC_DCCSR(chan) |= DMAC_DCCSR_EN;
+
+	release_dma_lock(flags);
+}
+#endif
+
+void jz_mmc_start_dma(struct jz_mmc_host *host) {
+	struct mmc_data *data = host->curr_mrq->data;
+	int mode;
+#ifndef USE_DMA_DESC
+	int i;
+	int ds = 4;
+	struct scatterlist *sgentry;
+#endif
+
+	if (data->flags & MMC_DATA_WRITE) {
+		mode = DMA_MODE_WRITE;
+		host->dma.dir = DMA_TO_DEVICE;
+	} else {
+		mode = DMA_MODE_READ;
+		host->dma.dir = DMA_FROM_DEVICE;
+	}
+
+	host->dma.len =
+	    dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+		       host->dma.dir);
+
+#ifdef USE_DMA_DESC
+	jz_mmc_start_scatter_dma(host->dma.channel, host, data->sg, host->dma.len, mode);
+#else
+	for_each_sg(data->sg, sgentry, host->dma.len, i) {
+		dma_cache_wback_inv((unsigned long)CKSEG0ADDR(sg_dma_address(sgentry) + data->sg->offset),
+				    sg_dma_len(sgentry));
+
+		if ((likely(sg_dma_len(sgentry) % 32 == 0)))
+			ds = 32; /* 32 byte */
+		else if (sg_dma_len(sgentry) % 16 == 0)
+			ds = 16; /* 16 byte */
+		else
+			ds = 4; /* default to 4 byte */
+
+		/*
+		 * FIXME: bug here!!!!! if NR_SG > 1(current NR_SG==1),
+		 * must wait for current dma done, then next sg
+		 */
+		jz_mmc_start_normal_dma(host, sg_dma_address(sgentry),
+				 sg_dma_len(sgentry), mode, ds);
+	}
+#endif
+}
+
+static irqreturn_t jz_mmc_dma_callback(int irq, void *devid)
+{
+	struct jz_mmc_host *host = devid;
+	int chan = host->dma.channel;
+
+	disable_dma(chan);
+
+	host->data_err = 0;
+	if (__dmac_channel_address_error_detected(chan)) {
+		printk("%s: DMAC address error.\n",
+		       __FUNCTION__);
+		__dmac_channel_clear_address_error(chan);
+		host->data_err = 1;
+		wmb();
+	}
+
+	if (__dmac_channel_transmit_halt_detected(chan)) {
+		printk("%s: DMA chan%d Halted.\n", __func__, chan);
+		__dmac_channel_clear_transmit_halt(chan);
+		host->data_err = 1;
+		wmb();
+	}
+	if (__dmac_channel_transmit_end_detected(chan)) {
+		__dmac_channel_clear_transmit_end(chan);
+	}
+
+	if (host->dma.dir == DMA_FROM_DEVICE) {
+		host->data_ack = 1;
+		wmb();
+		wake_up_interruptible(&host->data_wait_queue);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static char *msc_dma_name[] = {
+	"msc0_dma",
+	"msc1_dma",
+	"msc2_dma",
+};
+
+static int jz_mmc_init_dma(struct jz_mmc_host *host)
+{
+	if (host->dma_id < 0)
+		return 0;     /* not use dma */
+
+	host->dma.channel = jz_request_dma(host->dma_id,
+					   msc_dma_name[host->pdev_id],
+					   jz_mmc_dma_callback,
+					   0, host);
+	if (host->dma.channel < 0) {
+		printk(KERN_ERR "jz_request_dma failed for MMC Rx\n");
+		goto err_out;
+	}
+
+	REG_DMAC_DMACR(host->dma.channel / HALF_DMA_NUM) |= DMAC_DMACR_FMSC;
+
+#ifdef USE_DMA_DESC
+	host->dma_desc = (JZ_MSC_DMA_DESC *)__get_free_pages(GFP_KERNEL, 0);
+#endif
+
+	return 0;
+err_out:
+	return -ENODEV;
+}
+
+static void jz_mmc_deinit_dma(struct jz_mmc_host *host)
+{
+	jz_free_dma(host->dma.channel);
+}
+
+int jz_mmc_dma_register(struct jz_mmc_dma *dma)
+{
+	if(dma == NULL)
+		return -ENOMEM;
+
+	dma->init = jz_mmc_init_dma;
+	dma->deinit = jz_mmc_deinit_dma;
+
+	return 0;
+}
diff --git a/drivers/mmc/host/jzmmc/jz_mmc_gpio.c b/drivers/mmc/host/jzmmc/jz_mmc_gpio.c
new file mode 100644
index 0000000..4aa9028
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/jz_mmc_gpio.c
@@ -0,0 +1,213 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/gpio/jz_mmc_gpio.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#include <linux/mmc/host.h>
+#include "include/jz_mmc_gpio.h"
+#include "include/jz_mmc_msc.h"
+
+#define	TRY_TIME	10
+#define	RETRY_TIME	50
+
+#define DETECT_CHANGE_DELAY 50
+
+static void jz_mmc_enable_detect(unsigned long arg) {
+	struct jz_mmc_host *host = (struct jz_mmc_host *)arg;
+
+	atomic_inc(&host->detect_refcnt);
+
+	if (host->eject) {
+		/* wait for card insertion */
+		host->plat->plug_change(CARD_REMOVED);
+	} else {
+		/* wait for card removal */
+		host->plat->plug_change(CARD_INSERTED);
+	}
+	enable_irq(host->plat->status_irq);
+}
+
+static void jz_mmc_enable_card_detect(struct jz_mmc_host *host) {
+	host->timer.expires = jiffies + DETECT_CHANGE_DELAY * 2;
+	host->timer.data = (unsigned long)host;
+	host->timer.function = jz_mmc_enable_detect;
+	add_timer(&host->timer);
+}
+
+static void jiq_de_quiver(struct work_struct *ptr){
+	struct jz_mmc_host *host = container_of((struct delayed_work *)ptr,
+						struct jz_mmc_host, gpio_jiq_work);
+	unsigned int time_to_try, i, tmp, counter = 0, result = 1;
+
+	if (unlikely(!host->plat->status)) { /* NEVER */
+		mmc_detect_change(host->mmc, 0);
+		jz_mmc_enable_card_detect(host);
+		return;
+	}
+
+	for (time_to_try = 0; time_to_try < RETRY_TIME; time_to_try++) {
+		for (i = 0; i < TRY_TIME; i++) {
+			tmp = (!host->plat->status(mmc_dev(host->mmc))); // tmp = 1 means slot is empty
+			result &= tmp;
+			if( !tmp )
+				counter++;
+			schedule_timeout((10*HZ)/1000);
+		}
+
+		if ( !result ) {
+			// The card is there
+			if (counter == TRY_TIME) {
+				host->eject = 0;
+				printk("Card Insert\n");
+				goto stable;
+			}
+			/* try again, goto for */
+			counter = 0;
+			result = 1;
+		} else {
+			host->eject = 1;
+			printk("Card Eject\n");
+			goto stable;
+		}
+	}
+
+stable:
+	/* oldstat: 1 -- eject, 0 -- inserted */
+	/* eject: 1 -- eject, 0 -- inserted */
+
+	if ( (0 == host->oldstat) && (0 == host->eject) && host->sleeping) {
+		mmc_resume_host(host->mmc);
+	}
+
+	if ( (0== host->oldstat) && (1 == host->eject) ) {
+		if (host->sleeping) {
+			mmc_resume_host(host->mmc);
+		} else {
+			mmc_detect_change(host->mmc, 50);
+				if (REG_MSC_STAT(host->pdev_id) & MSC_STAT_CLK_EN){
+					printk(" ====> Clock is on\n");
+					jz_mmc_reset(host);
+				}
+
+
+		}
+
+		wake_up_interruptible(&host->data_wait_queue);
+	}
+
+	if ( (1 == host->oldstat) && (0 == host->eject) ) {
+		mmc_detect_change(host->mmc, 50);
+	}
+
+	host->sleeping = 0;
+	host->oldstat = host->eject;
+	jz_mmc_enable_card_detect(host);
+}
+
+int jz_mmc_detect(struct jz_mmc_host *host, int from_resuming) {
+	int ret = 0;
+
+	if (!atomic_dec_and_test(&host->detect_refcnt)) {
+		atomic_inc(&host->detect_refcnt);
+		return 0;
+	}
+
+	disable_irq_nosync(host->plat->status_irq);
+
+	if (from_resuming)
+		schedule_timeout(HZ / 2); /* 500ms, wait for MMC Block module resuming*/
+
+	ret = schedule_delayed_work( &(host->gpio_jiq_work), HZ / 100); /* 10ms, a little time */
+
+	return ret;
+}
+
+#if 0
+extern int wait_cmd_done;
+extern void jz_mmc_dump_regs(int msc_id, int line);
+volatile int error_may_happen = 0;
+#endif
+
+static irqreturn_t jz_mmc_detect_irq(int irq, void *devid)
+{
+#if 0
+	printk("===>enter %s\n", __func__);
+	if (wait_cmd_done) {
+		printk("============================>CAUTION: error may happen!\n");
+		//jz_mmc_dump_regs(1, __LINE__);
+		error_may_happen = 1;
+	}
+#endif
+	jz_mmc_detect((struct jz_mmc_host *) devid, 0);
+
+	return IRQ_HANDLED;
+}
+
+static int jz_mmc_gpio_init(struct jz_mmc_host *host, struct platform_device *pdev)
+{
+	int ret = 0;
+
+	/*
+	 * Setup card detect change
+	 */
+	if (host->plat->status_irq) {
+		ret = request_irq(host->plat->status_irq,
+				  jz_mmc_detect_irq,
+				  0,
+				  "jz-msc (gpio)",
+				  host);
+		if (ret) {
+			printk(KERN_ERR "Unable to get slot IRQ %d (%d)\n",
+			       host->plat->status_irq, ret);
+			return ret;
+		}
+
+		device_init_wakeup(&pdev->dev, 1);
+
+		INIT_DELAYED_WORK(&(host->gpio_jiq_work), jiq_de_quiver);
+		init_timer(&host->timer);
+
+		atomic_set(&host->detect_refcnt, 1);
+		host->sleeping = 0;
+
+		// Check if there were any card present
+		if (host->plat->status) {
+			host->eject = !(host->plat->status(mmc_dev(host->mmc)));
+			host->oldstat = host->eject;
+
+			if(host->eject) {
+				host->plat->plug_change(CARD_REMOVED);
+			} else {
+				host->plat->plug_change(CARD_INSERTED);
+			}
+		}
+	} else
+		printk(KERN_ERR "%s: No card detect facilities available\n",
+		       mmc_hostname(host->mmc));
+
+	return 0;
+}
+
+static void jz_mmc_gpio_deinit(struct jz_mmc_host *host, struct platform_device *pdev)
+{
+	if(host->plat->status_irq) {
+		free_irq(host->plat->status_irq, host);
+		device_init_wakeup(&pdev->dev, 0);
+	}
+}
+
+int jz_mmc_gpio_register(struct jz_mmc_gpio *gpio)
+{
+	if(gpio == NULL)
+		return -ENOMEM;
+
+	gpio->init = jz_mmc_gpio_init;
+	gpio->deinit = jz_mmc_gpio_deinit;
+
+	return 0;
+}
diff --git a/drivers/mmc/host/jzmmc/jz_mmc_main.c b/drivers/mmc/host/jzmmc/jz_mmc_main.c
new file mode 100644
index 0000000..63e71bb
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/jz_mmc_main.c
@@ -0,0 +1,522 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/jz_mmc_main.c - JZ SD/MMC driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/card.h>
+#include <linux/mm.h>
+#include <linux/signal.h>
+#include <linux/pm.h>
+#include <linux/scatterlist.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+#include <asm/jzsoc.h>
+#include "include/jz_mmc_host.h"
+#include "include/jz_mmc_controller.h"
+
+/* for Atheros wifi */
+int is_virt_addr_valid(unsigned char *buffer) {
+	return virt_addr_valid(buffer);
+}
+EXPORT_SYMBOL(is_virt_addr_valid);
+
+struct jz_mmc_controller controller[JZ_MAX_MSC_NUM];
+int is_permission = 0;
+
+int jz_mmc_get_permission(struct mmc_host *mmc, struct mmc_request *mrq){
+	int sector,up_limit,down_limit;
+
+	if (!mmc_card_blockaddr(mmc->card)){
+		up_limit = 16384 << 9 ;
+		down_limit = 512;
+	}
+	else{
+		up_limit = 16384 ;
+		down_limit = 1;
+	}
+	sector = mrq->cmd->arg;
+
+	if(sector>down_limit && sector<up_limit){
+
+		return is_permission;
+	}else{
+		return 1;
+	}
+}
+
+/* add partitions info for recovery */
+#ifdef CONFIG_JZ_RECOVERY_SUPPORT
+static ssize_t jz_mmc_partitions_show(struct device *dev,struct device_attribute *attr, char *buf)
+{
+	int i;
+	struct jz_mmc_platform_data *pdata = dev->platform_data;
+	ssize_t count = 0;
+
+	if(pdata->num_partitions == 0) {
+		count = sprintf(buf, "null\n");
+		return count;
+	}
+
+	for(i=0;i<pdata->num_partitions;i++)
+		count += sprintf(buf+count, "%s %x %x %d\n",
+				pdata->partitions[i].name,
+				pdata->partitions[i].saddr,
+				pdata->partitions[i].len,
+				pdata->partitions[i].type);
+
+	return count;
+}
+
+
+static ssize_t jz_mmc_permission_set(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct jz_mmc_platform_data *pdata = dev->platform_data;
+
+	if (buf == NULL)
+		return count;
+
+	if (strcmp(buf, "RECOVERY_MODE") == 0) {
+		printk("host->permission: MMC_BOOT_AREA_PROTECTED->MMC_BOOT_AREA_OPENED\n");
+		pdata->permission = MMC_BOOT_AREA_OPENED;
+	} else {
+		printk("host->permission: MMC_BOOT_AREA_OPENED->MMC_BOOT_AREA_PROTECTED\n");
+		pdata->permission = MMC_BOOT_AREA_PROTECTED;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(partitions, S_IRUSR | S_IRGRP | S_IROTH, jz_mmc_partitions_show, NULL);
+static DEVICE_ATTR(recovery_permission, S_IWUSR, NULL, jz_mmc_permission_set);
+
+static struct attribute *jz_mmc_attributes[] = {
+	&dev_attr_partitions.attr,
+	&dev_attr_recovery_permission.attr,
+	NULL
+};
+
+static const struct attribute_group jz_mmc_attr_group = {
+	.attrs = jz_mmc_attributes,
+};
+#endif
+
+void jz_mmc_finish_request(struct jz_mmc_host *host, struct mmc_request *mrq)
+{
+	host->curr_mrq = NULL;
+	up(&host->mutex);
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void jz_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct jz_mmc_host *host = mmc_priv(mmc);
+	struct jz_mmc_functions *functions = host->plat->driver_data;
+
+	down(&host->mutex);
+
+	if (SD_IO_SEND_OP_COND == mrq->cmd->opcode) {
+		if(host->plat->support_sdio == 0) {
+			mrq->cmd->error = -ETIMEDOUT;
+			jz_mmc_finish_request(host, mrq);
+			return;
+		}
+	}
+
+	if (host->eject) {
+		if (mrq->data && !(mrq->data->flags & MMC_DATA_READ)) {
+			mrq->cmd->error = -EIO;
+			mrq->data->bytes_xfered = 0;
+		} else
+			mrq->cmd->error = -ENOMEDIUM;
+		up(&host->mutex);
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+#if defined(CONFIG_JZ_SYSTEM_AT_CARD)
+	if(host->pdev_id == 0 ){
+		if (mrq->data && (mrq->data->flags & MMC_DATA_WRITE)){
+			if(!jz_mmc_get_permission(mmc, mrq) && mrq->cmd->opcode != 6) {
+				mrq->cmd->error = -EIO;
+				mrq->data->bytes_xfered = 0;
+
+					up(&host->mutex);
+					mmc_request_done(mmc, mrq);
+					return;
+			}
+		}
+	}
+#endif
+
+	BUG_ON (host->curr_mrq);
+	host->curr_mrq = mrq;
+	functions->execute_cmd(host);
+	jz_mmc_finish_request(host, mrq);
+}
+
+static int jz_mmc_get_ro(struct mmc_host *mmc)
+{
+	struct jz_mmc_host *host = mmc_priv(mmc);
+
+	if(host->plat->write_protect != NULL)
+		return host->plat->write_protect(mmc_dev(host->mmc));
+	else
+		return 0;
+}
+
+static int jz_mmc_get_cd(struct mmc_host *mmc)
+{
+	struct jz_mmc_host *host = mmc_priv(mmc);
+
+	if(host->plat->status != NULL) {
+		return host->plat->status(mmc_dev(host->mmc));
+	}
+	else
+		return 1;
+}
+
+/* set clock and power */
+static void jz_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct jz_mmc_host *host = mmc_priv(mmc);
+	struct jz_mmc_functions *functions = host->plat->driver_data;
+	//void *dev;
+
+	if(!functions) {
+//		printk("%s: functions is NULL!\n", __FUNCTION__);
+		while(1);
+	}
+
+	if (ios->clock) {
+		functions->set_clock(host, ios->clock);
+	}
+
+	switch(ios->power_mode) {
+	case MMC_POWER_ON:
+		host->plat->power_on(NULL);
+		host->cmdat |= MSC_CMDAT_INIT;
+		break;
+	case MMC_POWER_OFF:
+		host->plat->power_off(NULL);
+		break;
+	default:
+		break;
+	}
+
+	if (ios->bus_width == MMC_BUS_WIDTH_4) {
+
+		host->cmdat &= ~MSC_CMDAT_BUS_WIDTH_MASK;
+
+		if(host->plat->bus_width == 4)
+			host->cmdat |= MSC_CMDAT_BUS_WIDTH_4BIT;
+		else
+			host->cmdat |= host->plat->bus_width;
+	} else if (ios->bus_width == MMC_BUS_WIDTH_8) {
+
+		host->cmdat &= ~MSC_CMDAT_BUS_WIDTH_MASK;
+
+		if(host->plat->bus_width == 8)
+			host->cmdat |= MSC_CMDAT_BUS_WIDTH_8BIT;
+//		else
+//			host->cmdat |= host->plat->bus_width;
+	} else {
+		/* 1 bit bus*/
+		host->cmdat &= ~MSC_CMDAT_BUS_WIDTH_8BIT;
+	}
+}
+
+static const struct mmc_host_ops jz_mmc_ops = {
+	.request = jz_mmc_request,
+	.get_ro = jz_mmc_get_ro,
+	.set_ios = jz_mmc_set_ios,
+	.get_cd = jz_mmc_get_cd,
+};
+
+#ifdef MSC_DEBUG_DMA
+static struct jz_mmc_host *msc_hosts[JZ_MAX_MSC_NUM] = { NULL, NULL, NULL };
+
+static void dump_host_info(struct jz_mmc_host *host) {
+	int i = 0;
+	JZ_MSC_DMA_DESC *desc = NULL;
+
+	printk("*** msc%d host info ***\n", host->pdev_id);
+	dump_jz_dma_channel(host->dma.channel);
+	printk("*** last running descriptors = %d direction = %d ***\n", host->num_desc, host->last_direction);
+	desc = host->dma_desc;
+	for (i = 0; i < host->num_desc; i++) {
+		printk("desc address = %p\n", desc + i);
+		printk("dcmd = 0x%08x\n", desc[i].dcmd);
+		printk("dsadr = 0x%08x\n", desc[i].dsadr);
+		printk("dtadr = 0x%08x\n", desc[i].dtadr);
+		printk("ddadr = 0x%08x\n", desc[i].ddadr);
+		printk("dstrd = 0x%08x\n", desc[i].dstrd);
+		printk("dreqt = 0x%08x\n", desc[i].dreqt);
+		printk("resv0 = 0x%08x\n", desc[i].reserved0);
+		printk("resv1 = 0x%08x\n", desc[i].reserved1);
+		printk("==========\n");
+	}
+
+	printk("curr tx_ack = %d\n", host->tx_ack);
+	printk("curr rx_ack = %d\n", host->rx_ack);
+}
+
+void msc_dump_host_info(void) {
+	int i = 0;
+
+	for (i = 0; i < JZ_MAX_MSC_NUM; i++) {
+		if (msc_hosts[i] != NULL) {
+			dump_host_info(msc_hosts[0]);
+		}
+	}
+}
+EXPORT_SYMBOL(msc_dump_host_info);
+#endif	/* MSC_DEBUG_DMA */
+
+#if defined(CONFIG_JZ_RECOVERY_SUPPORT) || defined(CONFIG_JZ_SYSTEM_AT_CARD)
+static ssize_t mmc_permission_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", is_permission);
+}
+
+static ssize_t mmc_permission_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int permis;
+
+	permis = simple_strtol(buf, NULL, 10);
+	is_permission = permis;
+	printk("%d\n",is_permission);
+	return count;
+}
+
+static DEVICE_ATTR(permission, S_IWUSR | S_IRUGO, mmc_permission_show, mmc_permission_store);
+#endif
+
+static int jz_mmc_probe(struct platform_device *pdev)
+{
+	struct jz_mmc_platform_data *plat = pdev->dev.platform_data;
+	struct mmc_host *mmc;
+	struct jz_mmc_host *host = NULL;
+	struct jz_mmc_functions *functions;
+
+	struct resource *irqres = NULL;
+	struct resource *memres = NULL;
+	struct resource *dmares = NULL;
+	int i;
+
+	if (pdev == NULL) {
+		printk(KERN_ERR "%s: pdev is NULL\n", __func__);
+		return -EINVAL;
+	}
+	if (!plat) {
+		printk(KERN_ERR "%s: Platform data not available\n", __func__);
+		return -EINVAL;
+	}
+
+	if (JZ_MSC_ID_INVALID(pdev->id))
+		return -EINVAL;
+
+	plat->cpm_start(&pdev->dev);
+
+	if (pdev->resource == NULL || pdev->num_resources < 2) {
+		printk(KERN_ERR "%s: Invalid resource\n", __func__);
+		return -ENXIO;
+	}
+	for (i = 0; i < pdev->num_resources; i++) {
+		if (pdev->resource[i].flags & IORESOURCE_MEM)
+			memres = &pdev->resource[i];
+		if (pdev->resource[i].flags & IORESOURCE_IRQ)
+			irqres = &pdev->resource[i];
+		if (pdev->resource[i].flags & IORESOURCE_DMA)
+			dmares = &pdev->resource[i];
+	}
+	if (!irqres || !memres) {
+		printk(KERN_ERR "%s: Invalid resource\n", __func__);
+		return -ENXIO;
+	}
+	/*
+	 * Setup our host structure
+	 */
+	mmc = mmc_alloc_host(sizeof(struct jz_mmc_host), &pdev->dev);
+	if (!mmc) {
+		return -ENOMEM;
+	}
+	host = mmc_priv(mmc);
+	host->pdev_id = pdev->id;
+	host->plat = plat;
+	host->mmc = mmc;
+#if 0			      /* Lutts */
+	// base address of MSC controller
+	host->base = ioremap(memres->start, PAGE_SIZE);
+	if (!host->base) {
+		return -ENOMEM;
+	}
+#endif
+	host->irq = irqres->start;
+	if (dmares)
+		host->dma_id = dmares->start;
+	else
+		host->dma_id = -1;
+	//spin_lock_init(&host->lock);
+	init_MUTEX(&host->mutex);
+
+	/*
+	 * Setup MMC host structure
+	 */
+	mmc->ops = &jz_mmc_ops;
+	mmc->f_min = MMC_CLOCK_SLOW;
+	mmc->f_max = SD_CLOCK_HIGH;
+	mmc->ocr_avail = plat->ocr_mask;
+	mmc->caps |= host->plat->max_bus_width;
+	mmc->max_phys_segs = NR_SG;
+	mmc->max_blk_size = 4095;
+	mmc->max_blk_count = 65535;
+
+	mmc->max_req_size = PAGE_SIZE * 16;
+	mmc->max_seg_size = mmc->max_req_size;
+	plat->init(&pdev->dev);
+	plat->power_on(&pdev->dev);
+	/*
+	 * Initialize controller and register some functions
+	 * From here, we can do everything!
+	 */
+	controller_register(&controller[host->pdev_id], host);
+	functions = host->plat->driver_data;
+	if(controller[host->pdev_id].init(&controller[host->pdev_id], host, pdev))
+		goto out;
+	mmc_set_drvdata(pdev, mmc);
+	mmc_add_host(mmc);
+#ifdef MSC_DEBUG_DMA
+	msc_hosts[host->pdev_id] = host;
+#endif
+
+	if(host->pdev_id == 0){
+#if defined(CONFIG_JZ_SYSTEM_AT_CARD)
+		if(device_create_file(&pdev->dev, &dev_attr_permission))
+			printk("MSC0: device_create_file for attr_permission failed!\n");;
+#endif
+	}
+#ifdef CONFIG_JZ_RECOVERY_SUPPORT
+	sysfs_create_group(&pdev->dev.kobj, &jz_mmc_attr_group);
+#endif
+	printk("JZ %s driver registered\n", mmc_hostname(host->mmc));
+
+	return 0;
+
+out:
+	return -1;
+}
+
+static int jz_mmc_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct jz_mmc_platform_data *plat = pdev->dev.platform_data;
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (mmc) {
+		struct jz_mmc_host *host = mmc_priv(mmc);
+		struct jz_mmc_functions *functions = host->plat->driver_data;
+
+		plat->power_off(&pdev->dev);
+
+		functions->deinit(host, pdev);
+
+		mmc_remove_host(mmc);
+		mmc_free_host(mmc);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int jz_mmc_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct mmc_host *mmc = platform_get_drvdata(dev);
+	struct jz_mmc_host *host = mmc_priv(mmc);
+	int ret = 0;
+
+#ifdef CONFIG_JZ_SYSTEM_AT_CARD
+	if (host->pdev_id == 0)
+		return 0;
+#endif
+	host->sleeping = 1;
+
+	if (mmc) {
+		if (mmc->card && mmc->card->type != MMC_TYPE_SDIO) {
+			ret = mmc_suspend_host(mmc, state);
+		}
+
+	}
+	return ret;
+}
+
+extern int jz_mmc_detect(struct jz_mmc_host *host, int from_resuming);
+static int jz_mmc_resume(struct platform_device *dev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(dev);
+	struct jz_mmc_host *host = mmc_priv(mmc);
+
+#ifdef CONFIG_JZ_SYSTEM_AT_CARD
+	if (host->pdev_id == 0){
+		return 0;
+	}
+#endif
+
+	if (mmc) {
+		if ( (mmc->card == NULL) || (mmc->card->type != MMC_TYPE_SDIO) )
+			jz_mmc_detect(host, 1);
+	}
+
+	return 0;
+}
+#else
+#define jz_mmc_suspend      NULL
+#define jz_mmc_resume       NULL
+#endif
+
+static struct platform_driver jz_msc_driver = {
+	.probe = jz_mmc_probe,
+	.remove = jz_mmc_remove,
+	.suspend = jz_mmc_suspend,
+	.resume = jz_mmc_resume,
+	.driver = {
+		   .name = "jz-msc",
+		   },
+};
+
+static int __init jz_mmc_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&jz_msc_driver);
+	return ret;
+}
+
+static void __exit jz_mmc_exit(void)
+{
+	platform_driver_unregister(&jz_msc_driver);
+}
+
+subsys_initcall(jz_mmc_init);
+module_exit(jz_mmc_exit);
+
+MODULE_DESCRIPTION("JZ47XX SD/Multimedia Card Interface Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/jzmmc/jz_mmc_msc.c b/drivers/mmc/host/jzmmc/jz_mmc_msc.c
new file mode 100644
index 0000000..75d1a55
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/jz_mmc_msc.c
@@ -0,0 +1,823 @@
+/*
+ *  linux/drivers/mmc/host/jz_mmc/msc/jz_mmc_msc.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copyright (c) Ingenic Semiconductor Co., Ltd.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/semaphore.h>
+#include <linux/kthread.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/host.h>
+#include <linux/scatterlist.h>
+
+#include <asm/jzsoc.h>
+#include "include/jz_mmc_msc.h"
+#include "include/jz_mmc_pio.h"
+
+#define MSC_STAT_ERR_BITS 0x3f
+#define WAITMASK							\
+	(MSC_STAT_CRC_RES_ERR |						\
+	 MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_MASK |	\
+	 MSC_STAT_TIME_OUT_RES | MSC_STAT_TIME_OUT_READ)
+
+#if 1
+
+static int jzmmc_trace_level = 0;
+static int jzmmc_trace_cmd_code = -1;
+static int jzmmc_trace_data_len = -1;
+static int jzmmc_trace_id = 0;
+module_param(jzmmc_trace_level, int, 0644);
+module_param(jzmmc_trace_cmd_code, int, 0644);
+module_param(jzmmc_trace_data_len, int, 0644);
+module_param(jzmmc_trace_id, int, 0644);
+
+#define TRACE_CMD_REQ()							\
+	({								\
+		if ( (jzmmc_trace_id & (1 << host->pdev_id)) && (jzmmc_trace_level & 0x1)) \
+			if ( (jzmmc_trace_cmd_code == -1) || (jzmmc_trace_cmd_code == cmd->opcode) ) \
+				printk("%s:     execute_cmd: opcode = %d cmdat = %#0x arg = %#0x data_flags = %#0x\n", \
+				       mmc_hostname(host->mmc), cmd->opcode, REG_MSC_CMDAT(host->pdev_id), REG_MSC_ARG(host->pdev_id), \
+				       host->curr_mrq->data ? host->curr_mrq->data->flags : 0); \
+	})
+
+#define TRACE_CMD_RES()							\
+	({								\
+		if ( (jzmmc_trace_id & (1 << host->pdev_id)) && (jzmmc_trace_level & 0x1)) \
+			if ( (jzmmc_trace_cmd_code == -1) || (jzmmc_trace_cmd_code == cmd->opcode) ) \
+				printk("%s:     cmd done: curr_res_type = %d resp[0] = %#0x err = %d state = %#0x\n", \
+				       mmc_hostname(host->mmc), host->curr_res_type, cmd->resp[0], cmd->error, \
+				       REG_MSC_STAT(host->pdev_id));	\
+	})
+
+#define TRACE_DATA_REQ()						\
+	({								\
+		if ((jzmmc_trace_id & (1 << host->pdev_id)) && (jzmmc_trace_level & 0x2) && host->curr_mrq->data ) { \
+			if ((jzmmc_trace_data_len == -1) ||		\
+			    (jzmmc_trace_data_len == host->curr_mrq->data->blksz * host->curr_mrq->data->blocks) ) \
+				printk("%s:     blksz %d blocks %d flags %08x "	\
+				       "tsac %d ms nsac %d\n",		\
+				       mmc_hostname(host->mmc), host->curr_mrq->data->blksz, \
+				       host->curr_mrq->data->blocks, host->curr_mrq->data->flags, \
+				       host->curr_mrq->data->timeout_ns / 1000000, \
+				       host->curr_mrq->data->timeout_clks); \
+		}							\
+	})
+
+#define TRACE_DATA_DONE()						\
+	({								\
+		if ((jzmmc_trace_id & (1 << host->pdev_id)) && (jzmmc_trace_level & 0x2)) \
+			if ((jzmmc_trace_data_len == -1) ||		\
+			    (jzmmc_trace_data_len == data->blksz * data->blocks) ) \
+				printk("%s:     stat = 0x%08x error = %d bytes_xfered = %d stop = %p\n", \
+				       mmc_hostname(host->mmc), stat, data->error, \
+				       data->bytes_xfered, host->curr_mrq->stop); \
+	})
+
+#define JZ_MMC_P_REG_BY_ID(reg_name, id) \
+  printk("" #reg_name "(%d) = 0x%08x\n", id, reg_name(id))
+
+void jz_mmc_dump_regs(int msc_id, int line) {
+        printk("***** msc%d regs, line = %d *****\n", msc_id, line);
+
+	JZ_MMC_P_REG_BY_ID(REG_MSC_STRPCL, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_STAT, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_CLKRT, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_CMDAT, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_RESTO, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_RDTO, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_BLKLEN, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_NOB, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_SNOB, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_IMASK, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_IREG, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_CMD, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_ARG, msc_id);
+	//JZ_MMC_P_REG_BY_ID(REG_MSC_RES, msc_id);
+	//JZ_MMC_P_REG_BY_ID(REG_MSC_RXFIFO, msc_id);
+	//JZ_MMC_P_REG_BY_ID(REG_MSC_TXFIFO, msc_id);
+	JZ_MMC_P_REG_BY_ID(REG_MSC_LPM, msc_id);
+}
+EXPORT_SYMBOL(jz_mmc_dump_regs);
+
+#else
+#define TRACE_CMD_REQ() do {  } while(0)
+#define TRACE_CMD_RES() do {  } while(0)
+#define TRACE_DATA_REQ() do {  } while(0)
+#define TRACE_DATA_DONE() do {  } while(0)
+#define jz_mmc_dump_regs(__mid, __ln) do {  } while(0)
+#endif
+
+void jz_mmc_set_clock(struct jz_mmc_host *host, int rate);
+static int jz_mmc_data_done(struct jz_mmc_host *host);
+
+static void msc_irq_mask_all(int msc_id)
+{
+	REG_MSC_IMASK(msc_id) = 0xffff;
+	REG_MSC_IREG(msc_id) = 0xffff;
+}
+
+void jz_mmc_reset(struct jz_mmc_host *host)
+{
+	u32 clkrt = REG_MSC_CLKRT(host->pdev_id);
+
+//	while (REG_MSC_STAT(host->pdev_id) & MSC_STAT_CLK_EN);     
+	
+	REG_MSC_STRPCL(host->pdev_id) = MSC_STRPCL_RESET;
+ 	while (REG_MSC_STAT(host->pdev_id) & MSC_STAT_IS_RESETTING);
+
+	// __msc_start_clk(host->pdev_id);
+	REG_MSC_LPM(host->pdev_id) = 0x1;	// Low power mode
+	msc_irq_mask_all(host->pdev_id);
+
+	REG_MSC_RDTO(host->pdev_id) = 0xffffffff;
+	REG_MSC_RESTO(host->pdev_id) = 0xff;
+
+	REG_MSC_CLKRT(host->pdev_id) = clkrt;
+}
+
+static inline int msc_calc_clkrt(int is_low, u32 rate)
+{
+	u32 clkrt;
+	u32 clk_src = is_low ? 24000000 : 48000000;
+
+	clkrt = 0;
+	while (rate < clk_src) {
+		clkrt++;
+		clk_src >>= 1;
+	}
+	return clkrt;
+}
+
+void jz_mmc_set_clock(struct jz_mmc_host *host, int rate)
+{
+	int clkrt;
+
+	/* __cpm_select_msc_clk_high will select 48M clock for MMC/SD card
+	 * perhaps this will made some card with bad quality init fail,or
+	 * bad stabilization.
+	*/
+
+	// Cause there is only ONE devider in CPM, the clock must only <= 24MHz
+	/* __cpm_select_msc_clk_high will select 48M clock for MMC/SD card
+	 * perhaps this will made some card with bad quality init fail,or
+	 * bad stabilization.
+	*/
+	if (rate > SD_CLOCK_FAST) {
+		rate = SD_CLOCK_FAST;
+		__cpm_select_msc_clk_high(host->pdev_id,1);	/* select clock source from CPM */
+
+		//		__cpm_select_msc_clk(host->pdev_id,1);	/* select clock source from CPM */
+		clkrt = msc_calc_clkrt(0, rate);
+	} else {
+		__cpm_select_msc_clk(host->pdev_id,1);	/* select clock source from CPM */
+		clkrt = msc_calc_clkrt(1, rate);
+	}
+
+	// printk("clock rate = %d\n", __cpm_get_mscclk(0));
+	REG_MSC_CLKRT(host->pdev_id) = clkrt;
+}
+
+static void jz_mmc_enable_irq(struct jz_mmc_host *host, unsigned int mask)
+{
+	REG_MSC_IMASK(host->pdev_id) &= ~mask;
+}
+
+static void jz_mmc_disable_irq(struct jz_mmc_host *host, unsigned int mask)
+{
+	REG_MSC_IMASK(host->pdev_id) |= mask;
+}
+
+static int jz_mmc_parse_cmd_response(struct jz_mmc_host *host, unsigned int stat)
+{
+	struct mmc_command *cmd = host->curr_mrq->cmd;
+	int i, temp[16] = {0};
+	unsigned char *buf;
+	unsigned int res, v, w1, w2;
+
+	if (!cmd)
+		return -EINVAL;
+
+	/* NOTE: we must flush the FIFO,  despite of fail or success*/
+	buf = (u8 *) temp;
+	switch (host->curr_res_type) {
+	case 1:
+		{
+			/*
+			 * Did I mention this is Sick.  We always need to
+			 * discard the upper 8 bits of the first 16-bit word.
+			 */
+
+			res = REG_MSC_RES(host->pdev_id);
+			buf[0] = (res >> 8) & 0xff;
+			buf[1] = res & 0xff;
+
+			res = REG_MSC_RES(host->pdev_id);
+			buf[2] = (res >> 8) & 0xff;
+			buf[3] = res & 0xff;
+
+			res = REG_MSC_RES(host->pdev_id);
+			buf[4] = res & 0xff;
+
+			cmd->resp[0] =
+				buf[1] << 24 | buf[2] << 16 | buf[3] << 8 |
+				buf[4];
+
+			// printk("opcode = %d, cmd->resp = 0x%08x\n", cmd->opcode, cmd->resp[0]);
+			break;
+		}
+	case 2:
+		{
+			res = REG_MSC_RES(host->pdev_id);
+			v = res & 0xffff;
+			for (i = 0; i < 4; i++) {
+				res = REG_MSC_RES(host->pdev_id);
+				w1 = res & 0xffff;
+				res = REG_MSC_RES(host->pdev_id);
+				w2 = res & 0xffff;
+				cmd->resp[i] = v << 24 | w1 << 8 | w2 >> 8;
+				v = w2;
+			}
+			break;
+		}
+	case 0:
+		break;
+	}
+
+	if (stat & MSC_STAT_TIME_OUT_RES) {
+		/* :-( our customer do not want to see SO MANY timeouts :-(
+		   so only CMD5 can return timeout error!!! */
+
+		/*
+		 * Note: we can not return timeout when CMD SD_SWITCH or MMC_SWITCH
+		 * because we declared that out host->caps support MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA and MMC_CAP_MMC_HIGHSPEED
+		 * if in the future some error occured because of this, we must add some code to remember
+		 * which mode(SDIO/SD/MMC)  the MSC is in
+		 */
+		switch(cmd->opcode) {
+		case SD_IO_SEND_OP_COND:
+			//case SD_SWITCH:
+			//case MMC_SWITCH:
+		case SD_SEND_IF_COND:
+		case MMC_APP_CMD:
+			cmd->error = -ETIMEDOUT;
+			break;
+		default:
+			/* silly, isn't it??? */
+			printk("jz-msc%d: ignored MSC_STAT_TIME_OUT_RES, cmd=%d\n", host->pdev_id, cmd->opcode);
+		}
+	} else if (stat & MSC_STAT_CRC_RES_ERR && cmd->flags & MMC_RSP_CRC) {
+		printk("jz-msc%d: MSC_STAT_CRC, cmd=%d\n", host->pdev_id, cmd->opcode);
+		if (cmd->opcode == MMC_ALL_SEND_CID ||
+		    cmd->opcode == MMC_SEND_CSD ||
+		    cmd->opcode == MMC_SEND_CID) {
+			/* a bogus CRC error can appear if the msb of
+			   the 15 byte response is a one */
+			if ((cmd->resp[0] & 0x80000000) == 0)
+				cmd->error = -EILSEQ;
+		}
+	}
+
+	TRACE_CMD_RES();
+
+	return cmd->error;
+}
+
+extern void jz_mmc_start_pio(struct jz_mmc_host *host);
+
+void jz_mmc_data_start(struct jz_mmc_host *host)
+{
+	struct mmc_data *data = host->curr_mrq->data;
+	unsigned int nob = data->blocks;
+	unsigned int block_size = data->blksz;
+
+	/* NOTE: this flag is never test! */
+	if (data->flags & MMC_DATA_STREAM)
+		nob = 0xffff;
+
+	REG_MSC_NOB(host->pdev_id) = nob;
+	REG_MSC_BLKLEN(host->pdev_id) = block_size;
+
+#ifdef JZ_MSC_USE_PIO
+	jz_mmc_start_pio(host);
+#endif
+#ifdef JZ_MSC_USE_DMA
+	jz_mmc_start_dma(host);
+#endif
+}
+
+volatile u32 junk = 0;
+EXPORT_SYMBOL(junk);
+
+void jz_mmc_data_stop(struct jz_mmc_host *host) {
+	int junked = 1;
+
+#ifdef JZ_MSC_USE_PIO
+	jz_mmc_stop_pio(host);
+#endif
+#ifdef JZ_MSC_USE_DMA
+	jz_mmc_stop_dma(host);
+#endif
+
+	/* What if the data not arrived imediately? our while exits, but data remain in fifo! */
+	while (!(REG_MSC_STAT(host->pdev_id) & MSC_STAT_DATA_FIFO_EMPTY)) {
+		if (junked)
+			jz_mmc_dump_regs(host->pdev_id, __LINE__);
+		junked = 0;
+		junk = REG_MSC_RXFIFO(host->pdev_id);
+		printk("warning: fifo not empty when dma stopped!!! junk = 0x%08x\n", junk);
+	}
+}
+
+static int need_wait_prog_done(struct mmc_command *cmd) {
+	if (cmd->flags & MMC_RSP_BUSY) {
+		return 1;
+	} else {
+		switch(cmd->opcode) { /* R1b cmds need wait PROG_DONE */
+		case 12:
+		case 28:
+		case 29:
+		case 38:
+			return 1;
+			break;
+		default:
+			/* do nothing */
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static void jz_mmc_set_cmdat(struct jz_mmc_host *host) {
+	struct mmc_request *mrq = host->curr_mrq;
+	struct mmc_command *cmd = mrq->cmd;
+	u32 cmdat;
+
+	cmdat = host->cmdat;
+	rmb();
+	host->cmdat &= ~MSC_CMDAT_INIT;
+
+	if(mrq->data) {
+		cmdat &= ~MSC_CMDAT_BUSY;
+
+		if ((cmd->opcode == 51) | (cmd->opcode == 8)) {
+			cmdat &= ~MSC_CMDAT_BUS_WIDTH_MASK;
+			cmdat |= MSC_CMDAT_BUS_WIDTH_1BIT | MSC_CMDAT_DATA_EN;
+		} else
+			cmdat |= MSC_CMDAT_DATA_EN;
+
+		cmdat |= MSC_CMDAT_DMA_EN;
+
+		if (mrq->data->flags & MMC_DATA_WRITE)
+			cmdat |= MSC_CMDAT_WRITE;
+
+		if (mrq->data->flags & MMC_DATA_STREAM)
+			cmdat |= MSC_CMDAT_STREAM_BLOCK;
+	}
+
+	if (cmd->flags & MMC_RSP_BUSY)
+		cmdat |= MSC_CMDAT_BUSY;
+
+	switch (RSP_TYPE(mmc_resp_type(cmd))) {
+	case RSP_TYPE(MMC_RSP_R1):	// r1, r1b, r5, r6, r7
+		cmdat |= MSC_CMDAT_RESPONSE_R1;
+		host->curr_res_type = 1;
+		break;
+	case RSP_TYPE(MMC_RSP_R3):	// r3, r4
+		cmdat |= MSC_CMDAT_RESPONSE_R3;
+		host->curr_res_type = 1;
+		break;
+	case RSP_TYPE(MMC_RSP_R2):	// r2
+		cmdat |= MSC_CMDAT_RESPONSE_R2;
+		host->curr_res_type = 2;
+		break;
+	default:
+		break;
+	}
+
+	// Multi-read || Multi-write
+	//if(cmd->opcode == MMC_READ_MULTIPLE_BLOCK || cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK)
+	if (host->curr_mrq->stop)
+		cmdat |= MSC_CMDAT_SEND_AS_STOP;
+
+#ifdef USE_DMA_BUSRT_64
+	cmdat |= MSC_CMDAT_RTRG_EQUALT_16 | MSC_CMDAT_TTRG_LESS_16;
+#endif
+	REG_MSC_CMDAT(host->pdev_id) = cmdat;
+}
+
+static void jz_mmc_set_cmdarg(struct jz_mmc_host *host) {
+	struct mmc_command *cmd = host->curr_mrq->cmd;
+
+	if(host->plat->bus_width == 1) {
+		if (cmd->opcode == 6) {
+			/* set  1 bit sd card bus*/
+			if (cmd->arg == 2) {
+				REG_MSC_ARG(host->pdev_id) = 0;
+			}
+
+			/* set  1 bit mmc card bus*/
+			if (cmd->arg == 0x3b70101) {
+				REG_MSC_ARG(host->pdev_id) = 0x3b70001;
+			}
+		} else
+			REG_MSC_ARG(host->pdev_id) = cmd->arg;
+	} else if(host->plat->bus_width == 8) {
+		if (cmd->opcode == 6) {
+			/* set  8 bit mmc card bus*/
+			if (cmd->arg == 0x3b70101) {
+				REG_MSC_ARG(host->pdev_id) = 0x3b70201;
+			} else
+				REG_MSC_ARG(host->pdev_id) = cmd->arg;
+		} else
+			REG_MSC_ARG(host->pdev_id) = cmd->arg;
+	} else
+		REG_MSC_ARG(host->pdev_id) = cmd->arg;
+}
+
+#if 0
+static void jz_mmc_status_checker(unsigned long arg) {
+	struct jz_mmc_host *host = (struct jz_mmc_host *)arg;
+
+	host->status = REG_MSC_STAT(host->pdev_id);
+	if ((host->status & host->st_mask) || (host->eject)) {
+		if (host->en_usr_intr)
+			wake_up_interruptible(&host->status_check_queue);
+		else
+			wake_up(&host->status_check_queue);
+	} else if ((host->st_check_timeout < 0) ||
+		 (host->st_check_timeout > host->st_check_interval)) {
+		if (host->st_check_timeout < 0)
+			host->st_check_timeout -= host->st_check_interval;
+		host->status_check_timer.expires = jiffies + host->st_check_interval;
+		host->status_check_timer.data = (unsigned long)host;
+
+
+		add_timer(&host->status_check_timer);
+	} else {
+		host->st_check_timeout = 0;
+		wake_up_interruptible(&host->status_check_queue);
+	}
+}
+
+
+/**
+  * timeout: -1 for wait forever until contition meet, otherwise the timeout value in jiffies
+  * en_usr_intr: if allow user interrupt
+  * Warning: if timeout == 0 && en_usr_intr == 0, this will wait forever if the condition never meet
+ **/
+static u32 jz_mmc_wait_status(struct jz_mmc_host *host, u32 st_mask,
+			      int timeout, int interval, int en_usr_intr) {
+	int ret = 0;
+
+	init_timer(&host->status_check_timer);
+	host->status_check_timer.expires = jiffies + interval;
+	host->status_check_timer.data = (unsigned long)host;
+	host->status = 0;
+	host->st_mask = st_mask;
+	host->st_check_timeout = timeout;
+	host->st_check_interval = interval;
+	host->en_usr_intr = en_usr_intr;
+
+	add_timer(&host->status_check_timer);
+
+	if (en_usr_intr)
+		ret = wait_event_interruptible(host->status_check_queue,
+					       (host->status & st_mask) ||
+					       (host->st_check_timeout == 0) ||
+					       (host->eject));
+	else
+		wait_event(host->status_check_queue,
+			   (host->status & st_mask) ||
+			   (host->st_check_timeout == 0) ||
+			   (host->eject));
+
+	/* in case when the condition is meet before wait_event, the timer must del right away */
+	del_timer_sync(&host->status_check_timer);
+	return ret;
+}
+#endif
+
+//int wait_cmd_done = 0;
+//extern volatile int error_may_happen;
+
+static u32 jz_mmc_wait_cmd_done(struct jz_mmc_host *host) {
+	u32 timeout = 0x7fffffff;
+	struct mmc_command *cmd = host->curr_mrq->cmd;
+	int cmd_succ = 0;
+	u32 stat = 0;
+
+#if 0
+	/* this may slow down the card response from the usrs' view, but more friendly to other kernel parts */
+	jz_mmc_wait_status(host, MSC_STAT_END_CMD_RES | MSC_STAT_TIME_OUT_RES | MSC_STAT_CRC_RES_ERR,
+			   -1, 1, 0); /* interval: 1jiffie = 10ms */
+#else
+	//wait_cmd_done = 1;
+	while (!(REG_MSC_STAT(host->pdev_id) & (MSC_STAT_END_CMD_RES | MSC_STAT_TIME_OUT_RES | MSC_STAT_CRC_RES_ERR)) &&
+	       (host->eject == 0)) {
+#if 0
+		if (error_may_happen)
+			jz_mmc_dump_regs(host->pdev_id, __LINE__);
+#endif
+	}
+	//error_may_happen = 0;
+	//wait_cmd_done = 0;
+#endif
+
+	if (REG_MSC_STAT(host->pdev_id) & MSC_STAT_TIME_OUT_RES)
+		cmd->error = -ETIMEDOUT;
+	if (host->eject) {
+		/* wait response timeout */
+		//printk("===>eject!!! state = 0x%08x\n", REG_MSC_STAT(host->pdev_id));
+		//while (!(REG_MSC_STAT(host->pdev_id) & (MSC_STAT_END_CMD_RES | MSC_STAT_TIME_OUT_RES | MSC_STAT_CRC_RES_ERR)));
+		cmd->error = -ENOMEDIUM;
+	}
+
+	/* Check for status, avoid be cleaned by following command*/
+	stat = REG_MSC_STAT(host->pdev_id);
+	if ((stat & MSC_STAT_END_CMD_RES) &&
+	    !(stat & (MSC_STAT_TIME_OUT_RES | MSC_STAT_CRC_RES_ERR)))
+		cmd_succ = 1;
+
+	REG_MSC_IREG(host->pdev_id) = MSC_IREG_END_CMD_RES;	/* clear irq flag */
+
+	if (cmd_succ && need_wait_prog_done(cmd)) {
+		timeout = 0x7fffffff;
+		while (--timeout && !(REG_MSC_IREG(host->pdev_id) & MSC_IREG_PRG_DONE) && (host->eject == 0))
+			;
+
+		stat |= (REG_MSC_STAT(host->pdev_id) & MSC_STAT_ERR_BITS);
+		REG_MSC_IREG(host->pdev_id) = MSC_IREG_PRG_DONE;	/* clear status */
+		if ((timeout == 0) || (host->eject)) {
+			cmd->error = -ETIMEDOUT;
+			printk("JZ-MSC%d: wait prog_done error when execute_cmd!, state = 0x%08x\n", host->pdev_id, stat);
+		}
+	}
+
+	return stat;
+}
+
+static void jz_mmc_send_stop_cmd(struct jz_mmc_host *host) {
+	struct mmc_command *stop_cmd = host->curr_mrq->stop;
+
+	REG_MSC_CMD(host->pdev_id) = stop_cmd->opcode;
+	REG_MSC_ARG(host->pdev_id) = stop_cmd->arg;
+
+	REG_MSC_CMDAT(host->pdev_id) = MSC_CMDAT_BUSY | MSC_CMDAT_RESPONSE_R1;
+
+	REG_MSC_RESTO(host->pdev_id) = 0xff;
+
+	REG_MSC_STRPCL(host->pdev_id) |= MSC_STRPCL_START_OP;
+
+	/* Becarefull, maybe endless */
+	while(!(REG_MSC_STAT(host->pdev_id) & (MSC_STAT_PRG_DONE | MSC_STAT_ERR_BITS)) &&
+	      !host->eject) ;
+
+	if (REG_MSC_STAT(host->pdev_id) | MSC_STAT_ERR_BITS)
+		stop_cmd->error = -ETIMEDOUT;
+
+	REG_MSC_IREG(host->pdev_id) = MSC_IREG_PRG_DONE;
+}
+
+static int jz_mmc_data_done(struct jz_mmc_host *host)
+{
+	struct mmc_data *data = host->curr_mrq->data;
+	int stat = 0;
+	u32 timeout = 0x7fffffff;
+
+	if (!data)
+		return -EINVAL;
+
+	stat = REG_MSC_STAT(host->pdev_id);
+	REG_MSC_IREG(host->pdev_id) = MSC_IREG_DATA_TRAN_DONE;	/* clear status */
+
+	if (host->curr_mrq && (host->curr_mrq->data->flags & MMC_DATA_WRITE)) {
+		while (--timeout && !(REG_MSC_IREG(host->pdev_id) & MSC_IREG_PRG_DONE))
+			;
+		if (timeout == 0) {
+			/* FIXME: aha, we never see this situation happen, what can we do if it happened???
+			 * block.c will send cmd13??? */
+			//host->curr.mrq->cmd->error = -ETIMEDOUT;
+			printk(KERN_ERR"PRG_DONE not done!!!\n");
+		}
+		stat |= REG_MSC_STAT(host->pdev_id);
+		REG_MSC_IREG(host->pdev_id) = MSC_IREG_PRG_DONE;	/* clear status */
+	}
+
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma.len,
+		     host->dma.dir);
+
+	if (stat & MSC_STAT_TIME_OUT_READ) {
+		printk("MMC/SD/SDIO timeout, MMC_STAT 0x%x opcode = %d data flags = 0x%0x blocks = %d blksz = %d\n",
+		       stat,
+		       host->curr_mrq? host->curr_mrq->cmd->opcode : -1,
+		       data->flags,
+		       data->blocks,
+		       data->blksz);
+		data->error = -ETIMEDOUT;
+	} else if (stat & (MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR)) {
+		printk("jz-msc%d: MMC/SD/SDIO CRC error, MMC_STAT 0x%x, cmd=%d\n",
+		       host->pdev_id, stat,
+		       host->curr_mrq? host->curr_mrq->cmd->opcode : -1);
+		data->error = -EILSEQ;
+	}
+	/*
+	 * There appears to be a hardware design bug here.  There seems to
+	 * be no way to find out how much data was transferred to the card.
+	 * This means that if there was an error on any block, we mark all
+	 * data blocks as being in error.
+	 */
+	if (data->error == 0)
+		data->bytes_xfered = data->blocks * data->blksz;
+	else
+		data->bytes_xfered = 0;
+
+	TRACE_DATA_DONE();
+
+	// jz_mmc_disable_irq(host, MSC_IMASK_DATA_TRAN_DONE);
+	if (host->curr_mrq->stop) {
+		if ((!(REG_MSC_STAT(host->pdev_id) & MSC_STAT_AUTO_CMD_DONE)) && data->error)
+			jz_mmc_send_stop_cmd(host);
+		else
+			while(!(REG_MSC_STAT(host->pdev_id) & (MSC_STAT_AUTO_CMD_DONE | MSC_STAT_ERR_BITS)) &&
+			      !host->eject) ;
+
+		REG_MSC_CMDAT(host->pdev_id) &= ~(MSC_CMDAT_SEND_AS_STOP);
+	}
+
+	if (host->data_err) {
+		data->bytes_xfered = 0;
+		host->data_err = 0;
+	}
+
+	return 0;
+}
+
+static void jz_mmc_execute_cmd(struct jz_mmc_host *host)
+{
+	struct mmc_request *mrq = host->curr_mrq;
+	struct mmc_data *data = mrq->data;
+	struct mmc_command *cmd = mrq->cmd;
+	unsigned int stat;
+	int err = 0;
+
+	/* mask interrupts */
+	REG_MSC_IMASK(host->pdev_id) = 0xffff;
+	/* clear status */
+	REG_MSC_IREG(host->pdev_id) = 0xffff;
+
+	jz_mmc_set_cmdat(host);
+	REG_MSC_CMD(host->pdev_id) = cmd->opcode;
+	jz_mmc_set_cmdarg(host);
+
+	/* reset NOB and BLKLEN */
+	//REG_MSC_NOB(host->pdev_id) = 0;
+	//REG_MSC_BLKLEN(host->pdev_id) = 0;
+
+	TRACE_CMD_REQ();
+
+	if(data && (data->flags & MMC_DATA_READ))
+		jz_mmc_data_start(host);
+
+	REG_MSC_RESTO(host->pdev_id) = 0xff;
+	/* Send command */
+	REG_MSC_STRPCL(host->pdev_id) = MSC_STRPCL_START_OP;
+	stat = jz_mmc_wait_cmd_done(host);
+	if (cmd->error)
+		goto cmd_err;
+
+	TRACE_DATA_REQ();
+
+	if (jz_mmc_parse_cmd_response(host, stat))
+		goto cmd_err;
+
+	if (host->curr_mrq->data) {
+		int acked = 0;
+		if(host->curr_mrq->data->flags & MMC_DATA_WRITE) {
+			jz_mmc_enable_irq(host, MSC_IMASK_DATA_TRAN_DONE);
+			jz_mmc_data_start(host);
+		}
+
+		err = wait_event_interruptible_timeout(host->data_wait_queue,
+						       ((host->data_ack) || (host->eject)
+							|| (REG_MSC_STAT(host->pdev_id) & WAITMASK)),
+						       6 * HZ);
+
+		while(!((REG_MSC_STAT(host->pdev_id) & MSC_STAT_DATA_TRAN_DONE) || (host->eject)));
+		REG_MSC_STAT(host->pdev_id) &= ~(MSC_STAT_DATA_TRAN_DONE);
+
+		acked = host->data_ack;
+		host->data_ack = 0;
+
+		if (acked)
+			jz_mmc_data_done(host);
+		else {
+			if (err == -ERESTARTSYS) /* user cancelled */
+				cmd->error = -ECANCELED;
+			else if (!err) {
+				printk("Timeout while IRQ_dma, opcode = %d\n", cmd->opcode);
+				printk("REG_MSC_STAT(host->pdev_id) = %x\n", REG_MSC_STAT(host->pdev_id));
+				jz_mmc_dump_regs(host->pdev_id, __LINE__);
+				cmd->error = -ETIMEDOUT;
+			}
+			goto data_wait_err;
+		}
+
+	}
+	return;
+
+ cmd_err:
+#if 0
+	if (host->eject)
+		printk("WARNNING: media eject when sending cmd, opcode = %d\n", cmd->opcode);
+#endif
+ data_wait_err:
+	if (host->curr_mrq->data){
+		host->curr_mrq->data->bytes_xfered = 0;
+
+#if 0
+		if (host->eject)
+			printk("WARNNING: media eject when transfering data, opcode = %d err = %d\n", cmd->opcode, err);
+#endif
+	}
+
+	if (host->eject)
+		cmd->error = -ENOMEDIUM;
+
+	if (host->curr_mrq->data)
+		jz_mmc_data_stop(host);
+}
+
+static irqreturn_t jz_mmc_irq(int irq, void *devid)
+{
+	struct jz_mmc_host *host = devid;
+	unsigned int ireg = 0;
+
+	ireg = REG_MSC_IREG(host->pdev_id);
+	if (ireg) {
+		if (ireg & MSC_IREG_DATA_TRAN_DONE) {
+			jz_mmc_disable_irq(host, MSC_IMASK_DATA_TRAN_DONE);
+			BUG_ON(host->data_ack);
+			host->data_ack = 1;
+			wmb();
+			wake_up_interruptible(&host->data_wait_queue);
+		}
+	}
+
+
+	return IRQ_HANDLED;
+}
+
+static char *msc_trans_irq_name[] = {
+	"msc_trans_0",
+	"msc_trans_1",
+	"msc_trans_2",
+};
+
+static int jz_mmc_msc_init(struct jz_mmc_host *host)
+{
+	int ret = 0;
+
+	jz_mmc_reset(host);
+
+	host->data_ack = 0;
+	init_waitqueue_head(&host->data_wait_queue);
+#if 0
+	init_waitqueue_head(&host->status_check_queue);
+	init_timer(&host->status_check_timer);
+	host->status_check_timer.function = jz_mmc_status_checker;
+#endif
+
+	ret = request_irq(host->irq, jz_mmc_irq, 0, msc_trans_irq_name[host->pdev_id], host);
+	if (ret) {
+		printk(KERN_ERR "MMC/SD: can't request MMC/SD IRQ\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void jz_mmc_msc_deinit(struct jz_mmc_host *host)
+{
+	free_irq(host->irq, &host);
+}
+
+int jz_mmc_msc_register(struct jz_mmc_msc *msc)
+{
+	if(msc == NULL)
+		return -ENOMEM;
+
+	msc->init = jz_mmc_msc_init;
+	msc->deinit = jz_mmc_msc_deinit;
+	msc->set_clock = jz_mmc_set_clock;
+	msc->execute_cmd = jz_mmc_execute_cmd;
+
+	return 0;
+}
diff --git a/drivers/mmc/host/jzmmc/jz_mmc_pio.c b/drivers/mmc/host/jzmmc/jz_mmc_pio.c
new file mode 100644
index 0000000..7c84900
--- /dev/null
+++ b/drivers/mmc/host/jzmmc/jz_mmc_pio.c
@@ -0,0 +1,100 @@
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/scatterlist.h>
+#include <linux/kthread.h>
+#include <asm/jzsoc.h>
+#include "include/jz_mmc_dma.h"
+#include "include/jz_mmc_host.h"
+
+#ifdef JZ_MSC_USE_PIO
+
+static int jz_mmc_pio_read(struct jz_mmc_host *host, unsigned int *buf, int len) {
+	int i = 0;
+
+	for (i = 0; i < len; i++) {
+		while ((REG_MSC_STAT(host->pdev_id) & (MSC_STAT_DATA_FIFO_EMPTY | MSC_STAT_TIME_OUT_READ)) &&
+		       !host->eject)
+			;
+		if (host->eject)
+			return -ENOMEDIUM;
+
+		if (REG_MSC_STAT(host->pdev_id) & MSC_STAT_TIME_OUT_READ)
+			return -ETIMEDOUT;
+
+		*buf = REG_MSC_RXFIFO(host->pdev_id);
+		buf++;
+	}
+
+	return 0;
+}
+
+static int jz_mmc_pio_write(struct jz_mmc_host *host, unsigned int *buf, int len) {
+	int i = 0;
+
+	for (i = 0; i < len; i++) {
+		while ((REG_MSC_STAT(host->pdev_id) & MSC_STAT_DATA_FIFO_FULL) && !host->eject)
+			;
+		if (host->eject)
+			return -ENOMEDIUM;
+
+		REG_MSC_TXFIFO(host->pdev_id) = *buf;
+		buf++;
+	}
+
+	return 0;
+}
+
+void jz_mmc_stop_pio(struct jz_mmc_host *host) {
+	while(!host->transfer_end);
+}
+
+static int jz_mmc_data_transfer(void *arg) {
+	struct jz_mmc_host *host = (struct jz_mmc_host *)arg;
+	struct mmc_data *data = host->curr_mrq->data;
+	int is_write = data->flags & MMC_DATA_WRITE;
+	int i = 0;
+	int ret = 0;
+	struct scatterlist *sgentry = NULL;
+	unsigned int *buf = NULL;
+	int len = 0;
+
+	for_each_sg(data->sg, sgentry, data->sg_len, i) {
+		buf = sg_virt(sgentry);
+		len = (sg_dma_len(sgentry)+3) >> 2; /* divide by 4 */
+
+		if (is_write)
+			ret = jz_mmc_pio_write(host, buf, len);
+		else
+			ret = jz_mmc_pio_read(host, buf, len);
+		if (ret) {
+			data->error = ret;
+			break;
+		}
+	}
+
+	if (is_write) {
+		if (ret) {
+			host->data_ack = 0;
+			wake_up_interruptible(&host->data_wait_queue);
+		}
+		/* else, DATA_TRANS_DONE interrupt will raise */
+	} else {
+		if (!ret)
+			host->data_ack = 1;
+		else
+			host->data_ack = 0;
+		wake_up_interruptible(&host->data_wait_queue);
+	}
+
+	host->transfer_end = 1;
+
+	return 0;
+}
+
+void jz_mmc_start_pio(struct jz_mmc_host *host) {
+	REG_MSC_CMDAT(host->pdev_id) &= ~MSC_CMDAT_DMA_EN;
+	host->transfer_end = 0;
+	kthread_run(jz_mmc_data_transfer, (void *)host, "msc pio transfer");
+}
+
+#endif /* JZ_MSC_USE_PIO */
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 2b1ea3d..61dbdd0 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -407,6 +407,10 @@ static unsigned int mem_serial_in(struct uart_port *p, int offset)
 static void mem_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = map_8250_out_reg(p, offset) << p->regshift;
+#if defined(CONFIG_JZSOC)
+		if (offset == (UART_FCR << p->regshift))
+			value |= 0x10; /* set FCR.UUE */
+#endif
 	writeb(value, p->membase + offset);
 }
 
@@ -2209,6 +2213,83 @@ static void serial8250_shutdown(struct uart_port *port)
 		serial_unlink_irq_chain(up);
 }
 
+#if defined(CONFIG_JZSOC) && !defined(CONFIG_SOC_JZ4730)
+static unsigned short quot1[3] = {0}; /* quot[0]:baud_div, quot[1]:umr, quot[2]:uacr */
+static unsigned short * serial8250_get_divisor(struct uart_port *port, unsigned int baud)
+{
+	int err, sum, i, j;
+	int a[12], b[12];
+	unsigned short div, umr, uacr;
+	unsigned short umr_best, div_best, uacr_best;
+	long long t0, t1, t2, t3;
+
+	sum = 0;
+	umr_best = div_best = uacr_best = 0;
+	div = 1;
+
+	if ((port->uartclk % (16 * baud)) == 0) {
+		quot1[0] = port->uartclk / (16 * baud);
+		quot1[1] = 16;
+		quot1[2] = 0;
+		return quot1;
+	}
+
+	while (1) {
+		umr = port->uartclk / (baud * div);
+  		if (umr > 32) {
+			div++;
+			continue;
+		}
+		if (umr < 4) {
+			break;
+		}
+		for (i = 0; i < 12; i++) {
+			a[i] = umr;
+			b[i] = 0;
+			sum = 0;
+			for (j = 0; j <= i; j++) {
+				sum += a[j];
+			}
+
+                        /* the precision could be 1/2^(36) due to the value of t0 */
+			t0 = 0x1000000000LL;
+			t1 = (i + 1) * t0;
+			t2 = (sum * div) * t0;
+			t3 = div * t0;
+			do_div(t1, baud);
+			do_div(t2, port->uartclk);
+			do_div(t3, (2 * port->uartclk));
+			err = t1 - t2 - t3;
+
+			if (err > 0) {
+				a[i] += 1;
+				b[i] = 1;
+			}
+		}
+
+		uacr = 0;
+		for (i = 0; i < 12; i++) {
+			if (b[i] == 1) {
+				uacr |= 1 << i;
+			}
+		}
+
+                /* the best value of umr should be near 16, and the value of uacr should better be smaller */
+		if (abs(umr - 16) < abs(umr_best - 16) || (abs(umr - 16) == abs(umr_best - 16) && uacr_best > uacr)) {
+			div_best = div;
+			umr_best = umr;
+			uacr_best = uacr;
+		}
+		div++;
+	}
+
+	quot1[0] = div_best;
+	quot1[1] = umr_best;
+	quot1[2] = uacr_best;
+
+	return quot1;
+}
+#else
 static unsigned int serial8250_get_divisor(struct uart_port *port, unsigned int baud)
 {
 	unsigned int quot;
@@ -2228,6 +2309,7 @@ static unsigned int serial8250_get_divisor(struct uart_port *port, unsigned int
 
 	return quot;
 }
+#endif
 
 static void
 serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
@@ -2237,6 +2319,9 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 	unsigned char cval, fcr = 0;
 	unsigned long flags;
 	unsigned int baud, quot;
+#if defined(CONFIG_JZSOC) && !defined(CONFIG_SOC_JZ4730)
+	unsigned short *quot1;
+#endif
 
 	switch (termios->c_cflag & CSIZE) {
 	case CS5:
@@ -2271,7 +2356,12 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 	baud = uart_get_baud_rate(port, termios, old,
 				  port->uartclk / 16 / 0xffff,
 				  port->uartclk / 16);
+#if defined(CONFIG_JZSOC)
+	quot1 = serial8250_get_divisor(port, baud);
+	quot = quot1[0]; /* not usefull, just let gcc happy */
+#else
 	quot = serial8250_get_divisor(port, baud);
+#endif
 
 	/*
 	 * Oxford Semi 952 rev B workaround
@@ -2349,6 +2439,10 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 	if (up->capabilities & UART_CAP_UUE)
 		up->ier |= UART_IER_UUE | UART_IER_RTOIE;
 
+#ifdef CONFIG_JZSOC
+	up->ier |= UART_IER_RTOIE; /* Set this flag, or very slow */
+#endif
+
 	serial_out(up, UART_IER, up->ier);
 
 	if (up->capabilities & UART_CAP_EFR) {
@@ -2383,7 +2477,15 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
 	}
 
+#if defined(CONFIG_JZSOC) && !defined(CONFIG_SOC_JZ4730)
+#define UART_UMR  9
+#define UART_UACR 10
+	serial_dl_write(up, quot1[0]);
+	serial_outp(up, UART_UMR, quot1[1]);
+	serial_outp(up, UART_UACR, quot1[2]);
+#else
 	serial_dl_write(up, quot);
+#endif
 
 	/*
 	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
@@ -2856,6 +2958,7 @@ static int __init serial8250_console_init(void)
 		nr_uarts = UART_NR;
 
 	serial8250_isa_init_ports();
+
 	register_console(&serial8250_console);
 	return 0;
 }
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 6a58cb1..5c70400 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -46,6 +46,7 @@ config USB_ARCH_HAS_OHCI
 	default y if PPC_MPC52xx
 	# MIPS:
 	default y if SOC_AU1X00
+	default y if JZSOC
 	# SH:
 	default y if CPU_SUBTYPE_SH7720
 	default y if CPU_SUBTYPE_SH7721
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 0940ccd..5391409 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -83,6 +83,31 @@ struct usb_hub {
 	void			**port_owners;
 };
 
+#if defined (CONFIG_USB_OHCI_HCD) && (CONFIG_JZSOC)
+/* JZ USB Root Hub Workaround - River. */
+static inline int is_root_hub(struct usb_device *udev)
+{
+	return (udev->parent == NULL);
+}
+
+static inline int jz_usb_hub_workaround(struct usb_hub *hub, int port1)
+{
+	if (!is_root_hub(hub->hdev))
+		return 0;
+
+#if defined(CONFIG_SOC_JZ4750D)
+	/*
+	 * On Jz4740 and Jz4750, the second USB port was used as device.
+	 */
+	if ((port1 == 2)) {
+		return 1;
+	}
+#endif
+	return 0;
+}
+#else
+#define jz_usb_hub_workaround(hub, port1) 0
+#endif
 
 /* Protect struct usb_device->state and ->children members
  * Note: Both are also protected by ->dev.sem, except that ->state can
@@ -1999,6 +2024,9 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 	int i, status;
 	struct usb_hcd *hcd;
 
+	if (jz_usb_hub_workaround(hub, port1))
+		return 0;
+
 	hcd = bus_to_hcd(udev->bus);
 	/* Block EHCI CF initialization during the port reset.
 	 * Some companion controllers don't like it when they mix.
@@ -2961,6 +2989,9 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 	struct usb_device *udev;
 	int status, i;
 
+	if (jz_usb_hub_workaround(hub, port1))
+		return;
+
 	dev_dbg (hub_dev,
 		"port %d, status %04x, change %04x, %s\n",
 		port1, portstatus, portchange, portspeed (portstatus));
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 11a3e0f..5649e90 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -121,6 +121,23 @@ choice
 #
 # Integrated controllers
 #
+config USB_GADGET_JZ4750D
+	boolean "JZ4750D UDC"
+	depends on SOC_JZ4750D
+	select USB_GADGET_DUALSPEED
+	help
+	   Select this to support the Ingenic JZ4750D processor
+	   high speed USB device controller.
+
+config USB_JZ4750D
+	tristate
+	depends on USB_GADGET_JZ4750D
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
+config JZ_UDC_HOTPLUG
+	bool "Support Ingenic USB Device Controller Hotplug"
+	depends on JZSOC
 
 config USB_GADGET_AT91
 	boolean "Atmel AT91 USB Device Port"
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 43b51da..10214a0 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX)	+= ci13xxx_udc.o
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
+obj-$(CONFIG_USB_JZ4750D)	+= jz4740_udc.o
 
 #
 # USB gadget drivers
diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 3568de2..56ddca0 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -139,6 +139,7 @@ ep_matches (
 		if (!gadget->is_dualspeed && max > 64)
 			return 0;
 		/* FALLTHROUGH */
+		break;
 
 	case USB_ENDPOINT_XFER_ISOC:
 		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index b49d86e..27a8fb5 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -324,8 +324,8 @@ static struct {
 } mod_data = {					// Default values
 	.transport_parm		= "BBB",
 	.protocol_parm		= "SCSI",
-	.removable		= 0,
-	.can_stall		= 1,
+	.removable		= 1,
+	.can_stall		= 0,
 	.cdrom			= 0,
 	.vendor			= FSG_VENDOR_ID,
 	.product		= FSG_PRODUCT_ID,
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index e511fec..4fb4612 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -15,6 +15,12 @@
 #ifndef __GADGET_CHIPS_H
 #define __GADGET_CHIPS_H
 
+#ifdef CONFIG_USB_GADGET_JZ4750D
+#define	gadget_is_jz4750d(g)	!strcmp("jz4740_udc", (g)->name)
+#else
+#define	gadget_is_jz4750d(g)	0
+#endif
+
 #ifdef CONFIG_USB_GADGET_NET2280
 #define	gadget_is_net2280(g)	!strcmp("net2280", (g)->name)
 #else
@@ -200,6 +206,9 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x25;
 	else if (gadget_is_s3c_hsotg(gadget))
 		return 0x26;
+	else if (gadget_is_jz4750d(gadget))
+		return 0x28;
+
 	return -ENOENT;
 }
 
diff --git a/drivers/usb/gadget/jz4740_udc.c b/drivers/usb/gadget/jz4740_udc.c
new file mode 100644
index 0000000..f2e0424
--- /dev/null
+++ b/drivers/usb/gadget/jz4740_udc.c
@@ -0,0 +1,2364 @@
+/*
+ * linux/drivers/usb/gadget/jz4740_udc.c
+ *
+ * Ingenic JZ4740 on-chip high speed USB device controller
+ *
+ * Copyright (C) 2006 - 2008 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/*
+ * This device has ep0, two bulk-in/interrupt-in endpoints, and one bulk-out endpoint.
+ *
+ *  - Endpoint numbering is fixed: ep0, ep1in-int, ep2in-bulk, ep1out-bulk.
+ *  - DMA works with bulk-in (channel 1) and bulk-out (channel 2) endpoints.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/usb.h>
+#include <linux/usb/gadget.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+#include "jz4740_udc.h"
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+#include "udc_hotplug.c"
+#endif
+
+//#define DEBUG(fmt,args...) printk(KERN_DEBUG fmt , ## args)
+//#define DEBUG(fmt,args...) printk(fmt , ## args)
+//#define DEBUG_EP0(fmt,args...) printk(fmt , ## args)
+//#define DEBUG_SETUP(fmt,args...) printk(fmt , ## args)
+
+#ifndef DEBUG
+# define DEBUG(fmt,args...) do {} while(0)
+#endif
+#ifndef DEBUG_EP0
+# define NO_STATES
+# define DEBUG_EP0(fmt,args...) do {} while(0)
+#endif
+#ifndef DEBUG_SETUP
+# define DEBUG_SETUP(fmt,args...) do {} while(0)
+#endif
+
+static unsigned int use_dma = 1;   /* 1: use DMA, 0: use PIO */
+
+module_param(use_dma, int, 0);
+MODULE_PARM_DESC(use_dma, "DMA mode enable flag");
+
+
+/*
+ *  Local definintions.
+ */
+
+#define	DRIVER_VERSION		"13-Mar-2008"
+#define	DRIVER_DESC		"JZ4740 USB Device Controller"
+
+static const char	gadget_name [] = "jz4740_udc";
+
+struct jz4740_udc *the_controller;
+
+static const char driver_name [] = "jz4740_udc";
+static const char driver_desc [] = DRIVER_DESC;
+static const char ep0name[] = "ep0";
+
+#ifndef NO_STATES
+static char *state_names[] = {
+	"WAIT_FOR_SETUP",
+	"DATA_STATE_XMIT",
+	"DATA_STATE_NEED_ZLP",
+	"WAIT_FOR_OUT_STATUS",
+	"DATA_STATE_RECV"
+};
+#endif
+
+//#define TEST_ON_WIN7
+#ifdef TEST_ON_WIN7
+/* used for WIN7 OR VISTA TEST */
+static unsigned int out_flag = 0;
+struct timer_list irq_timer;
+static void irq_timer_func(unsigned long data)
+{
+
+	if (out_flag) {
+		out_flag = 0;
+		printk(" PC removed???.\n");
+	}
+}
+#endif
+
+
+/*
+ * Local declarations.
+ */
+static int jz4740_ep_enable(struct usb_ep *_ep, 
+			    const struct usb_endpoint_descriptor *desc);
+static int jz4740_ep_disable(struct usb_ep *_ep);
+static struct usb_request *jz4740_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags);
+static void jz4740_free_request(struct usb_ep *_ep, struct usb_request *_req);
+
+static int jz4740_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags);
+static int jz4740_dequeue(struct usb_ep *_ep, struct usb_request *_req);
+static int jz4740_set_halt(struct usb_ep *_ep, int value);
+static int jz4740_fifo_status(struct usb_ep *_ep);
+static void jz4740_fifo_flush(struct usb_ep *_ep);
+
+static void jz4740_ep0_kick(struct jz4740_udc *dev, struct jz4740_ep *ep, struct usb_request *req);
+static void jz4740_handle_ep0(struct jz4740_udc *dev, u32 intr);
+
+static void done(struct jz4740_ep *ep, struct jz4740_request *req,
+		 int status);
+static void pio_irq_enable(struct jz4740_ep *ep);
+static void pio_irq_disable(struct jz4740_ep *ep);
+static void stop_activity(struct jz4740_udc *dev,
+			  struct usb_gadget_driver *driver);
+static void nuke(struct jz4740_ep *ep, int status);
+static void flush(struct jz4740_ep *ep);
+static void udc_enable(struct jz4740_udc *dev);
+static void udc_set_address(struct jz4740_udc *dev, unsigned char address);
+static void jz4740_udc_release (struct device *dev) {}
+
+extern void *dma_alloc_noncoherent(struct device *dev, size_t size,
+				   dma_addr_t *dma_handle, gfp_t flag);
+extern void dma_free_noncoherent(struct device *dev, size_t size,
+				 void *vaddr, dma_addr_t dma_handle);
+
+static struct usb_ep_ops jz4740_ep_ops = {
+	.enable		= jz4740_ep_enable,
+	.disable	= jz4740_ep_disable,
+
+	.alloc_request	= jz4740_alloc_request,
+	.free_request	= jz4740_free_request,
+
+	.queue		= jz4740_queue,
+	.dequeue	= jz4740_dequeue,
+
+	.set_halt	= jz4740_set_halt,
+	.fifo_status	= jz4740_fifo_status,
+	.fifo_flush	= jz4740_fifo_flush,
+};
+
+
+/*-------------------------------------------------------------------------*/
+
+/* inline functions of register read/write/set/clear  */
+
+static __inline__ u8 usb_readb(u32 port)
+{
+	return *(volatile u8 *)port;
+}
+
+static __inline__ u16 usb_readw(u32 port)
+{
+	return *(volatile u16 *)port;
+}
+
+static __inline__ u32 usb_readl(u32 port)
+{
+	return *(volatile u32 *)port;
+}
+
+static __inline__ void usb_writeb(u32 port, u8 val)
+{
+	*(volatile u8 *)port = val;
+}
+
+static __inline__ void usb_writew(u32 port, u16 val)
+{
+	*(volatile u16 *)port = val;
+}
+
+static __inline__ void usb_writel(u32 port, u32 val)
+{
+	*(volatile u32 *)port = val;
+}
+
+static __inline__ void usb_setb(u32 port, u8 val)
+{
+	volatile u8 *ioport = (volatile u8 *)(port);
+	*ioport = (*ioport) | val;
+}
+
+static __inline__ void usb_setw(u32 port, u16 val)
+{
+	volatile u16 *ioport = (volatile u16 *)(port);
+	*ioport = (*ioport) | val;
+}
+
+static __inline__ void usb_setl(u32 port, u32 val)
+{
+	volatile u32 *ioport = (volatile u32 *)(port);
+	*ioport = (*ioport) | val;
+}
+
+static __inline__ void usb_clearb(u32 port, u8 val)
+{
+	volatile u8 *ioport = (volatile u8 *)(port);
+	*ioport = (*ioport) & ~val;
+}
+
+static __inline__ void usb_clearw(u32 port, u16 val)
+{
+	volatile u16 *ioport = (volatile u16 *)(port);
+	*ioport = (*ioport) & ~val;
+}
+
+static __inline__ void usb_clearl(u32 port, u32 val)
+{
+	volatile u32 *ioport = (volatile u32 *)(port);
+	*ioport = (*ioport) & ~val;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static __inline__ int write_packet(struct jz4740_ep *ep,
+				   struct jz4740_request *req, int max)
+{
+	u8 *buf;	
+	int length, nlong, nbyte;
+	volatile u32 *fifo = (volatile u32 *)ep->fifo;
+
+	buf = req->req.buf + req->req.actual;
+	prefetch(buf);
+
+	length = req->req.length - req->req.actual;
+	length = min(length, max);
+	req->req.actual += length;
+
+	DEBUG("Write %d (max %d), fifo %p\n", length, max, fifo);
+
+	nlong = length >> 2;
+	nbyte = length & 0x3;
+	while (nlong--) {
+		*fifo = *((u32 *)buf);
+		buf += 4;
+	}
+	while (nbyte--) {
+		*((volatile u8 *)fifo) = *buf++;
+	}
+
+	return length;
+}
+
+static __inline__ int read_packet(struct jz4740_ep *ep, 
+				  struct jz4740_request *req, int count)
+{
+	u8 *buf;
+	int length, nlong, nbyte;
+	volatile u32 *fifo = (volatile u32 *)ep->fifo;
+	char *tmp = req->req.buf;
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+
+	length = req->req.length - req->req.actual;
+	length = min(length, count);
+	req->req.actual += length;
+
+	DEBUG("Read %d, fifo %p\n", length, fifo);
+
+	nlong = length >> 2;
+	nbyte = length & 0x3;
+	while (nlong--) {
+		*((u32 *)buf) = *fifo;
+		buf += 4;
+	}
+	while (nbyte--) {
+		*buf++ = *((volatile u8 *)fifo);
+	}
+
+#ifdef  TEST_ON_WIN7
+	if (tmp[15] == 0x35)
+		out_flag = 1;
+#endif
+	return length;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * 	udc_disable - disable USB device controller
+ */
+static void udc_disable(struct jz4740_udc *dev)
+{
+	DEBUG("%s, %p\n", __FUNCTION__, dev);
+
+	udc_set_address(dev, 0);
+
+	/* Disable interrupts */
+	usb_writew(USB_REG_INTRINE, 0);
+	usb_writew(USB_REG_INTROUTE, 0);
+	usb_writeb(USB_REG_INTRUSBE, 0);
+
+	/* Disable DMA */
+	usb_writel(USB_REG_CNTL1, 0);
+	usb_writel(USB_REG_CNTL2, 0);
+
+	/* Disconnect from usb */
+	usb_clearb(USB_REG_POWER, USB_POWER_SOFTCONN);
+
+	/* Disable the USB PHY */
+#if defined(CONFIG_SOC_JZ4750D)
+	REG_CPM_OPCR &= ~CPM_OPCR_UDCPHY_ENABLE;
+#endif
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+}
+
+/*
+ * 	udc_reinit - initialize software state
+ */
+static void udc_reinit(struct jz4740_udc *dev)
+{
+	u32 i;
+
+	DEBUG("%s, %p\n", __FUNCTION__, dev);
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	for (i = 0; i < UDC_MAX_ENDPOINTS; i++) {
+		struct jz4740_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		INIT_LIST_HEAD(&ep->queue);
+		ep->desc = 0;
+		ep->stopped = 0;
+		ep->pio_irqs = 0;
+	}
+}
+
+/* until it's enabled, this UDC should be completely invisible
+ * to any USB host.
+ */
+static void udc_enable(struct jz4740_udc *dev)
+{
+	int i;
+
+	DEBUG("%s, %p\n", __FUNCTION__, dev);
+
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	/* Flush FIFO for each */
+	for (i = 0; i < UDC_MAX_ENDPOINTS; i++) {
+		struct jz4740_ep *ep = &dev->ep[i];
+
+		usb_set_index(ep_index(ep));
+		flush(ep);
+	}
+
+	/* Set this bit to allow the UDC entering low-power mode when
+	 * there are no actions on the USB bus.
+	 * UDC still works during this bit was set.
+	 */
+	__cpm_stop_udc();
+
+	/* Enable the USB PHY */
+#if defined(CONFIG_SOC_JZ4750D)
+	REG_CPM_OPCR |= CPM_OPCR_UDCPHY_ENABLE;
+#endif
+
+	/* Disable interrupts */
+	usb_writew(USB_REG_INTRINE, 0);
+	usb_writew(USB_REG_INTROUTE, 0);
+	usb_writeb(USB_REG_INTRUSBE, 0);
+
+	/* Enable interrupts */
+	usb_setw(USB_REG_INTRINE, USB_INTR_EP0);
+	usb_setb(USB_REG_INTRUSBE, USB_INTR_RESET);
+	/* Don't enable rest of the interrupts */
+	/* usb_setw(USB_REG_INTRINE, USB_INTR_INEP1 | USB_INTR_INEP2);
+	   usb_setw(USB_REG_INTROUTE, USB_INTR_OUTEP1); */
+
+	/* Enable SUSPEND */
+	/* usb_setb(USB_REG_POWER, USB_POWER_SUSPENDM); */
+
+	/* Enable HS Mode */
+	usb_setb(USB_REG_POWER, USB_POWER_HSENAB);
+
+	/* Let host detect UDC:
+	 * Software must write a 1 to the PMR:USB_POWER_SOFTCONN bit to turn this
+	 * transistor on and pull the USBDP pin HIGH.
+	 */
+	usb_setb(USB_REG_POWER, USB_POWER_SOFTCONN);
+
+	
+}
+
+/*-------------------------------------------------------------------------*/
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+static int jz4740_udc_uh_event(struct notifier_block *n, unsigned long val, void *data)
+{
+	struct jz4740_udc *dev = the_controller;
+	unsigned long flags;
+	
+	int state = *((int *)data);
+
+	if (!dev || !dev->driver)
+		return 0;
+
+	switch (val) {
+		case UH_NOTIFY_CABLE_STATE:
+			switch (state) {
+				case UH_CABLE_STATE_OFFLINE:
+				case UH_CABLE_STATE_POWER:
+					spin_lock_irqsave(&dev->lock, flags);
+					stop_activity(dev, dev->driver);
+					spin_unlock_irqrestore(&dev->lock, flags);
+
+					udc_disable(dev);
+
+					break;
+
+				case UH_CABLE_STATE_USB:
+					udc_enable(dev);
+
+					break;
+			}
+	}
+
+	return 0;
+}
+
+static struct notifier_block jz4740_udc_nb = {
+	.notifier_call = jz4740_udc_uh_event,
+};
+#endif
+
+/* keeping it simple:
+ * - one bus driver, initted first;
+ * - one function driver, initted second
+ */
+
+/*
+ * Register entry point for the peripheral controller driver.
+ */
+
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct jz4740_udc *dev = the_controller;
+	int retval;
+
+	if (!driver
+	    || !driver->bind
+	    || !driver->unbind || !driver->disconnect || !driver->setup)
+	{
+		printk("\n-EINVAL");
+		return -EINVAL;
+	}
+	if (!dev)
+	{
+		printk("\n-ENODEV");
+		return -ENODEV;
+	}
+	if (dev->driver)
+	{
+		printk("\n-ENODEV");
+		return -EBUSY;
+	}
+
+	/* hook up the driver */
+	dev->driver = driver;
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		DEBUG("%s: bind to driver %s --> error %d\n", dev->gadget.name,
+		            driver->driver.name, retval);
+		dev->driver = 0;
+		return retval;
+	}
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+	uh_register_notifier(&jz4740_udc_nb);
+#else
+	/* then enable host detection and ep0; and we're ready
+	 * for set_configuration as well as eventual disconnect.
+	 */
+	udc_enable(dev);
+#endif
+
+	DEBUG("%s: registered gadget driver '%s'\n", dev->gadget.name, 
+	      driver->driver.name);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+static void stop_activity(struct jz4740_udc *dev,
+			  struct usb_gadget_driver *driver)
+{
+	int i;
+
+	DEBUG("%s\n", __FUNCTION__);
+
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = 0;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < UDC_MAX_ENDPOINTS; i++) {
+		struct jz4740_ep *ep = &dev->ep[i];
+
+		ep->stopped = 1;
+
+		usb_set_index(ep_index(ep));
+		nuke(ep, -ESHUTDOWN);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		spin_unlock(&dev->lock);
+		driver->disconnect(&dev->gadget);
+		spin_lock(&dev->lock);
+	}
+
+	/* re-init driver-visible data structures */
+	udc_reinit(dev);
+}
+
+/*
+ * Unregister entry point for the peripheral controller driver.
+ */
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct jz4740_udc *dev = the_controller;
+	unsigned long flags;
+
+	if (!dev)
+		return -ENODEV;
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+	uh_unregister_notifier(&jz4740_udc_nb);
+#endif
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->driver = 0;
+	stop_activity(dev, driver);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	driver->unbind(&dev->gadget);
+
+	udc_disable(dev);
+
+	DEBUG("unregistered driver '%s'\n", driver->driver.name);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Starting DMA using mode 1
+ */
+static void kick_dma(struct jz4740_ep *ep, struct jz4740_request *req)
+{
+	u32 count = req->req.length;
+	u32 physaddr = virt_to_phys((void *)req->req.buf);
+
+	usb_set_index(ep_index(ep));
+	if (ep_is_in(ep)) { /* Bulk-IN transfer using DMA channel 1 */
+		ep->reg_addr = USB_REG_ADDR1;
+
+		dma_cache_wback_inv((unsigned long)req->req.buf, count);
+
+		pio_irq_enable(ep);
+
+		usb_writeb(USB_REG_INCSRH,
+			   USB_INCSRH_DMAREQENAB | USB_INCSRH_AUTOSET | USB_INCSRH_DMAREQMODE);
+
+		usb_writel(USB_REG_ADDR1, physaddr);
+		usb_writel(USB_REG_COUNT1, count);
+		usb_writel(USB_REG_CNTL1, USB_CNTL_ENA | USB_CNTL_DIR_IN | USB_CNTL_MODE_1 | 
+			   USB_CNTL_INTR_EN | USB_CNTL_BURST_16 | USB_CNTL_EP(ep_index(ep)));
+	}
+	else { /* Bulk-OUT transfer using DMA channel 2 */
+		ep->reg_addr = USB_REG_ADDR2;
+
+		dma_cache_wback_inv((unsigned long)req->req.buf, count);
+
+		pio_irq_enable(ep);
+
+		usb_setb(USB_REG_OUTCSRH,
+			 USB_OUTCSRH_DMAREQENAB | USB_OUTCSRH_AUTOCLR | USB_OUTCSRH_DMAREQMODE);
+
+		usb_writel(USB_REG_ADDR2, physaddr);
+		usb_writel(USB_REG_COUNT2, count);
+		usb_writel(USB_REG_CNTL2, USB_CNTL_ENA | USB_CNTL_MODE_1 | 
+			   USB_CNTL_INTR_EN | USB_CNTL_BURST_16 | USB_CNTL_EP(ep_index(ep)));
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/** Write request to FIFO (max write == maxp size)
+ *  Return:  0 = still running, 1 = completed, negative = errno
+ *  NOTE: INDEX register must be set for EP
+ */
+static int write_fifo(struct jz4740_ep *ep, struct jz4740_request *req)
+{
+	u32 max, csr;
+	u32 physaddr = virt_to_phys((void *)req->req.buf);
+
+	max = le16_to_cpu(ep->desc->wMaxPacketSize);
+
+	if (use_dma) {
+		u32 dma_count;
+
+		/* DMA interrupt generated due to the last packet loaded into the FIFO */
+
+		dma_count = usb_readl(ep->reg_addr) - physaddr;
+		req->req.actual += dma_count;
+
+		if (dma_count % max) {
+			/* If the last packet is less than MAXP, set INPKTRDY manually */
+			usb_setb(ep->csr, USB_INCSR_INPKTRDY);
+		}
+
+		done(ep, req, 0);
+		if (list_empty(&ep->queue)) {
+			pio_irq_disable(ep);
+			return 1;
+		}
+		else {
+			/* advance the request queue */
+			req = list_entry(ep->queue.next, struct jz4740_request, queue);
+			kick_dma(ep, req);
+			return 0;
+		}
+	}
+
+	/*
+	 * PIO mode handling starts here ...
+	 */
+
+	csr = usb_readb(ep->csr);
+
+	if (!(csr & USB_INCSR_FFNOTEMPT)) {
+		unsigned count;
+		int is_last, is_short;
+
+		count = write_packet(ep, req, max);
+		usb_setb(ep->csr, USB_INCSR_INPKTRDY);
+
+		/* last packet is usually short (or a zlp) */
+		if (unlikely(count != max))
+			is_last = is_short = 1;
+		else {
+			if (likely(req->req.length != req->req.actual)
+			    || req->req.zero)
+				is_last = 0;
+			else
+				is_last = 1;
+			/* interrupt/iso maxpacket may not fill the fifo */
+			is_short = unlikely(max < ep_maxpacket(ep));
+		}
+
+		DEBUG("%s: wrote %s %d bytes%s%s %d left %p\n", __FUNCTION__,
+		      ep->ep.name, count,
+		      is_last ? "/L" : "", is_short ? "/S" : "",
+		      req->req.length - req->req.actual, req);
+
+		/* requests complete when all IN data is in the FIFO */
+		if (is_last) {
+			done(ep, req, 0);
+			if (list_empty(&ep->queue)) {
+				pio_irq_disable(ep);
+			}
+			return 1;
+		}
+	} else {
+		DEBUG("Hmm.. %d ep FIFO is not empty!\n", ep_index(ep));
+	}
+
+	return 0;
+}
+
+/** Read to request from FIFO (max read == bytes in fifo)
+ *  Return:  0 = still running, 1 = completed, negative = errno
+ *  NOTE: INDEX register must be set for EP
+ */
+static int read_fifo(struct jz4740_ep *ep, struct jz4740_request *req)
+{
+	u32 csr;
+	unsigned count, is_short;
+	u32 physaddr = virt_to_phys((void *)req->req.buf);
+
+	if (use_dma) {
+		u32 dma_count;
+
+		/* DMA interrupt generated due to a packet less than MAXP loaded into the FIFO */
+		dma_count = usb_readl(ep->reg_addr) - physaddr;
+		req->req.actual += dma_count;
+		
+		/* Disable interrupt and DMA */
+		pio_irq_disable(ep);
+		usb_writel(USB_REG_CNTL2, 0);
+
+		/* Read all bytes from this packet */
+		count = usb_readw(USB_REG_OUTCOUNT);
+		count = read_packet(ep, req, count);
+
+		if (count) {
+			/* If the last packet is greater than zero, clear OUTPKTRDY manually */
+			usb_clearb(ep->csr, USB_OUTCSR_OUTPKTRDY);
+		}
+
+		done(ep, req, 0);
+
+		if (!list_empty(&ep->queue)) {
+			/* advance the request queue */
+			req = list_entry(ep->queue.next, struct jz4740_request, queue);
+			kick_dma(ep, req);
+		}
+
+		return 1;
+	}
+
+	/*
+	 * PIO mode handling starts here ...
+	 */
+
+	/* make sure there's a packet in the FIFO. */
+	csr = usb_readb(ep->csr);
+	if (!(csr & USB_OUTCSR_OUTPKTRDY)) {
+		DEBUG("%s: Packet NOT ready!\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* read all bytes from this packet */
+	count = usb_readw(USB_REG_OUTCOUNT);
+
+	is_short = (count < ep->ep.maxpacket);
+
+	count = read_packet(ep, req, count);
+
+	DEBUG("read %s %02x, %d bytes%s req %p %d/%d\n",
+	      ep->ep.name, csr, count,
+	      is_short ? "/S" : "", req, req->req.actual, req->req.length);
+
+	/* Clear OutPktRdy */
+	usb_clearb(ep->csr, USB_OUTCSR_OUTPKTRDY);
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		done(ep, req, 0);
+
+		if (list_empty(&ep->queue))
+			pio_irq_disable(ep);
+		return 1;
+	}
+
+	/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+/*
+ *	done - retire a request; caller blocked irqs
+ *  INDEX register is preserved to keep same
+ */
+static void done(struct jz4740_ep *ep, struct jz4740_request *req, int status)
+{
+	unsigned int stopped = ep->stopped;
+	u32 index;
+
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN)
+		DEBUG("complete %s req %p stat %d len %u/%u\n",
+		      ep->ep.name, &req->req, status,
+		      req->req.actual, req->req.length);
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+	/* Read current index (completion may modify it) */
+	index = usb_readb(USB_REG_INDEX);
+
+	spin_unlock(&ep->dev->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->dev->lock);
+
+	/* Restore index */
+	usb_set_index(index);
+	ep->stopped = stopped;
+}
+
+/** Enable EP interrupt */
+static void pio_irq_enable(struct jz4740_ep *ep)
+{
+	DEBUG("%s: EP%d %s\n", __FUNCTION__, ep_index(ep), ep_is_in(ep) ? "IN": "OUT");
+
+	if (ep_is_in(ep)) {
+		switch (ep_index(ep)) {
+		case 1:
+			usb_setw(USB_REG_INTRINE, USB_INTR_INEP1);
+			break;
+		case 2:
+			usb_setw(USB_REG_INTRINE, USB_INTR_INEP2);
+			break;
+		default:
+			DEBUG("Unknown endpoint: %d\n", ep_index(ep));
+			break;
+		}
+	}
+	else {
+		switch (ep_index(ep)) {
+		case 1:
+			usb_setw(USB_REG_INTROUTE, USB_INTR_OUTEP1);
+			break;
+		default:
+			DEBUG("Unknown endpoint: %d\n", ep_index(ep));
+			break;
+		}
+	}
+}
+
+/** Disable EP interrupt */
+static void pio_irq_disable(struct jz4740_ep *ep)
+{
+	DEBUG("%s: EP%d %s\n", __FUNCTION__, ep_index(ep), ep_is_in(ep) ? "IN": "OUT");
+
+	if (ep_is_in(ep)) {
+		switch (ep_index(ep)) {
+		case 1:
+			usb_clearw(USB_REG_INTRINE, USB_INTR_INEP1);
+			break;
+		case 2:
+			usb_clearw(USB_REG_INTRINE, USB_INTR_INEP2);
+			break;
+		default:
+			DEBUG("Unknown endpoint: %d\n", ep_index(ep));
+			break;
+		}
+	}
+	else {
+		switch (ep_index(ep)) {
+		case 1:
+			usb_clearw(USB_REG_INTROUTE, USB_INTR_OUTEP1);
+			break;
+		default:
+			DEBUG("Unknown endpoint: %d\n", ep_index(ep));
+			break;
+		}
+	}
+}
+
+/*
+ * 	nuke - dequeue ALL requests
+ */
+static void nuke(struct jz4740_ep *ep, int status)
+{
+	struct jz4740_request *req;
+
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+
+	/* Flush FIFO */
+	flush(ep);
+
+	/* called with irqs blocked */
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct jz4740_request, queue);
+		done(ep, req, status);
+	}
+
+	/* Disable IRQ if EP is enabled (has descriptor) */
+	if (ep->desc)
+		pio_irq_disable(ep);
+}
+
+/** Flush EP FIFO
+ * NOTE: INDEX register must be set before this call
+ */
+static void flush(struct jz4740_ep *ep)
+{
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+
+	switch (ep->ep_type) {
+	case ep_control:
+		break;
+
+	case ep_bulk_in:
+	case ep_interrupt:
+		usb_setb(ep->csr, USB_INCSR_FF);
+		break;
+
+	case ep_bulk_out:
+		usb_setb(ep->csr, USB_OUTCSR_FF);
+		break;
+	}
+}
+
+/**
+ * jz4740_in_epn - handle IN interrupt
+ */
+static void jz4740_in_epn(struct jz4740_udc *dev, u32 ep_idx, u32 intr)
+{
+	u32 csr;
+	struct jz4740_ep *ep = &dev->ep[ep_idx + 1];
+	struct jz4740_request *req;
+
+	usb_set_index(ep_index(ep));
+
+	csr = usb_readb(ep->csr);
+	DEBUG("%s: %d, csr %x\n", __FUNCTION__, ep_idx, csr);
+
+	if (csr & USB_INCSR_SENTSTALL) {
+		DEBUG("USB_INCSR_SENTSTALL\n");
+		usb_clearb(ep->csr, USB_INCSR_SENTSTALL);
+		return;
+	}
+
+	if (!ep->desc) {
+		DEBUG("%s: NO EP DESC\n", __FUNCTION__);
+		return;
+	}
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct jz4740_request, queue);
+
+	DEBUG("req: %p\n", req);
+
+	if (!req)
+		return;
+
+	write_fifo(ep, req);
+}
+
+/*
+ * Bulk OUT (recv)
+ */
+static void jz4740_out_epn(struct jz4740_udc *dev, u32 ep_idx, u32 intr)
+{
+	struct jz4740_ep *ep = &dev->ep[ep_idx];
+	struct jz4740_request *req;
+
+	DEBUG("%s: %d\n", __FUNCTION__, ep_idx);
+
+	usb_set_index(ep_index(ep));
+	if (ep->desc) {
+		u32 csr;
+
+		if (use_dma) {
+			/* DMA starts here ... */
+			if (list_empty(&ep->queue))
+				req = 0;
+			else
+				req = list_entry(ep->queue.next, struct jz4740_request, queue);
+
+			if (req)
+				read_fifo(ep, req);
+			return;
+		}
+
+		/*
+		 * PIO mode starts here ...
+		 */
+
+		while ((csr = usb_readb(ep->csr)) & 
+		       (USB_OUTCSR_OUTPKTRDY | USB_OUTCSR_SENTSTALL)) {
+			DEBUG("%s: %x\n", __FUNCTION__, csr);
+
+			if (csr & USB_OUTCSR_SENTSTALL) {
+				DEBUG("%s: stall sent, flush fifo\n",
+				      __FUNCTION__);
+				/* usb_set(USB_OUT_CSR1_FIFO_FLUSH, ep->csr1); */
+				flush(ep);
+			} else if (csr & USB_OUTCSR_OUTPKTRDY) {
+				if (list_empty(&ep->queue))
+					req = 0;
+				else
+					req =
+						list_entry(ep->queue.next,
+							   struct jz4740_request,
+							   queue);
+
+				if (!req) {
+					DEBUG("%s: NULL REQ %d\n",
+					      __FUNCTION__, ep_idx);
+					break;
+				} else {
+					read_fifo(ep, req);
+				}
+			}
+		}
+	} else {
+		/* Throw packet away.. */
+		printk("%s: ep %p ep_indx %d No descriptor?!?\n", __FUNCTION__, ep, ep_idx);
+		flush(ep);
+	}
+}
+
+static int jz4740_ep_enable(struct usb_ep *_ep,
+			    const struct usb_endpoint_descriptor *desc)
+{
+	struct jz4740_ep *ep;
+	struct jz4740_udc *dev;
+	unsigned long flags;
+	u32 max, csrh = 0;
+
+	ep = container_of(_ep, struct jz4740_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+	    || desc->bDescriptorType != USB_DT_ENDPOINT
+	    || ep->bEndpointAddress != desc->bEndpointAddress) {
+		DEBUG("%s, bad ep or descriptor\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes
+	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
+	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
+		DEBUG("%s, %s type mismatch\n", __FUNCTION__, _ep->name);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DEBUG("%s, bogus device state\n", __FUNCTION__);
+		return -ESHUTDOWN;
+	}
+
+	max = le16_to_cpu(desc->wMaxPacketSize);
+
+	/* Configure the endpoint */
+	usb_set_index(desc->bEndpointAddress & 0x0F);
+	if (ep_is_in(ep)) {
+		usb_writew(USB_REG_INMAXP, max);
+		switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+		case USB_ENDPOINT_XFER_BULK:
+		case USB_ENDPOINT_XFER_INT:
+			csrh &= ~USB_INCSRH_ISO;
+			break;
+		case USB_ENDPOINT_XFER_ISOC:
+			csrh |= USB_INCSRH_ISO;
+			break;
+		}
+		usb_writeb(USB_REG_INCSRH, csrh);
+	}
+	else {
+		usb_writew(USB_REG_OUTMAXP, max);
+		switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+		case USB_ENDPOINT_XFER_BULK:
+			 csrh &= ~USB_OUTCSRH_ISO;
+			break;
+		case USB_ENDPOINT_XFER_INT:
+			csrh &= ~USB_OUTCSRH_ISO;
+			csrh |= USB_OUTCSRH_DNYT;
+			break;
+		case USB_ENDPOINT_XFER_ISOC:
+			csrh |= USB_OUTCSRH_ISO;
+			break;
+		}
+		usb_writeb(USB_REG_OUTCSRH, csrh);
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	ep->stopped = 0;
+	ep->desc = desc;
+	ep->pio_irqs = 0;
+	ep->ep.maxpacket = max;
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	/* Reset halt state (does flush) */
+	jz4740_set_halt(_ep, 0);
+
+	DEBUG("%s: enabled %s\n", __FUNCTION__, _ep->name);
+
+	return 0;
+}
+
+/** Disable EP
+ *  NOTE: Sets INDEX register
+ */
+static int jz4740_ep_disable(struct usb_ep *_ep)
+{
+	struct jz4740_ep *ep;
+	unsigned long flags;
+
+	DEBUG("%s, %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct jz4740_ep, ep);
+	if (!_ep || !ep->desc) {
+		DEBUG("%s, %s not enabled\n", __FUNCTION__,
+		      _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	usb_set_index(ep_index(ep));
+
+	/* Nuke all pending requests (does flush) */
+	nuke(ep, -ESHUTDOWN);
+
+	/* Disable ep IRQ */
+	pio_irq_disable(ep);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DEBUG("%s: disabled %s\n", __FUNCTION__, _ep->name);
+	return 0;
+}
+
+static struct usb_request *jz4740_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)
+{
+	struct jz4740_request *req;
+
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+
+	req = kzalloc(sizeof(*req), gfp_flags);
+	if (!req)
+		return 0;
+
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void jz4740_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct jz4740_request *req;
+
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+
+	req = container_of(_req, struct jz4740_request, req);
+	WARN_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+/*--------------------------------------------------------------------*/
+
+/** Queue one request
+ *  Kickstart transfer if needed
+ *  NOTE: Sets INDEX register
+ */
+static int jz4740_queue(struct usb_ep *_ep, struct usb_request *_req,
+			gfp_t gfp_flags)
+{
+	struct jz4740_request *req;
+	struct jz4740_ep *ep;
+	struct jz4740_udc *dev;
+	unsigned long flags;
+
+	DEBUG("%s, %p\n", __FUNCTION__, _ep);
+
+	req = container_of(_req, struct jz4740_request, req);
+	if (unlikely
+	    (!_req || !_req->complete || !_req->buf
+	     || !list_empty(&req->queue))) {
+		DEBUG("%s, bad params\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct jz4740_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s, bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+		DEBUG("%s, bogus device state %p\n", __FUNCTION__, dev->driver);
+		return -ESHUTDOWN;
+	}
+
+	DEBUG("%s queue req %p, len %d buf %p\n", _ep->name, _req, _req->length,
+	      _req->buf);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	DEBUG("Add to %d Q %d %d\n", ep_index(ep), list_empty(&ep->queue),
+	      ep->stopped);
+	if (list_empty(&ep->queue) && likely(!ep->stopped)) {
+		u32 csr;
+
+		if (unlikely(ep_index(ep) == 0)) {
+			/* EP0 */
+			usb_set_index(0);
+			list_add_tail(&req->queue, &ep->queue);
+			jz4740_ep0_kick(dev, ep, _req);
+			goto done;
+		} else if (use_dma) {
+			/* DMA */
+			kick_dma(ep, req);
+		}
+		/* PIO */
+		else if (ep_is_in(ep)) {
+			/* EP1 & EP2 */
+			usb_set_index(ep_index(ep));
+			csr = usb_readb(ep->csr);
+			pio_irq_enable(ep);
+			if (!(csr & USB_INCSR_FFNOTEMPT)) {
+				if (write_fifo(ep, req) == 1)
+					req = 0;
+			}
+		} else {
+			/* EP1 */
+			usb_set_index(ep_index(ep));
+			csr = usb_readb(ep->csr);
+			pio_irq_enable(ep);
+			if (csr & USB_OUTCSR_OUTPKTRDY) {
+				if (read_fifo(ep, req) == 1)
+					req = 0;
+			}
+		}
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (likely(req != 0))
+		list_add_tail(&req->queue, &ep->queue);
+done:
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/* dequeue JUST ONE request */
+static int jz4740_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct jz4740_ep *ep;
+	struct jz4740_request *req;
+	unsigned long flags;
+
+	DEBUG("%s, %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct jz4740_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		spin_unlock_irqrestore(&ep->dev->lock, flags);
+		return -EINVAL;
+	}
+
+	done(ep, req, -ECONNRESET);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return 0;
+}
+
+/** Halt specific EP
+ *  Return 0 if success
+ *  NOTE: Sets INDEX register to EP !
+ */
+static int jz4740_set_halt(struct usb_ep *_ep, int value)
+{
+	struct jz4740_ep *ep;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct jz4740_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s, bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	usb_set_index(ep_index(ep));
+
+	DEBUG("%s, ep %d, val %d\n", __FUNCTION__, ep_index(ep), value);
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	if (ep_index(ep) == 0) {
+		/* EP0 */
+		usb_setb(USB_REG_CSR0, USB_CSR0_SENDSTALL);
+	} else if (ep_is_in(ep)) {
+		u32 csr = usb_readb(ep->csr);
+		if (value && ((csr & USB_INCSR_FFNOTEMPT)
+			      || !list_empty(&ep->queue))) {
+			/*
+			 * Attempts to halt IN endpoints will fail (returning -EAGAIN)
+			 * if any transfer requests are still queued, or if the controller
+			 * FIFO still holds bytes that the host hasnt collected.
+			 */
+			spin_unlock_irqrestore(&ep->dev->lock, flags);
+			DEBUG
+			    ("Attempt to halt IN endpoint failed (returning -EAGAIN) %d %d\n",
+			     (csr & USB_INCSR_FFNOTEMPT),
+			     !list_empty(&ep->queue));
+			return -EAGAIN;
+		}
+		flush(ep);
+		if (value) {
+			usb_setb(ep->csr, USB_INCSR_SENDSTALL);
+		}
+		else {
+			usb_clearb(ep->csr, USB_INCSR_SENDSTALL);
+			usb_setb(ep->csr, USB_INCSR_CDT);
+		}
+	} else {
+
+		flush(ep);
+		if (value) {
+			usb_setb(ep->csr, USB_OUTCSR_SENDSTALL);
+		}
+		else {
+			usb_clearb(ep->csr, USB_OUTCSR_SENDSTALL);
+			usb_setb(ep->csr, USB_OUTCSR_CDT);
+		}
+	}
+
+	if (value) {
+		ep->stopped = 1;
+	} else {
+		ep->stopped = 0;
+	}
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DEBUG("%s %s halted\n", _ep->name, value == 0 ? "NOT" : "IS");
+
+	return 0;
+}
+
+/** Return bytes in EP FIFO
+ *  NOTE: Sets INDEX register to EP
+ */
+static int jz4740_fifo_status(struct usb_ep *_ep)
+{
+	u32 csr;
+	int count = 0;
+	struct jz4740_ep *ep;
+
+	ep = container_of(_ep, struct jz4740_ep, ep);
+	if (!_ep) {
+		DEBUG("%s, bad ep\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	DEBUG("%s, %d\n", __FUNCTION__, ep_index(ep));
+
+	/* LPD can't report unclaimed bytes from IN fifos */
+	if (ep_is_in(ep))
+		return -EOPNOTSUPP;
+
+	usb_set_index(ep_index(ep));
+
+	csr = usb_readb(ep->csr);
+	if (ep->dev->gadget.speed != USB_SPEED_UNKNOWN ||
+	    csr & 0x1) {
+		count = usb_readw(USB_REG_OUTCOUNT);
+	}
+
+	return count;
+}
+
+/** Flush EP FIFO
+ *  NOTE: Sets INDEX register to EP
+ */
+static void jz4740_fifo_flush(struct usb_ep *_ep)
+{
+	struct jz4740_ep *ep;
+
+	ep = container_of(_ep, struct jz4740_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s, bad ep\n", __FUNCTION__);
+		return;
+	}
+
+	usb_set_index(ep_index(ep));
+	flush(ep);
+}
+
+/****************************************************************/
+/* End Point 0 related functions                                */
+/****************************************************************/
+
+/* return:  0 = still running, 1 = completed, negative = errno */
+static int write_fifo_ep0(struct jz4740_ep *ep, struct jz4740_request *req)
+{
+	u32 max;
+	unsigned count;
+	int is_last;
+
+	max = ep_maxpacket(ep);
+
+	if (req->req.length == 0) {
+		is_last = 1;
+		goto done;
+	}
+	count = write_packet(ep, req, max);
+
+	/* last packet is usually short (or a zlp) */
+	if (unlikely(count != max))
+		is_last = 1;
+	else {
+		if (likely(req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	DEBUG_EP0("%s: wrote %s %d bytes%s %d left %p\n", __FUNCTION__,
+		  ep->ep.name, count,
+		  is_last ? "/L" : "", req->req.length - req->req.actual, req);
+
+done:
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		done(ep, req, 0);
+		return 1;
+	}
+
+	return 0;
+}
+
+static __inline__ int jz4740_fifo_read(struct jz4740_ep *ep,
+				       unsigned char *cp, int max)
+{
+	int bytes;
+	int count = usb_readw(USB_REG_OUTCOUNT);
+	volatile u8 *fifo = (volatile u8 *)ep->fifo;
+
+	if (count > max)
+		count = max;
+	bytes = count;
+	while (count--)
+		*cp++ = *fifo;
+	return bytes;
+}
+
+static __inline__ void jz4740_fifo_write(struct jz4740_ep *ep,
+					 unsigned char *cp, int count)
+{
+	volatile u8 *fifo = (volatile u8 *)ep->fifo;
+	DEBUG_EP0("fifo_write: %d %d\n", ep_index(ep), count);
+	while (count--)
+		*fifo = *cp++;
+}
+
+static int read_fifo_ep0(struct jz4740_ep *ep, struct jz4740_request *req)
+{
+	u32 csr;
+	u8 *buf;
+	unsigned bufferspace, count, is_short = 0;
+	volatile u8 *fifo = (volatile u8 *)ep->fifo;
+
+	DEBUG_EP0("%s\n", __FUNCTION__);
+
+	csr = usb_readb(USB_REG_CSR0);
+	if (!(csr & USB_CSR0_OUTPKTRDY))
+		return 0;
+
+	if (req->req.length == 0)
+		goto done;
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	/* read all bytes from this packet */
+	if (likely(csr & USB_CSR0_OUTPKTRDY)) {
+		count = usb_readw(USB_REG_OUTCOUNT);
+		req->req.actual += min(count, bufferspace);
+	} else			/* zlp */
+		count = 0;
+
+	is_short = (count < ep->ep.maxpacket);
+	DEBUG_EP0("read %s %02x, %d bytes%s req %p %d/%d\n",
+		  ep->ep.name, csr, count,
+		  is_short ? "/S" : "", req, req->req.actual, req->req.length);
+
+	while (likely(count-- != 0)) {
+		u8 byte = (u8) (*fifo & 0xff);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+			 * is smaller than what the host sent.
+			 * discard the extra data.
+			 */
+			if (req->req.status != -EOVERFLOW)
+				DEBUG_EP0("%s overflow %d\n", ep->ep.name,
+					  count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace--;
+		}
+	}
+done:
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		done(ep, req, 0);
+		return 1;
+	}
+
+	/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+/**
+ * udc_set_address - set the USB address for this device
+ * @address:
+ *
+ * Called from control endpoint function after it decodes a set address setup packet.
+ */
+static void udc_set_address(struct jz4740_udc *dev, unsigned char address)
+{
+	DEBUG_EP0("%s: %d\n", __FUNCTION__, address);
+
+	dev->usb_address = address;
+	usb_writeb(USB_REG_FADDR, address);
+}
+
+/*
+ * DATA_STATE_RECV (USB_CSR0_OUTPKTRDY)
+ *      - if error
+ *              set USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND | USB_CSR0_SENDSTALL bits
+ *      - else
+ *              set USB_CSR0_SVDOUTPKTRDY bit
+ 				if last set USB_CSR0_DATAEND bit
+ */
+static void jz4740_ep0_out(struct jz4740_udc *dev, u32 csr)
+{
+	struct jz4740_request *req;
+	struct jz4740_ep *ep = &dev->ep[0];
+	int ret;
+
+	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct jz4740_request, queue);
+
+	if (req) {
+		ret = read_fifo_ep0(ep, req);
+		if (ret) {
+			/* Done! */
+			DEBUG_EP0("%s: finished, waiting for status\n",
+				  __FUNCTION__);
+			usb_setb(USB_REG_CSR0, (USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND));
+			dev->ep0state = WAIT_FOR_SETUP;
+		} else {
+			/* Not done yet.. */
+			DEBUG_EP0("%s: not finished\n", __FUNCTION__);
+			usb_setb(USB_REG_CSR0, USB_CSR0_SVDOUTPKTRDY);
+		}
+	} else {
+		DEBUG_EP0("NO REQ??!\n");
+	}
+}
+
+/*
+ * DATA_STATE_XMIT
+ */
+static int jz4740_ep0_in(struct jz4740_udc *dev, u32 csr)
+{
+	struct jz4740_request *req;
+	struct jz4740_ep *ep = &dev->ep[0];
+	int ret, need_zlp = 0;
+
+	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct jz4740_request, queue);
+
+	if (!req) {
+		DEBUG_EP0("%s: NULL REQ\n", __FUNCTION__);
+		return 0;
+	}
+
+
+	if (req->req.length - req->req.actual == EP0_MAXPACKETSIZE) {
+		/* Next write will end with the packet size, */
+		/* so we need zero-length-packet */
+		need_zlp = 1;
+	}
+
+	ret = write_fifo_ep0(ep, req);
+
+	if (ret == 1 && !need_zlp) {
+		/* Last packet */
+		DEBUG_EP0("%s: finished, waiting for status\n", __FUNCTION__);
+
+		usb_setb(USB_REG_CSR0, (USB_CSR0_INPKTRDY | USB_CSR0_DATAEND));
+		dev->ep0state = WAIT_FOR_SETUP;
+	} else {
+		DEBUG_EP0("%s: not finished\n", __FUNCTION__);
+		usb_setb(USB_REG_CSR0, USB_CSR0_INPKTRDY);
+	}
+
+	if (need_zlp) {
+		DEBUG_EP0("%s: Need ZLP!\n", __FUNCTION__);
+		usb_setb(USB_REG_CSR0, USB_CSR0_INPKTRDY);
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+	}
+
+	return 1;
+}
+
+#if 0
+static int jz4740_handle_get_status(struct jz4740_udc *dev,
+				    struct usb_ctrlrequest *ctrl)
+{
+	struct jz4740_ep *ep0 = &dev->ep[0];
+	struct jz4740_ep *qep;
+	int reqtype = (ctrl->bRequestType & USB_RECIP_MASK);
+	u16 val = 0;
+
+	if (reqtype == USB_RECIP_INTERFACE) {
+		/* This is not supported.
+		 * And according to the USB spec, this one does nothing..
+		 * Just return 0
+		 */
+		DEBUG_SETUP("GET_STATUS: USB_RECIP_INTERFACE\n");
+	} else if (reqtype == USB_RECIP_DEVICE) {
+		DEBUG_SETUP("GET_STATUS: USB_RECIP_DEVICE\n");
+		val |= (1 << 0);	/* Self powered */
+		/*val |= (1<<1); *//* Remote wakeup */
+	} else if (reqtype == USB_RECIP_ENDPOINT) {
+		int ep_num = (ctrl->wIndex & ~USB_DIR_IN);
+
+		DEBUG_SETUP
+			("GET_STATUS: USB_RECIP_ENDPOINT (%d), ctrl->wLength = %d\n",
+			 ep_num, ctrl->wLength);
+
+		if (ctrl->wLength > 2 || ep_num > 3)
+			return -EOPNOTSUPP;
+
+		qep = &dev->ep[ep_num];
+		if (ep_is_in(qep) != ((ctrl->wIndex & USB_DIR_IN) ? 1 : 0)
+		    && ep_index(qep) != 0) {
+			return -EOPNOTSUPP;
+		}
+
+		usb_set_index(ep_index(qep));
+
+		/* Return status on next IN token */
+		switch (qep->ep_type) {
+		case ep_control:
+			val =
+			    (usb_readb(qep->csr) & USB_CSR0_SENDSTALL) ==
+			    USB_CSR0_SENDSTALL;
+			break;
+		case ep_bulk_in:
+		case ep_interrupt:
+			val =
+			    (usb_readb(qep->csr) & USB_INCSR_SENDSTALL) ==
+			    USB_INCSR_SENDSTALL;
+			break;
+		case ep_bulk_out:
+			val =
+			    (usb_readb(qep->csr) & USB_OUTCSR_SENDSTALL) ==
+			    USB_OUTCSR_SENDSTALL;
+			break;
+		}
+
+		/* Back to EP0 index */
+		usb_set_index(0);
+
+		DEBUG_SETUP("GET_STATUS, ep: %d (%x), val = %d\n", ep_num,
+			    ctrl->wIndex, val);
+	} else {
+		DEBUG_SETUP("Unknown REQ TYPE: %d\n", reqtype);
+		return -EOPNOTSUPP;
+	}
+
+	/* Clear "out packet ready" */
+	usb_setb(USB_REG_CSR0, USB_CSR0_SVDOUTPKTRDY);
+	/* Put status to FIFO */
+	jz4740_fifo_write(ep0, (u8 *) & val, sizeof(val));
+	/* Issue "In packet ready" */
+	usb_setb(USB_REG_CSR0, (USB_CSR0_INPKTRDY | USB_CSR0_DATAEND));
+
+	return 0;
+}
+#endif
+
+/*
+ * WAIT_FOR_SETUP (OUTPKTRDY)
+ *      - read data packet from EP0 FIFO
+ *      - decode command
+ *      - if error
+ *              set USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND | USB_CSR0_SENDSTALL bits
+ *      - else
+ *              set USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND bits
+ */
+static void jz4740_ep0_setup(struct jz4740_udc *dev, u32 csr)
+{
+	struct jz4740_ep *ep = &dev->ep[0];
+	struct usb_ctrlrequest ctrl;
+	int i;
+	int clear = 1;
+
+	DEBUG_SETUP("%s: %x\n", __FUNCTION__, csr);
+
+	/* Nuke all previous transfers */
+	nuke(ep, -EPROTO);
+
+	/* read control req from fifo (8 bytes) */
+	jz4740_fifo_read(ep, (unsigned char *)&ctrl, 8);
+
+	DEBUG_SETUP("SETUP %02x.%02x v%04x i%04x l%04x\n",
+		    ctrl.bRequestType, ctrl.bRequest,
+		    ctrl.wValue, ctrl.wIndex, ctrl.wLength);
+
+	/* Set direction of EP0 */
+	if (likely(ctrl.bRequestType & USB_DIR_IN)) {
+		ep->bEndpointAddress |= USB_DIR_IN;
+	} else {
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+	}
+
+	/* Handle some SETUP packets ourselves */
+	switch (ctrl.bRequest) {
+	case USB_REQ_SET_ADDRESS:
+		if (ctrl.bRequestType != (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+			break;
+
+		DEBUG_SETUP("USB_REQ_SET_ADDRESS (%d)\n", ctrl.wValue);
+		udc_set_address(dev, ctrl.wValue);
+		usb_setb(USB_REG_CSR0, (USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND));
+		return;
+
+	case USB_REQ_SET_CONFIGURATION:
+		if (ctrl.bRequestType != (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+			break;
+
+		DEBUG_SETUP("USB_REQ_SET_CONFIGURATION (%d)\n", ctrl.wValue);
+		usb_setb(USB_REG_CSR0, (USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND));
+
+		/* Enable RESUME and SUSPEND interrupts */
+		usb_setb(USB_REG_INTRUSBE, (USB_INTR_RESUME | USB_INTR_SUSPEND));
+		break;
+
+	case USB_REQ_SET_INTERFACE:
+		if (ctrl.bRequestType != (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+			break;
+
+		DEBUG_SETUP("USB_REQ_SET_INTERFACE (%d)\n", ctrl.wValue);
+		usb_setb(USB_REG_CSR0, (USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND));
+		break;
+
+//	case USB_REQ_GET_STATUS:
+//		if (jz4740_handle_get_status(dev, &ctrl) == 0)
+//			return;
+
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+		if (ctrl.bRequestType == USB_RECIP_ENDPOINT) {
+			struct jz4740_ep *qep;
+			int ep_num = (ctrl.wIndex & 0x0f);
+
+			/* Support only HALT feature */
+			if (ctrl.wValue != 0 || ctrl.wLength != 0
+			    || ep_num > 3 || ep_num < 1)
+				break;
+
+			qep = &dev->ep[ep_num];
+			spin_unlock(&dev->lock);
+			if (ctrl.bRequest == USB_REQ_SET_FEATURE) {
+				DEBUG_SETUP("SET_FEATURE (%d)\n",
+					    ep_num);
+				jz4740_set_halt(&qep->ep, 1);
+			} else {
+				DEBUG_SETUP("CLR_FEATURE (%d)\n",
+					    ep_num);
+				jz4740_set_halt(&qep->ep, 0);
+			}
+			spin_lock(&dev->lock);
+			
+			usb_set_index(0);
+
+			/* Reply with a ZLP on next IN token */
+			usb_setb(USB_REG_CSR0, 
+				 (USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND));
+			return;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	if (clear) {
+		DEBUG_EP0("Clear OUTPKTRDY.\n");
+		usb_setb(USB_REG_CSR0, USB_CSR0_SVDOUTPKTRDY);
+	}
+	/* gadget drivers see class/vendor specific requests,
+	 * {SET,GET}_{INTERFACE,DESCRIPTOR,CONFIGURATION}, 
+	 * and more.
+	 */
+	if (likely((u32)dev->driver)) {
+		/* device-2-host (IN) or no data setup command, process immediately */
+		spin_unlock(&dev->lock);
+
+		i = dev->driver->setup(&dev->gadget, &ctrl);
+		spin_lock(&dev->lock);
+
+		if (unlikely(i < 0)) {
+			/* setup processing failed, force stall */
+			DEBUG_SETUP
+			    ("  --> ERROR: gadget setup FAILED (stalling), setup returned %d\n",
+			     i);
+			usb_set_index(0);
+			usb_setb(USB_REG_CSR0, (USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND | USB_CSR0_SENDSTALL));
+
+			/* ep->stopped = 1; */
+			dev->ep0state = WAIT_FOR_SETUP;
+		}
+		else {
+			DEBUG_SETUP("gadget driver setup ok (%d)\n", ctrl.wLength);
+		}
+	}
+}
+
+/*
+ * DATA_STATE_NEED_ZLP
+ */
+static void jz4740_ep0_in_zlp(struct jz4740_udc *dev, u32 csr)
+{
+	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
+
+	usb_setb(USB_REG_CSR0, (USB_CSR0_INPKTRDY | USB_CSR0_DATAEND));
+	dev->ep0state = WAIT_FOR_SETUP;
+}
+
+/*
+ * handle ep0 interrupt
+ */
+static void jz4740_handle_ep0(struct jz4740_udc *dev, u32 intr)
+{
+	struct jz4740_ep *ep = &dev->ep[0];
+	u32 csr;
+
+	/* Set index 0 */
+	usb_set_index(0);
+	csr = usb_readb(USB_REG_CSR0);
+
+	DEBUG_EP0("%s: csr = %x  state = \n", __FUNCTION__, csr);//, state_names[dev->ep0state]);
+
+	/*
+	 * if SENT_STALL is set
+	 *      - clear the SENT_STALL bit
+	 */
+	if (csr & USB_CSR0_SENTSTALL) {
+		DEBUG_EP0("%s: USB_CSR0_SENTSTALL is set: %x\n", __FUNCTION__, csr);
+		usb_clearb(USB_REG_CSR0, USB_CSR0_SENDSTALL | USB_CSR0_SENTSTALL);
+		nuke(ep, -ECONNABORTED);
+		dev->ep0state = WAIT_FOR_SETUP;
+		return;
+	}
+
+	/*
+	 * if a transfer is in progress && INPKTRDY and OUTPKTRDY are clear
+	 *      - fill EP0 FIFO
+	 *      - if last packet
+	 *      -       set IN_PKT_RDY | DATA_END
+	 *      - else
+	 *              set IN_PKT_RDY
+	 */
+	if (!(csr & (USB_CSR0_INPKTRDY | USB_CSR0_OUTPKTRDY))) {
+		DEBUG_EP0("%s: INPKTRDY and OUTPKTRDY are clear\n",
+			  __FUNCTION__);
+
+		switch (dev->ep0state) {
+		case DATA_STATE_XMIT:
+			DEBUG_EP0("continue with DATA_STATE_XMIT\n");
+			jz4740_ep0_in(dev, csr);
+			return;
+		case DATA_STATE_NEED_ZLP:
+			DEBUG_EP0("continue with DATA_STATE_NEED_ZLP\n");
+			jz4740_ep0_in_zlp(dev, csr);
+			return;
+		default:
+			/* Stall? */
+//			DEBUG_EP0("Odd state!! state = %s\n",
+//				  state_names[dev->ep0state]);
+			dev->ep0state = WAIT_FOR_SETUP;
+			/* nuke(ep, 0); */
+			/* usb_setb(ep->csr, USB_CSR0_SENDSTALL); */
+//			break;
+			return;
+		}
+	}
+
+	/*
+	 * if SETUPEND is set
+	 *      - abort the last transfer
+	 *      - set SERVICED_SETUP_END_BIT
+	 */
+	if (csr & USB_CSR0_SETUPEND) {
+		DEBUG_EP0("%s: USB_CSR0_SETUPEND is set: %x\n", __FUNCTION__, csr);
+
+		usb_setb(USB_REG_CSR0, USB_CSR0_SVDSETUPEND);
+		nuke(ep, 0);
+		dev->ep0state = WAIT_FOR_SETUP;
+	}
+
+	/*
+	 * if USB_CSR0_OUTPKTRDY is set
+	 *      - read data packet from EP0 FIFO
+	 *      - decode command
+	 *      - if error
+	 *              set SVDOUTPKTRDY | DATAEND | SENDSTALL bits
+	 *      - else
+	 *              set SVDOUTPKTRDY | DATAEND bits
+	 */
+	if (csr & USB_CSR0_OUTPKTRDY) {
+
+		DEBUG_EP0("%s: EP0_OUT_PKT_RDY is set: %x\n", __FUNCTION__,
+			  csr);
+
+		switch (dev->ep0state) {
+		case WAIT_FOR_SETUP:
+			DEBUG_EP0("WAIT_FOR_SETUP\n");
+			jz4740_ep0_setup(dev, csr);
+			break;
+
+		case DATA_STATE_RECV:
+			DEBUG_EP0("DATA_STATE_RECV\n");
+			jz4740_ep0_out(dev, csr);
+			break;
+
+		default:
+			/* send stall? */
+			DEBUG_EP0("strange state!! 2. send stall? state = %d\n",
+				  dev->ep0state);
+			break;
+		}
+	}
+}
+
+static void jz4740_ep0_kick(struct jz4740_udc *dev, struct jz4740_ep *ep, struct usb_request *req)
+{
+	u32 csr;
+
+	csr = usb_readb(USB_REG_CSR0);
+
+	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
+
+	if (ep_is_in(ep)) {
+		dev->ep0state = DATA_STATE_XMIT;
+		jz4740_ep0_in(dev, csr);
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+		/* out request will wait for the interrupt except the zero length state */
+		if (!req->length)
+			jz4740_ep0_out(dev, csr);
+	}
+}
+
+static void jz4740_handle_reset(struct jz4740_udc *dev)
+{
+	udc_set_address(dev, 0);
+
+	/* Disable interrupts */
+	usb_writew(USB_REG_INTRINE, 0);
+	usb_writew(USB_REG_INTROUTE, 0);
+	usb_writeb(USB_REG_INTRUSBE, 0);
+
+	/* Disable DMA */
+	usb_writel(USB_REG_CNTL1, 0);
+	usb_writel(USB_REG_CNTL2, 0);
+
+	stop_activity(dev, dev->driver);
+
+	/* Enable interrupts */
+	usb_setw(USB_REG_INTRINE, USB_INTR_EP0);
+	usb_setb(USB_REG_INTRUSBE, USB_INTR_RESET);
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	
+	dev->gadget.speed = (usb_readb(USB_REG_POWER) & USB_POWER_HSMODE) ? 
+		USB_SPEED_HIGH : USB_SPEED_FULL;
+
+	DEBUG_SETUP("%s: address = %d, speed = %s\n", __FUNCTION__, dev->usb_address,
+		    (dev->gadget.speed == USB_SPEED_HIGH) ? "HIGH":"FULL");
+}
+
+static void jz4740_handle_resume(struct jz4740_udc *dev)
+{
+	if (dev->gadget.speed != USB_SPEED_UNKNOWN
+			&& dev->driver && dev->driver->resume)
+		dev->driver->resume(&dev->gadget);
+
+	return;
+}
+
+static void jz4740_handle_suspend(struct jz4740_udc *dev)
+{
+	/* Host unloaded from us, can do something, such as flushing
+	   the NAND block cache etc. */
+
+	if (dev->gadget.speed != USB_SPEED_UNKNOWN
+			&& dev->driver && dev->driver->suspend)
+		dev->driver->suspend(&dev->gadget);
+	
+	return;
+}
+
+/*
+ *	jz4740 usb device interrupt handler.
+ */
+static irqreturn_t jz4740_udc_irq(int irq, void *_dev)
+{
+	struct jz4740_udc *dev = _dev;
+
+	int do_keep_alive = 1;
+
+	u32 intr_usb = usb_readb(USB_REG_INTRUSB) & 0x7; /* mask SOF */
+	u32 intr_in  = usb_readw(USB_REG_INTRIN);
+	u32 intr_out = usb_readw(USB_REG_INTROUT);
+	u32 intr_dma = usb_readb(USB_REG_INTR);
+
+	if (!intr_usb && !intr_in && !intr_out && !intr_dma)
+		return IRQ_HANDLED;
+
+	DEBUG("intr_out = %x intr_in=%x intr_usb=%x\n", 
+	      intr_out, intr_in, intr_usb);
+
+	spin_lock(&dev->lock);
+
+	/* Check for resume from suspend mode */
+	if ((intr_usb & USB_INTR_RESUME) && 
+	    (usb_readb(USB_REG_INTRUSBE) & USB_INTR_RESUME)) {
+		DEBUG("USB resume\n");
+		jz4740_handle_resume(dev);
+
+		do_keep_alive = 0;
+	}
+
+	/* Check for system interrupts */
+	if (intr_usb & USB_INTR_RESET) {
+		DEBUG("USB reset\n");
+		jz4740_handle_reset(dev);
+	}
+
+	/* Check for endpoint 0 interrupt */
+	if (intr_in & USB_INTR_EP0) {
+		DEBUG("USB_INTR_EP0 (control)\n");
+		jz4740_handle_ep0(dev, intr_in);
+	}
+
+	/* Check for Bulk-IN DMA interrupt */
+	if (intr_dma & 0x1) {
+		int ep_num;
+		ep_num = (usb_readl(USB_REG_CNTL1) >> 4) & 0xf;
+		jz4740_in_epn(dev, ep_num, intr_in);
+	}
+
+	/* Check for Bulk-OUT DMA interrupt */
+	if (intr_dma & 0x2) {
+		int ep_num;
+#ifdef TEST_ON_WIN7
+		if (out_flag)
+			out_flag = 0;
+#endif
+		ep_num = (usb_readl(USB_REG_CNTL2) >> 4) & 0xf;
+		jz4740_out_epn(dev, ep_num, intr_out);
+	}
+
+	/* Check for each configured endpoint interrupt */
+	if (intr_in & USB_INTR_INEP1) {
+		DEBUG("USB_INTR_INEP1\n");
+		jz4740_in_epn(dev, 1, intr_in);
+	}
+
+	if (intr_in & USB_INTR_INEP2) {
+		DEBUG("USB_INTR_INEP2\n");
+		jz4740_in_epn(dev, 2, intr_in);
+	}
+
+	if (intr_out & USB_INTR_OUTEP1) {
+		DEBUG("USB_INTR_OUTEP1\n");
+		jz4740_out_epn(dev, 1, intr_out);
+	}
+
+	/* Check for suspend mode */
+	if ((intr_usb & USB_INTR_SUSPEND) && 
+	    (usb_readb(USB_REG_INTRUSBE) & USB_INTR_SUSPEND)) {
+		DEBUG("USB suspend\n");
+		jz4740_handle_suspend(dev);
+
+		do_keep_alive = 0;
+	}
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+	if (do_keep_alive)
+		uh_alive();
+#endif
+
+	spin_unlock(&dev->lock);
+
+#ifdef	TEST_ON_WIN7
+	if (out_flag == 1)
+		mod_timer(&irq_timer, 400+jiffies);
+#endif
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int jz4740_udc_get_frame(struct usb_gadget *_gadget)
+{
+	DEBUG("%s, %p\n", __FUNCTION__, _gadget);
+	return usb_readw(USB_REG_FRAME);
+}
+
+static int jz4740_udc_wakeup(struct usb_gadget *_gadget)
+{
+	/* host may not have enabled remote wakeup */
+	/*if ((UDCCS0 & UDCCS0_DRWF) == 0)
+	   return -EHOSTUNREACH;
+	   udc_set_mask_UDCCR(UDCCR_RSM); */
+	return -ENOTSUPP;
+}
+
+static const struct usb_gadget_ops jz4740_udc_ops = {
+	.get_frame = jz4740_udc_get_frame,
+	.wakeup = jz4740_udc_wakeup,
+	/* current versions must always be self-powered */
+};
+
+/*-------------------------------------------------------------------------*/
+
+static struct jz4740_udc udc_dev = {
+	.usb_address = 0,
+
+	.gadget = {
+		.ops = &jz4740_udc_ops,
+		.ep0 = &udc_dev.ep[0].ep,
+		.name = driver_name,
+		.dev = {
+			.init_name = "gadget",
+		},
+	},
+
+	/* control endpoint */
+	.ep[0] = {
+		.ep = {
+			.name = ep0name,
+			.ops = &jz4740_ep_ops,
+			.maxpacket = EP0_MAXPACKETSIZE,
+		},
+		.dev = &udc_dev,
+
+		.bEndpointAddress = 0,
+		.bmAttributes = 0,
+
+		.ep_type = ep_control,
+		.fifo = USB_FIFO_EP0,
+		.csr = USB_REG_CSR0,
+	},
+
+	/* bulk out endpoint */
+	.ep[1] = {
+		.ep = {
+			.name = "ep1out-bulk",
+			.ops = &jz4740_ep_ops,
+			.maxpacket = EPBULK_MAXPACKETSIZE,
+		},
+		.dev = &udc_dev,
+
+		.bEndpointAddress = 1,
+		.bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		.ep_type = ep_bulk_out,
+		.fifo = USB_FIFO_EP1,
+		.csr = USB_REG_OUTCSR,
+	},
+
+	/* bulk in endpoint */
+	.ep[2] = {
+		.ep = {
+			.name = "ep1in-bulk",
+			.ops = &jz4740_ep_ops,
+			.maxpacket = EPBULK_MAXPACKETSIZE,
+		},
+		.dev = &udc_dev,
+
+		.bEndpointAddress = USB_DIR_IN | 1,
+		.bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		.ep_type = ep_bulk_in,
+		.fifo = USB_FIFO_EP1,
+		.csr = USB_REG_INCSR,
+	},
+
+	/* interrupt in endpoint */
+	.ep[3] = {
+		.ep = {
+			.name = "ep2in-int",
+			.ops = &jz4740_ep_ops,
+			.maxpacket = EPINTR_MAXPACKETSIZE,
+		},
+		.dev = &udc_dev,
+
+		.bEndpointAddress = USB_DIR_IN | 2,
+		.bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		.ep_type = ep_interrupt,
+		.fifo = USB_FIFO_EP2,
+		.csr = USB_REG_INCSR,
+	},
+};
+
+
+
+static int jz4740_udc_probe(struct platform_device *pdev)
+{
+	struct jz4740_udc *dev = &udc_dev;
+	int rc;
+
+	DEBUG("%s\n", __FUNCTION__);
+
+#ifdef 	TEST_ON_WIN7
+	setup_timer(&irq_timer, irq_timer_func, 0);
+#endif
+
+	spin_lock_init(&dev->lock);
+	the_controller = dev;
+
+	dev->dev = &pdev->dev;
+	dev->gadget.dev.parent = &pdev->dev;
+
+//	strcpy (dum->gadget.dev.bus_id, "gadget");
+	dev->gadget.dev.release = jz4740_udc_release;
+	if ((rc = device_register (&dev->gadget.dev)) < 0)
+		return rc;
+	platform_set_drvdata(pdev, dev);
+
+	udc_disable(dev);
+	udc_reinit(dev);
+
+	/* irq setup */
+	if (request_irq(IRQ_UDC, jz4740_udc_irq, IRQF_DISABLED,//SA_SHIRQ/*|SA_SAMPLE_RANDOM*/,
+			driver_name, dev) != 0) {
+		printk(KERN_INFO "request UDC interrupt %d failed\n", IRQ_UDC);
+		return -EBUSY;
+	}
+
+	printk(KERN_INFO "%s\n", driver_desc);
+	printk(KERN_INFO "version: " DRIVER_VERSION "\n");
+	
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+	uh_setup(pdev);
+
+	printk(KERN_INFO "Support UDC Hotplug.\n");
+#endif
+
+	return 0;
+}
+
+static int jz4740_udc_remove(struct platform_device *pdev)
+{
+	struct jz4740_udc *dev = platform_get_drvdata(pdev);
+	DEBUG("%s: %p\n", __FUNCTION__, dev);
+
+	if (dev->driver)
+		return -EBUSY;
+	
+	udc_disable(dev);
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+	uh_cleanup(pdev);
+#endif
+
+	free_irq(IRQ_UDC, dev);
+	platform_set_drvdata(pdev, 0);
+	device_unregister(&dev->gadget.dev);
+	the_controller = 0;
+
+	return 0;
+}
+
+static struct platform_driver udc_driver = {
+	.probe		= jz4740_udc_probe,
+	.remove		= jz4740_udc_remove,
+	.suspend	= NULL,
+	.resume		= NULL,
+	.driver		= {
+		.name	= (char *) driver_name,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_device		the_udc_pdev = {
+	.name		= (char *) gadget_name,
+	.id		= -1,
+	.dev		= {
+		.release	= jz4740_udc_release,
+	},
+};
+
+
+/*-------------------------------------------------------------------------*/
+
+static int __init udc_init (void)
+{
+        platform_driver_register(&udc_driver);
+	return platform_device_register (&the_udc_pdev);
+}
+
+static void __exit udc_exit (void)
+{
+	platform_driver_unregister(&udc_driver);
+	platform_device_unregister(&the_udc_pdev);
+#ifdef TEST_ON_WIN7
+	del_timer(&irq_timer);
+#endif
+}
+
+module_init(udc_init);
+module_exit(udc_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Wei Jianli <jlwei@ingenic.cn>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/jz4740_udc.h b/drivers/usb/gadget/jz4740_udc.h
new file mode 100644
index 0000000..5d59f72
--- /dev/null
+++ b/drivers/usb/gadget/jz4740_udc.h
@@ -0,0 +1,105 @@
+/*
+ * linux/drivers/usb/gadget/jz4740_udc.h
+ *
+ * Ingenic JZ4740 on-chip high speed USB device controller
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __USB_GADGET_JZ4740_H__
+#define __USB_GADGET_JZ4740_H__
+
+/*-------------------------------------------------------------------------*/
+
+// Max packet size
+#define EP0_MAXPACKETSIZE  	64
+#define EPBULK_MAXPACKETSIZE  	512
+#define EPINTR_MAXPACKETSIZE  	64
+
+#define UDC_MAX_ENDPOINTS       4
+
+/*-------------------------------------------------------------------------*/
+
+typedef enum ep_type {
+	ep_control, ep_bulk_in, ep_bulk_out, ep_interrupt
+} ep_type_t;
+
+struct jz4740_ep {
+	struct usb_ep ep;
+	struct jz4740_udc *dev;
+
+	const struct usb_endpoint_descriptor *desc;
+	struct list_head queue;
+	unsigned long pio_irqs;
+
+	u8 stopped;
+	u8 bEndpointAddress;
+	u8 bmAttributes;
+
+	ep_type_t ep_type;
+	u32 fifo;
+	u32 csr;
+
+	u32 reg_addr;
+};
+
+struct jz4740_request {
+	struct usb_request req;
+	struct list_head queue;
+};
+
+enum ep0state {
+	WAIT_FOR_SETUP,		/* between STATUS ack and SETUP report */
+	DATA_STATE_XMIT, 	/* data tx stage */
+	DATA_STATE_NEED_ZLP,	/* data tx zlp stage */
+	WAIT_FOR_OUT_STATUS,	/* status stages */
+	DATA_STATE_RECV,	/* data rx stage */
+};
+
+struct jz4740_udc {
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	struct device *dev;
+	spinlock_t lock;
+
+	enum ep0state ep0state;
+	struct jz4740_ep ep[UDC_MAX_ENDPOINTS];
+
+	unsigned char usb_address;
+};
+
+extern struct jz4740_udc *the_controller;
+
+#define ep_is_in(EP) 		(((EP)->bEndpointAddress&USB_DIR_IN)==USB_DIR_IN)
+#define ep_maxpacket(EP) 	((EP)->ep.maxpacket)
+#define ep_index(EP) 		((EP)->bEndpointAddress&0xF)
+#define usb_set_index(i)	(REG8(USB_REG_INDEX) = (i))
+
+/*-------------------------------------------------------------------------*/
+
+/* 2.5 stuff that's sometimes missing in 2.4 */
+
+#ifndef container_of
+#define	container_of	list_entry
+#endif
+
+#ifndef likely
+#define likely(x)	(x)
+#define unlikely(x)	(x)
+#endif
+
+#ifndef BUG_ON
+#define BUG_ON(condition) do { if (unlikely((condition)!=0)) BUG(); } while(0)
+#endif
+
+#ifndef WARN_ON
+#define	WARN_ON(x)	do { } while (0)
+#endif
+
+#endif /* __USB_GADGET_JZ4740_H__ */
diff --git a/drivers/usb/gadget/udc_hotplug.c b/drivers/usb/gadget/udc_hotplug.c
new file mode 100644
index 0000000..42c6a2b
--- /dev/null
+++ b/drivers/usb/gadget/udc_hotplug.c
@@ -0,0 +1,762 @@
+/*
+ * Ingenic USB Device Controller Hotplug Driver.
+ * 
+ * Author: River Wang <zwang@ingenic.cn> 
+ */
+
+/*
+How to use
+
+1. Basic usage:
+All controlling interfaces are locacated in /sys/devices/platform/jz4740_udc/.
+[uh_cable]: It indicates the status of the cable: offline/power/usb.
+
+2. Asychronous notification: 
+You can use a non-blocking PF_NETLINK socket to receive the uevent sent by udc_houplug. DRIVER & UDC_HOTPLUG_CABLE_STATE varible in uevent can be used to get the status of UDC cable.
+
+3. Notification mode & Gadget loading:
+There are two notification modes can be configured by [uh_notify_mode]: auto/manual.
+Auto: When a USB cable with active signals is plugged in, the udc_hotplug driver will broadcast this event to jz4740_udc & userspace app, and jz4740_udc will try to activate the current gadget. 
+
+This mode is used when userspace APP only wants to get the cable status notification.
+
+Manual: The event will only be broadcast to userspace APP. When APP decides to how to handle this event, It can make it with [uh_notify]:
+auto: The udc_hotplug driver broadcast the latest cable status to jz4740_udc.
+offline/power/usb:....
+
+This mode is recommended when multiple gadgets are used. Userspace APP is notified by the uevent, load the specific gadget module by insmod, then set [uh_notify] to broadcat the event at last.
+*/
+
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/wait.h>
+#include <linux/kthread.h>
+#include <linux/timer.h>
+#include <linux/kobject.h>
+#include <linux/notifier.h>
+
+#include <asm/jzsoc.h>
+
+#define UDC_PFX "jz_hotplug_udc"
+
+#define D(msg, fmt...)  \
+	printk(KERN_ERR UDC_PFX": %s(): "msg, __func__, ##fmt)
+
+#define NR_UDC_WAIT_INTR_LOOP	(5 * 1000 * 1000)
+
+#define DEFAULT_KEEP_ALIVE_TIMER_INTERVAL     (2 * HZ)
+#define DEFAULT_KEEP_ALIVE_COUNTER_LIMIT      2
+
+#define UDC_HOTPLUG_PIN   GPIO_UDC_HOTPLUG
+#define UDC_HOTPLUG_IRQ   (IRQ_GPIO_0 + UDC_HOTPLUG_PIN)
+
+typedef enum {
+	UH_NOTIFY_CABLE_STATE = 0,
+}uh_notify_type_t;
+
+typedef enum {
+	UH_CABLE_STATE_OFFLINE = 0,
+	UH_CABLE_STATE_POWER,
+	UH_CABLE_STATE_USB,
+}uh_cable_state_t;
+
+typedef enum {
+	UH_THREAD_STATE_IDLE = 0,
+	UH_THREAD_STATE_START,
+	UH_THREAD_STATE_BUSY,
+	UH_THREAD_STATE_DONE,
+}uh_thread_state_t;
+
+/* UDC Flag bits */
+enum {
+	BIT_UH_ENABLE,
+
+	/* State changed ?*/
+	BIT_CABLE_STATE_CHANGE,      
+	
+	BIT_DO_DETECT,
+	BIT_DO_NOTIFY,
+
+	/* Keep alive */
+	BIT_KEEP_ALIVE,
+	BIT_KEEP_ALIVE_STOP,
+};
+
+#define DO_DETECT (1 << BIT_DO_DETECT)
+#define DO_NOTIFY (1 << BIT_DO_NOTIFY)
+#define DO_ALL ( DO_DETECT | DO_NOTIFY)
+
+struct uh_data {
+	unsigned long flags;
+
+	/* Notifier */
+	struct blocking_notifier_head notifier_head;
+
+	/* Thread */
+	struct task_struct *kthread;
+
+	int b_notify_mode;
+
+	/* Wait queue */
+	wait_queue_head_t kthread_wq;	/* Kernel thread sleep here. */
+	wait_queue_head_t timer_wq;	/* Wake up when timer is finished. */
+	wait_queue_head_t finish_wq;	/* Wake up when thread is finished. */
+	
+	uh_thread_state_t thread_state;
+	uh_cable_state_t cable_state;	
+	uh_cable_state_t cable_detect_state;	
+	
+	struct timer_list stable_timer;
+	struct timer_list keep_alive_timer; /* Keep alive */
+
+	unsigned long keep_alive_counter_limit;
+	unsigned long keep_alive_timer_interval;
+	unsigned long keep_alive_counter;
+
+	struct platform_device *pdev;
+};
+
+static struct uh_data *g_puh_data = NULL;
+
+static inline void uh_start_work(struct uh_data *uh, int work)
+{
+	if (work & DO_DETECT) {
+		set_bit(BIT_DO_DETECT, &uh->flags);
+	}
+
+	if (work & DO_NOTIFY) {
+		set_bit(BIT_DO_NOTIFY, &uh->flags);
+	}
+
+	mod_timer(&uh->stable_timer, 1 + jiffies);
+
+	return;
+}
+
+static inline void set_cable_state(struct uh_data *uh, uh_cable_state_t state)
+{
+	if (uh->cable_state != state) {
+		D("Cable state: %d -> %d.\n", uh->cable_state, state);
+
+		uh->cable_state = state;
+		set_bit(BIT_CABLE_STATE_CHANGE, &uh->flags);
+	}
+
+	return;
+}
+
+static void uh_stable_timer_func(unsigned long data)
+{
+	struct uh_data *uh = (struct uh_data *)data;
+	
+	D("Called.\n");
+
+	if (!test_bit(BIT_UH_ENABLE, &uh->flags))
+		return;
+
+	uh->thread_state = UH_THREAD_STATE_START;
+
+	/* Start. */
+	wake_up_process(uh->kthread);
+	
+	return;
+}
+
+/* Do cable detection */
+static void cable_detect(struct uh_data *uh)
+{	
+	if (__gpio_get_pin(UDC_HOTPLUG_PIN)) {
+		D("Cable online.\n");
+		
+		uh->cable_detect_state = UH_CABLE_STATE_POWER;
+		
+	}else {
+		D("Cable offline.\n");
+
+		clear_bit(BIT_KEEP_ALIVE, &uh->flags);
+		
+		uh->cable_detect_state = UH_CABLE_STATE_OFFLINE;
+	}
+
+	return;
+}
+	
+/* USB is active ? */
+static int usb_is_active(void)
+{
+	unsigned long timeout = NR_UDC_WAIT_INTR_LOOP;	
+	unsigned long frame_no = REG16(USB_REG_FRAME);
+
+	/* 
+	   Some power charger may cause fake SOF, 
+	   We must handle this situation.
+					- River.
+	*/
+
+	int counter = 7;
+
+	while (timeout && counter) {
+		if (frame_no != REG16(USB_REG_FRAME)) {
+			if (!--counter)
+				break;
+			
+			/* Wait next frame. */
+			frame_no = REG16(USB_REG_FRAME);
+		}
+
+		timeout --;
+	}
+
+	D("timout: %d, counter: %d.\n", timeout, counter);
+
+	return timeout ? 1 : 0;
+}
+
+/* Really do USB detection */
+static int do_usb_detect(struct uh_data *uh)
+{
+	int rv;
+
+	D("Called.\n");
+
+	__intc_mask_irq(IRQ_UDC);
+
+	/* Now enable PHY to start detect */
+#if defined(CONFIG_SOC_JZ4750D)
+	REG_CPM_OPCR |= CPM_OPCR_UDCPHY_ENABLE;
+#endif
+	/* Clear IRQs */
+	REG16(USB_REG_INTRINE) = 0;
+	REG16(USB_REG_INTROUTE) = 0;
+	REG8(USB_REG_INTRUSBE) = 0;
+
+	/* disable UDC IRQs first */
+	REG16(USB_REG_INTRINE) = 0;
+	REG16(USB_REG_INTROUTE) = 0;
+	REG8(USB_REG_INTRUSBE) = 0;
+
+	/* Disable DMA */
+	REG32(USB_REG_CNTL1) = 0;
+	REG32(USB_REG_CNTL2) = 0;
+
+	/* Enable HS Mode */
+	REG8(USB_REG_POWER) |= USB_POWER_HSENAB;
+	/* Enable soft connect */
+	REG8(USB_REG_POWER) |= USB_POWER_SOFTCONN;
+
+	rv = usb_is_active();
+
+	/* Detect finish ,clean every thing */
+	/* Disconnect from usb */
+	REG8(USB_REG_POWER) &= ~USB_POWER_SOFTCONN;
+	
+	/* Disable the USB PHY */
+#if defined(CONFIG_SOC_JZ4750D)
+	REG_CPM_OPCR &= ~CPM_OPCR_UDCPHY_ENABLE;
+#endif
+
+	/* Clear IRQs */
+	REG16(USB_REG_INTRINE) = 0;
+	REG16(USB_REG_INTROUTE) = 0;
+	REG8(USB_REG_INTRUSBE) = 0;
+
+	__intc_ack_irq(IRQ_UDC);
+	__intc_unmask_irq(IRQ_UDC);
+
+	return rv;
+}
+
+/* Do USB bus protocol detection */
+static void usb_detect(struct uh_data *uh)
+{
+	int rv = 0;
+	
+	D("Called.\n");
+
+	/* If the cable has already been offline, we just pass the real USB detection. */
+	if (uh->cable_detect_state != UH_CABLE_STATE_OFFLINE) {
+		D("Do real detection.\n");
+		rv = do_usb_detect(uh);
+	}else{
+		D("No need to do real detection.\n");
+	}
+
+	if (rv) {
+		/* Online. */
+		uh->cable_detect_state = UH_CABLE_STATE_USB;
+	}else{
+		/* No USB Signal. */
+		if (uh->cable_detect_state == UH_CABLE_STATE_POWER) {
+			/* TODO: Wait USB alive again. */ 
+		}
+	}
+	
+	return;
+}
+
+static void do_wait(struct uh_data *uh)
+{
+	D("Called.\n");
+	
+	wait_event(uh->kthread_wq, uh->thread_state == UH_THREAD_STATE_START);
+
+	uh->thread_state = UH_THREAD_STATE_BUSY;
+
+	return;
+}
+
+/* Called from kernel thread */
+static void do_detect(struct uh_data *uh)
+{
+	D("Called.\n");
+	
+	if (!test_and_clear_bit(BIT_DO_DETECT, &uh->flags))
+		return;
+
+	D("Do detect.\n");
+
+	if(__gpio_get_pin(UDC_HOTPLUG_PIN)) {
+		cable_detect(uh);
+		usb_detect(uh);
+		
+		set_cable_state(uh, uh->cable_detect_state);
+	}else{
+		set_cable_state(uh, UH_CABLE_STATE_OFFLINE);
+	}
+	
+	return;
+}
+
+static void __do_notify(struct uh_data *uh) 
+{	
+	D("Called.\n");
+
+	if (test_and_clear_bit(BIT_CABLE_STATE_CHANGE, &uh->flags)) {
+		D("Kick notifier chain.\n");
+
+		blocking_notifier_call_chain(&uh->notifier_head, 
+			UH_NOTIFY_CABLE_STATE, &uh->cable_state);
+		
+
+		D("Send uevent to userspace.\n");
+	
+		switch (uh->cable_state) {
+			case UH_CABLE_STATE_USB:
+				kobject_uevent(&uh->pdev->dev.kobj, KOBJ_ADD);
+				break;
+
+			case UH_CABLE_STATE_POWER:
+				kobject_uevent(&uh->pdev->dev.kobj, KOBJ_CHANGE);
+				break;
+
+			case UH_CABLE_STATE_OFFLINE:
+				kobject_uevent(&uh->pdev->dev.kobj, KOBJ_REMOVE);
+				break;
+		}
+	}
+
+	return;
+}
+
+static inline void do_notify(struct uh_data *uh)
+{
+	if (!uh->b_notify_mode)	/* Auto nofity mode. */
+		set_bit(BIT_DO_NOTIFY, &uh->flags);
+
+	if (test_and_clear_bit(BIT_DO_NOTIFY, &uh->flags))	
+		__do_notify(uh);
+
+	return;
+}
+
+static inline void do_done(struct uh_data *uh)
+{
+	D("Done.\n");
+	
+	uh->thread_state = UH_THREAD_STATE_IDLE;
+	
+	wake_up(&uh->finish_wq);
+	
+	return;
+}
+
+/* Kernel thread */
+static int uh_thread(void *data)
+{
+	struct uh_data *uh = (struct uh_data *)data;
+	
+	while (!kthread_should_stop()) {
+		do_wait(uh);
+
+		if (kthread_should_stop())
+			break;
+
+		do_detect(uh);
+		
+		do_notify(uh);
+		
+		do_done(uh);
+	}
+	
+	D("Exit.\n");
+
+	return 0;
+}
+
+static irqreturn_t uh_irq(int irq, void *dev_id)
+{	
+	struct uh_data *uh = (struct uh_data *)dev_id;
+       
+	D("Called.\n");
+
+	uh_start_work(uh, DO_DETECT);
+
+	return IRQ_HANDLED;
+}
+
+static void uh_init_gpio(struct uh_data *uh)
+{
+        /* get current pin level */
+	__gpio_disable_pull(UDC_HOTPLUG_PIN);
+        __gpio_as_input(UDC_HOTPLUG_PIN);
+
+	udelay(1);
+	
+	/* Because of every plug IN/OUT action will casue more than one interrupt, 
+	   So whether rising trigger or falling trigger method can both start the detection.
+         */
+
+	__gpio_as_irq_rise_edge(UDC_HOTPLUG_PIN);
+
+	return;
+}
+
+static void uh_keep_alive_timer_func(unsigned long data)
+{
+	struct uh_data *uh = (struct uh_data *)data;
+	
+//	D("Timer running.\n");
+	
+	/* Decrease the counter. */
+	if (test_bit(BIT_KEEP_ALIVE, &uh->flags) 
+			&& !(--uh->keep_alive_counter)) {
+
+		if (!usb_is_active()) {
+			D("Timeout.\n");
+
+			clear_bit(BIT_KEEP_ALIVE, &uh->flags);
+
+			if (uh->cable_state == UH_CABLE_STATE_USB)
+				set_cable_state(uh, UH_CABLE_STATE_POWER);
+		
+			uh_start_work(uh, DO_NOTIFY);
+		}
+	}
+
+	/* Set next active time. */
+	if (test_bit(BIT_KEEP_ALIVE, &uh->flags)) {
+		mod_timer(&uh->keep_alive_timer, uh->keep_alive_timer_interval + jiffies);
+	}else{
+		D("Timer will stop.\n");
+
+		set_bit(BIT_KEEP_ALIVE_STOP, &uh->flags);
+		wake_up(&uh->timer_wq);
+	}
+
+	return;
+}
+
+static void uh_set_counter(unsigned long timer_interval_in_jiffies, unsigned long counter_limit)
+{
+	struct uh_data *uh = g_puh_data;
+
+	uh->keep_alive_timer_interval = timer_interval_in_jiffies;
+	uh->keep_alive_counter_limit = counter_limit;
+
+	uh->keep_alive_counter = uh->keep_alive_counter_limit;
+
+	return;
+}
+
+static void uh_disable(void)
+{
+	struct uh_data *uh = g_puh_data;
+	
+	/* Disable the source of input. */
+	clear_bit(BIT_UH_ENABLE, &uh->flags);
+
+	if (test_and_clear_bit(BIT_KEEP_ALIVE, &uh->flags))
+		/* Wait timer stop. */
+		wait_event(uh->timer_wq, test_and_clear_bit(BIT_KEEP_ALIVE_STOP, &uh->flags));
+	
+	/* Wait thread idle. */
+	wait_event(uh->finish_wq, uh->thread_state == UH_THREAD_STATE_IDLE);
+
+	return;
+}
+
+static void uh_enable(void)
+{
+	struct uh_data *uh = g_puh_data;
+
+	set_bit(BIT_UH_ENABLE, &uh->flags);
+
+	return;
+}
+
+static void uh_alive(void)
+{
+	struct uh_data *uh = g_puh_data;
+	
+	if (!test_bit(BIT_UH_ENABLE, &uh->flags))
+		return;
+	
+        /* Reset counter */
+	uh->keep_alive_counter = uh->keep_alive_counter_limit;
+	
+	/* We are alive. */
+	if (!test_bit(BIT_KEEP_ALIVE, &uh->flags)) {
+		D("Active timer.\n");
+
+		/* Active timer. */
+		set_bit(BIT_KEEP_ALIVE, &uh->flags);
+		clear_bit(BIT_KEEP_ALIVE_STOP, &uh->flags);
+
+		mod_timer(&uh->keep_alive_timer, 3 + jiffies);
+	}
+	
+	return;
+}
+
+int uh_register_notifier(struct notifier_block *n)
+{
+	struct uh_data *uh = g_puh_data;
+
+	D("Register notifier: 0x%p.\n", (void *)n);
+
+	BUG_ON(!n->notifier_call);
+
+	/* Notify in auto mode. */
+	if (!uh->b_notify_mode)
+		n->notifier_call(n, UH_NOTIFY_CABLE_STATE, &uh->cable_state);
+	
+	return blocking_notifier_chain_register(&uh->notifier_head, n);
+}EXPORT_SYMBOL(uh_register_notifier);
+
+int uh_unregister_notifier(struct notifier_block *n)
+{
+	struct uh_data *uh = g_puh_data;
+	
+	int rv;
+	
+	D("Unregister notifier: 0x%p.\n", (void *)n);
+	
+	/* Wait all stop. */	
+	uh_disable();
+
+	rv = blocking_notifier_chain_unregister(&uh->notifier_head, n);
+	
+	uh_enable();
+
+	uh_start_work(uh, DO_DETECT);	/* Update status. */
+	
+	return rv;
+}EXPORT_SYMBOL(uh_unregister_notifier);
+
+static ssize_t show_cable(struct device *device, struct device_attribute *attr,
+			char *buf)
+{
+	struct uh_data *uh = g_puh_data;
+
+	char *s = NULL;
+
+	switch (uh->cable_state) {
+		case UH_CABLE_STATE_OFFLINE:
+			s = "offline";
+			break;
+		
+		case UH_CABLE_STATE_POWER:
+			s = "power";
+			break;
+
+		case UH_CABLE_STATE_USB:
+			s = "usb";
+			break;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t show_notify_mode(struct device *device, struct device_attribute *attr,
+			char *buf)
+{
+	struct uh_data *uh = g_puh_data;
+	
+	char *s = uh->b_notify_mode ? "manual" : "auto";
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", s);
+}
+
+static ssize_t store_notify_mode(struct device *device, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct uh_data *uh = g_puh_data;
+
+	if (!strncmp(buf, "auto", 4)) {
+		uh->b_notify_mode = 0;
+	}else if (!strncmp(buf, "manual", 6)) {
+		uh->b_notify_mode = 1;
+	}
+	
+	return count;
+}
+
+
+static ssize_t store_notify(struct device *device, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct uh_data *uh = g_puh_data;
+
+	if (!strncmp(buf, "auto", 4)) { 
+		uh_start_work(uh, DO_ALL);
+	}
+
+	return count;
+}
+
+static struct device_attribute uh_sysfs_attrs[] = {
+	__ATTR(uh_cable, S_IRUGO|S_IWUSR, show_cable, NULL),
+	__ATTR(uh_notify_mode, S_IRUGO|S_IWUSR, show_notify_mode, store_notify_mode),
+	__ATTR(uh_notify, S_IRUGO|S_IWUSR, NULL, store_notify),
+};
+
+static int uh_register_attr(struct platform_device *pdev)
+{
+	int i, error = 0;
+
+	for (i = 0; i < ARRAY_SIZE(uh_sysfs_attrs); i++) {
+		error = device_create_file(&pdev->dev, &uh_sysfs_attrs[i]);
+
+		if (error)
+			break;
+	}
+
+	if (error) {
+		while (--i >= 0)
+			device_remove_file(&pdev->dev, &uh_sysfs_attrs[i]);
+	}
+
+	return 0;
+}
+
+static void uh_unregister_attr(struct platform_device *pdev)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(uh_sysfs_attrs); i++)
+		device_remove_file(&pdev->dev, &uh_sysfs_attrs[i]);
+}
+
+static int uh_setup(struct platform_device *pdev)
+{
+	struct uh_data *uh;
+
+	unsigned long status = 0;
+
+        int rv;
+	
+	g_puh_data = (struct uh_data *)kzalloc(sizeof(struct uh_data), GFP_KERNEL);
+	if (!g_puh_data) {
+		printk(KERN_ERR UDC_PFX": Failed to allocate memory.\n");
+		return -ENOMEM;
+	}
+	
+	uh = g_puh_data;
+	uh->pdev = pdev;
+
+	set_bit(1, &status);
+	
+	init_waitqueue_head(&uh->kthread_wq);
+	init_waitqueue_head(&uh->timer_wq);
+	init_waitqueue_head(&uh->finish_wq);
+
+	BLOCKING_INIT_NOTIFIER_HEAD(&uh->notifier_head);
+
+	setup_timer(&uh->keep_alive_timer, uh_keep_alive_timer_func, (unsigned long)uh);
+	setup_timer(&uh->stable_timer, uh_stable_timer_func, (unsigned long)uh);
+	
+	uh->kthread = kthread_run(uh_thread, uh, "kuhd");
+	if (IS_ERR(uh->kthread)) {
+		printk(KERN_ERR UDC_PFX": Failed to create UDC hotplug monitor thread.\n");
+		rv = PTR_ERR(uh->kthread);
+		goto err;
+	}
+	
+	set_bit(2, &status);
+
+	uh_init_gpio(uh);
+
+	rv = uh_register_attr(pdev);
+	if (rv) {
+		printk(KERN_ERR UDC_PFX": Failed to register UDC sysfs interface.\n");
+		goto err;
+	}
+	
+	set_bit(3, &status);
+
+        rv = request_irq(UDC_HOTPLUG_IRQ, uh_irq, IRQF_DISABLED, UDC_PFX, uh);
+        if (rv) {
+                printk(KERN_ERR UDC_PFX": Could not get udc hotplug irq %d\n", UDC_HOTPLUG_IRQ);
+		goto err;
+        }
+	
+	uh_enable();
+
+	uh_set_counter(DEFAULT_KEEP_ALIVE_TIMER_INTERVAL, DEFAULT_KEEP_ALIVE_COUNTER_LIMIT);
+	
+	uh_start_work(uh, DO_DETECT);	
+
+	printk(KERN_ERR UDC_PFX": Registered.\n");	
+
+	return 0;
+
+err:
+	if (test_bit(3, &status)) {
+		uh_unregister_attr(pdev);
+	}
+
+	if (test_bit(2, &status)) {
+		uh->thread_state = UH_THREAD_STATE_START;
+		kthread_stop(uh->kthread);
+	}
+	
+	if (test_bit(1, &status)) {
+		kfree(g_puh_data);
+	}
+
+	return rv;
+}
+
+static void uh_cleanup(struct platform_device *pdev)
+{
+	struct uh_data *uh = g_puh_data;
+
+	uh_disable();
+
+        free_irq(UDC_HOTPLUG_IRQ, uh);
+
+	/* Let our thread to exit. */
+	uh->thread_state = UH_THREAD_STATE_START;
+        kthread_stop(uh->kthread);
+
+	uh_unregister_attr(pdev);
+        kfree(uh);
+
+        return;
+}
+
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 6e16244..8aaf118 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -242,6 +242,106 @@ config FB_TILEBLITTING
 comment "Frame buffer hardware drivers"
 	depends on FB
 
+
+config FB_JZ475X
+	tristate "JZ475X LCD Controller Driver Support (Staging. Only used for test.)"
+	depends on FB && (SOC_JZ4750 || SOC_JZ4750D)
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	default n
+
+config FB_JZ475X_TVE_PAL_OUTPUT
+	tristate "JZ475X TVE PAL Output Support"
+	depends on FB_JZ475X
+	---help---
+	default n
+
+config FB_JZ475X_TVE_NTSC_OUTPUT
+	tristate "JZ475X TVE NTSC Output Support"
+	depends on FB_JZ475X
+	---help---
+	default n
+
+config FB_JZ475X_LCD_OUTPUT
+	tristate "JZ475X LCD Output Support"
+	depends on FB_JZ475X
+	default y
+	---help---
+	default n
+
+choice
+	depends on FB_JZ475X_LCD_OUTPUT
+	prompt "LCD Output Support"
+	default FB_JZ475X_LCD_PANEL_AUO_A043FL01V2	
+	---help---
+	   Please select the lcd panel in you board
+
+config FB_JZ475X_LCD_PANEL_AUO_A043FL01V2
+	bool "AUO A043FL01V2 TFT panel (480x272)(24bits)"
+
+endchoice
+
+config FB_JZSOC
+	tristate "JZSOC LCD/EPD controller support"
+	depends on FB && JZSOC
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	   JZSOC LCD Controller, Smart LCD Controller driver support and EPD Controller driver support.
+
+config FB_JZ4750_LCD
+	tristate "JZ4750 LCD Controller support"
+	depends on FB_JZSOC && SOC_JZ4750D
+	---help---
+	   JZ4750 LCD Controller driver.
+	   JZ4750 LCD Controller support OSD function(refer jz4750_lcdc_spec.pdf).JZ4750 LCD OSD implement 2 framebuffer layers: foreground0 and foreground1. JZ4750 LCD driver support only foreground0 default.
+
+config FB_JZ4750_LCD_USE_2LAYER_FRAMEBUFFER
+	bool "JZ4750 LCD driver 2 layers framebuffer support."
+	depends on FB_JZ4750_LCD
+	---help---
+	   JZ4750 LCD driver support only foreground0 by default.
+	   If you need both foreground0 and foreground1, please select this.
+
+config FB_JZ4750_TVE
+	tristate "JZ4750 TV Encode support"
+	depends on FB_JZSOC && FB_JZ4750_LCD
+	default n
+
+config JZ4750_IPU_MM
+	tristate "JZ4750 IPU MM support"
+	depends on FB_JZSOC && FB_JZ4750_LCD
+	default y
+	---help---
+	   Enable IPU Memory Management system. 
+	   It will reserve 16MB / 16MB + 4MB as IPU Framebuffer on JZ4750 / JZ4755. 
+	   Enable this if you want to use IPU.
+
+config FB_JZ4750_SLCD
+	bool
+	depends on FB_JZ4750_LCD
+	default n
+choice
+	depends on FB_JZ4750_LCD
+	prompt "JZ4750 LCD Panels Support"
+	default JZ4750_LCD_SAMSUNG_LTP400WQF02
+	---help---
+	   Please select the lcd panel in you board
+
+config JZ4750_LCD_SAMSUNG_LTP400WQF01
+	bool "SAMSUNG LTP400WQF01 TFT panel (480x272)(16bits)"
+
+config JZ4750_LCD_SAMSUNG_LTP400WQF02
+	bool "SAMSUNG LTP400WQF02 TFT panel (480x272)(18bits)"
+
+config JZ4750_LCD_AUO_A043FL01V2
+	bool "AUO A043FL01V2 TFT panel (480x272)(24bits)"
+
+endchoice
+
 config FB_CIRRUS
 	tristate "Cirrus Logic support"
 	depends on FB && (ZORRO || PCI)
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index ddc2af2..ed468fe 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -28,6 +28,11 @@ obj-$(CONFIG_FB_DDC)           += fb_ddc.o
 obj-$(CONFIG_FB_DEFERRED_IO)   += fb_defio.o
 
 # Hardware specific drivers go first
+obj-$(CONFIG_FB_JZ475X)		+= jz475x/
+
+obj-$(CONFIG_FB_JZ4750_LCD)       += jz4750_lcd.o
+obj-$(CONFIG_FB_JZ4750_TVE)       += jz4750_tve.o
+
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
 obj-$(CONFIG_FB_ARC)              += arcfb.o
 obj-$(CONFIG_FB_CLPS711X)         += clps711xfb.o
diff --git a/drivers/video/console/Kconfig b/drivers/video/console/Kconfig
index 8e8f18d..38ae828 100644
--- a/drivers/video/console/Kconfig
+++ b/drivers/video/console/Kconfig
@@ -112,6 +112,14 @@ config FRAMEBUFFER_CONSOLE_DETECT_PRIMARY
 
 	 If unsure, select n.
 
+config FRAMEBUFFER_CONSOLE_CURSOR_FLASH
+       bool "Framebuffer Console Cursor flash"
+       depends on FRAMEBUFFER_CONSOLE
+       help
+         Enable cursor flush for the framebuffer console.  This is done
+         in software and may be significantly slower than a normally oriented
+         display.
+
 config FRAMEBUFFER_CONSOLE_ROTATION
        bool "Framebuffer Console Rotation"
        depends on FRAMEBUFFER_CONSOLE
diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c
index b0a3fa0..447c7c3 100644
--- a/drivers/video/console/fbcon.c
+++ b/drivers/video/console/fbcon.c
@@ -367,6 +367,7 @@ static void fbcon_update_softback(struct vc_data *vc)
 
 static void fb_flashcursor(struct work_struct *work)
 {
+#ifdef CONFIG_FRAMEBUFFER_CONSOLE_CURSOR_FLASH
 	struct fb_info *info = container_of(work, struct fb_info, queue);
 	struct fbcon_ops *ops = info->fbcon_par;
 	struct display *p;
@@ -392,6 +393,7 @@ static void fb_flashcursor(struct work_struct *work)
 	ops->cursor(vc, info, mode, softback_lines, get_color(vc, info, c, 1),
 		    get_color(vc, info, c, 0));
 	release_console_sem();
+#endif
 }
 
 static void cursor_timer_handler(unsigned long dev_addr)
diff --git a/drivers/video/jz4750_lcd.c b/drivers/video/jz4750_lcd.c
new file mode 100644
index 0000000..4a2fcfe
--- /dev/null
+++ b/drivers/video/jz4750_lcd.c
@@ -0,0 +1,2295 @@
+/*
+ * linux/drivers/video/jz4750_lcd.c -- Ingenic Jz4750 LCD frame buffer device
+ *
+ * Copyright (C) 2005-2008, Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * --------------------------------
+ * NOTE:
+ * This LCD driver support TFT16 TFT32 LCD, not support STN and Special TFT LCD 
+ * now.
+ * 	It seems not necessory to support STN and Special TFT.
+ * 	If it's necessary, update this driver in the future.
+ * 	<Wolfgang Wang, Jun 10 2008>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/processor.h>
+#include <asm/jzsoc.h>
+
+#include "console/fbcon.h"
+
+#include "jz4750_lcd.h"
+#include "jz4750_tve.h"
+
+MODULE_DESCRIPTION("Jz4750 LCD Controller driver");
+MODULE_AUTHOR("Wolfgang Wang, <lgwang@ingenic.cn>");
+MODULE_LICENSE("GPL");
+
+#define D(fmt, args...) \
+//	printk(KERN_ERR "%s(): "fmt"\n", __func__, ##args)
+
+#define E(fmt, args...) \
+	printk(KERN_ERR "%s(): "fmt"\n", __func__, ##args)
+
+#define JZ_FB_DEBUG 0
+
+struct jz4750lcd_info jz4750_lcd_panel = {
+#if defined(CONFIG_JZ4750_LCD_SAMSUNG_LTP400WQF02)
+	.panel = {
+		.cfg = LCD_CFG_LCDPIN_LCD | LCD_CFG_RECOVER | /* Underrun recover */ 
+		LCD_CFG_NEWDES | /* 8words descriptor */
+		LCD_CFG_MODE_GENERIC_TFT | /* General TFT panel */
+		LCD_CFG_MODE_TFT_18BIT | 	/* output 18bpp */
+		LCD_CFG_HSP | 	/* Hsync polarity: active low */
+		LCD_CFG_VSP,	/* Vsync polarity: leading edge is falling edge */
+		.slcd_cfg = 0,
+		.ctrl = LCD_CTRL_OFUM | LCD_CTRL_BST_16,	/* 16words burst, enable out FIFO underrun irq */
+		480, 272, 60, 41, 10, 2, 2, 2, 2,
+	},
+	.osd = {
+		 .osd_cfg = LCD_OSDC_OSDEN | /* Use OSD mode */
+//		 LCD_OSDC_ALPHAEN | /* enable alpha */
+		 LCD_OSDC_F0EN,	/* enable Foreground0 */
+		 .osd_ctrl = 0,		/* disable ipu,  */
+		 .rgb_ctrl = 0,
+		 .bgcolor = 0x000000, /* set background color Black */
+		 .colorkey0 = 0, /* disable colorkey */
+		 .colorkey1 = 0, /* disable colorkey */
+		 .alpha = 0xA0,	/* alpha value */
+		 .ipu_restart = 0x80001000, /* ipu restart */
+		 .fg_change = FG_CHANGE_ALL, /* change all initially */
+		 .fg0 = {32, 0, 0, 480, 272}, /* bpp, x, y, w, h */
+		 .fg1 = {32, 0, 0, 720, 573}, /* bpp, x, y, w, h */
+	 },
+#elif defined(CONFIG_JZ4750_LCD_AUO_A043FL01V2)
+	// rzx50
+	.panel = {
+		.cfg = LCD_CFG_LCDPIN_LCD | LCD_CFG_RECOVER | /* Underrun recover */ 
+		LCD_CFG_NEWDES | /* 8words descriptor */
+		LCD_CFG_MODE_GENERIC_TFT | /* General TFT panel */
+		LCD_CFG_MODE_TFT_24BIT | 	/* output 18bpp */
+		LCD_CFG_HSP | 	/* Hsync polarity: active low */
+		LCD_CFG_VSP,	/* Vsync polarity: leading edge is falling edge */
+		.slcd_cfg = 0,
+		.ctrl = LCD_CTRL_OFUM | LCD_CTRL_BST_16,	/* 16words burst, enable out FIFO underrun irq */
+		480, 272, 60, 41, 10, 8, 4, 4, 2,
+	},
+	.osd = {
+		 .osd_cfg = LCD_OSDC_OSDEN | /* Use OSD mode */
+//		 LCD_OSDC_ALPHAEN | /* enable alpha */
+//		 LCD_OSDC_F1EN | /* enable Foreground1 */
+		 LCD_OSDC_F0EN,	/* enable Foreground0 */
+		 .osd_ctrl = 0,		/* disable ipu,  */
+		 .rgb_ctrl = 0,
+		 .bgcolor = 0x000000, /* set background color Black */
+		 .colorkey0 = 0, /* disable colorkey */
+		 .colorkey1 = 0, /* disable colorkey */
+		 .alpha = 0xA0,	/* alpha value */
+		 .ipu_restart = 0x80001000, /* ipu restart */
+		 .fg_change = FG_CHANGE_ALL, /* change all initially */
+		 .fg0 = {16, 0, 0, 480, 272}, /* bpp, x, y, w, h */
+		 .fg1 = {16, 0, 0, 720, 573}, /* bpp, x, y, w, h */
+	 },
+#else
+#error "Select LCD panel first!!!"
+#endif
+};
+
+struct jz4750lcd_info jz4750_info_tve = {
+	.panel = {
+		.cfg = LCD_CFG_TVEN | /* output to tve */
+		LCD_CFG_NEWDES | /* 8words descriptor */
+		LCD_CFG_RECOVER | /* underrun protect */
+		LCD_CFG_MODE_INTER_CCIR656, /* Interlace CCIR656 mode */
+		.ctrl = LCD_CTRL_OFUM | LCD_CTRL_BST_16,	/* 16words burst */
+		TVE_WIDTH_PAL, TVE_HEIGHT_PAL, TVE_FREQ_PAL, 0, 0, 0, 0, 0, 0,
+	},
+	.osd = {
+		 .osd_cfg = LCD_OSDC_OSDEN | /* Use OSD mode */
+//		 LCD_OSDC_ALPHAEN | /* enable alpha */
+		 LCD_OSDC_F0EN,	/* enable Foreground0 */
+		 .osd_ctrl = 0,		/* disable ipu,  */
+		 .rgb_ctrl = LCD_RGBC_YCC, /* enable RGB => YUV */
+		 .bgcolor = 0x00000000, /* set background color Black */
+		 .colorkey0 = 0, /* disable colorkey */
+		 .colorkey1 = 0, /* disable colorkey */
+		 .alpha = 0xA0,	/* alpha value */
+		 .ipu_restart = 0x80000100, /* ipu restart */
+		 .fg_change = FG_CHANGE_ALL, /* change all initially */
+		 .fg0 = {32,},	/*  */
+		 .fg0 = {32,},
+	},
+};
+
+struct jz4750lcd_info *jz4750_lcd_info = &jz4750_lcd_panel; /* default output to lcd panel */
+static struct lcd_cfb_info *jz4750fb_info;
+static struct jz4750_lcd_dma_desc *dma_desc_base;
+static struct jz4750_lcd_dma_desc *dma0_desc_palette, *dma0_desc0, *dma0_desc1, *dma1_desc0, *dma1_desc1;
+
+#if JZ_FB_DEBUG
+static unsigned char *lcd_frame_test;
+static unsigned char *lcd_frame_test1;
+static int lcd_frame_size=0;
+
+static void display_h_color_bar(int w, int h, int bpp) ;
+
+static void print_lcdc_registers(void)	/* debug */
+{
+	/* LCD Controller Resgisters */
+	printk("REG_LCD_CFG:\t0x%08x\n", REG_LCD_CFG);
+	printk("REG_LCD_CTRL:\t0x%08x\n", REG_LCD_CTRL);
+	printk("REG_LCD_STATE:\t0x%08x\n", REG_LCD_STATE);
+	printk("REG_LCD_OSDC:\t0x%08x\n", REG_LCD_OSDC);
+	printk("REG_LCD_OSDCTRL:\t0x%08x\n", REG_LCD_OSDCTRL);
+	printk("REG_LCD_OSDS:\t0x%08x\n", REG_LCD_OSDS);
+	printk("REG_LCD_BGC:\t0x%08x\n", REG_LCD_BGC);
+	printk("REG_LCD_KEK0:\t0x%08x\n", REG_LCD_KEY0);
+	printk("REG_LCD_KEY1:\t0x%08x\n", REG_LCD_KEY1);
+	printk("REG_LCD_ALPHA:\t0x%08x\n", REG_LCD_ALPHA);
+	printk("REG_LCD_IPUR:\t0x%08x\n", REG_LCD_IPUR);
+	printk("REG_LCD_VAT:\t0x%08x\n", REG_LCD_VAT);
+	printk("REG_LCD_DAH:\t0x%08x\n", REG_LCD_DAH);
+	printk("REG_LCD_DAV:\t0x%08x\n", REG_LCD_DAV);
+	printk("REG_LCD_XYP0:\t0x%08x\n", REG_LCD_XYP0);
+	printk("REG_LCD_XYP1:\t0x%08x\n", REG_LCD_XYP1);
+	printk("REG_LCD_SIZE0:\t0x%08x\n", REG_LCD_SIZE0);
+	printk("REG_LCD_SIZE1:\t0x%08x\n", REG_LCD_SIZE1);
+	printk("REG_LCD_RGBC\t0x%08x\n", REG_LCD_RGBC);
+	printk("REG_LCD_VSYNC:\t0x%08x\n", REG_LCD_VSYNC);
+	printk("REG_LCD_HSYNC:\t0x%08x\n", REG_LCD_HSYNC);
+	printk("REG_LCD_PS:\t0x%08x\n", REG_LCD_PS);
+	printk("REG_LCD_CLS:\t0x%08x\n", REG_LCD_CLS);
+	printk("REG_LCD_SPL:\t0x%08x\n", REG_LCD_SPL);
+	printk("REG_LCD_REV:\t0x%08x\n", REG_LCD_REV);
+	printk("REG_LCD_IID:\t0x%08x\n", REG_LCD_IID);
+	printk("REG_LCD_DA0:\t0x%08x\n", REG_LCD_DA0);
+	printk("REG_LCD_SA0:\t0x%08x\n", REG_LCD_SA0);
+	printk("REG_LCD_FID0:\t0x%08x\n", REG_LCD_FID0);
+	printk("REG_LCD_CMD0:\t0x%08x\n", REG_LCD_CMD0);
+	printk("REG_LCD_OFFS0:\t0x%08x\n", REG_LCD_OFFS0);
+	printk("REG_LCD_PW0:\t0x%08x\n", REG_LCD_PW0);
+	printk("REG_LCD_CNUM0:\t0x%08x\n", REG_LCD_CNUM0);
+	printk("REG_LCD_DESSIZE0:\t0x%08x\n", REG_LCD_DESSIZE0);
+	printk("REG_LCD_DA1:\t0x%08x\n", REG_LCD_DA1);
+	printk("REG_LCD_SA1:\t0x%08x\n", REG_LCD_SA1);
+	printk("REG_LCD_FID1:\t0x%08x\n", REG_LCD_FID1);
+	printk("REG_LCD_CMD1:\t0x%08x\n", REG_LCD_CMD1);
+	printk("REG_LCD_OFFS1:\t0x%08x\n", REG_LCD_OFFS1);
+	printk("REG_LCD_PW1:\t0x%08x\n", REG_LCD_PW1);
+	printk("REG_LCD_CNUM1:\t0x%08x\n", REG_LCD_CNUM1);
+	printk("REG_LCD_DESSIZE1:\t0x%08x\n", REG_LCD_DESSIZE1);
+	printk("==================================\n");
+	printk("REG_LCD_VSYNC:\t%d:%d\n", REG_LCD_VSYNC>>16, REG_LCD_VSYNC&0xfff);
+	printk("REG_LCD_HSYNC:\t%d:%d\n", REG_LCD_HSYNC>>16, REG_LCD_HSYNC&0xfff);
+	printk("REG_LCD_VAT:\t%d:%d\n", REG_LCD_VAT>>16, REG_LCD_VAT&0xfff);
+	printk("REG_LCD_DAH:\t%d:%d\n", REG_LCD_DAH>>16, REG_LCD_DAH&0xfff);
+	printk("REG_LCD_DAV:\t%d:%d\n", REG_LCD_DAV>>16, REG_LCD_DAV&0xfff);
+	printk("==================================\n");
+
+	/* Smart LCD Controller Resgisters */
+	printk("REG_SLCD_CFG:\t0x%08x\n", REG_SLCD_CFG);
+	printk("REG_SLCD_CTRL:\t0x%08x\n", REG_SLCD_CTRL);
+	printk("REG_SLCD_STATE:\t0x%08x\n", REG_SLCD_STATE);
+	printk("==================================\n");
+
+	/* TVE Controller Resgisters */
+	printk("REG_TVE_CTRL:\t0x%08x\n", REG_TVE_CTRL);
+	printk("REG_TVE_FRCFG:\t0x%08x\n", REG_TVE_FRCFG);
+	printk("REG_TVE_SLCFG1:\t0x%08x\n", REG_TVE_SLCFG1);
+	printk("REG_TVE_SLCFG2:\t0x%08x\n", REG_TVE_SLCFG2);
+	printk("REG_TVE_SLCFG3:\t0x%08x\n", REG_TVE_SLCFG3);
+	printk("REG_TVE_LTCFG1:\t0x%08x\n", REG_TVE_LTCFG1);
+	printk("REG_TVE_LTCFG2:\t0x%08x\n", REG_TVE_LTCFG2);
+	printk("REG_TVE_CFREQ:\t0x%08x\n", REG_TVE_CFREQ);
+	printk("REG_TVE_CPHASE:\t0x%08x\n", REG_TVE_CPHASE);
+	printk("REG_TVE_CBCRCFG:\t0x%08x\n", REG_TVE_CBCRCFG);
+	printk("REG_TVE_WSSCR:\t0x%08x\n", REG_TVE_WSSCR);
+	printk("REG_TVE_WSSCFG1:\t0x%08x\n", REG_TVE_WSSCFG1);
+	printk("REG_TVE_WSSCFG2:\t0x%08x\n", REG_TVE_WSSCFG2);
+	printk("REG_TVE_WSSCFG3:\t0x%08x\n", REG_TVE_WSSCFG3);
+
+	printk("==================================\n");
+
+	if ( 1 ) {
+		unsigned int * pii = (unsigned int *)dma_desc_base;
+		int i, j;
+		/*for (j=0;j< DMA_DESC_NUM ; j++) {
+			printk("dma_desc%d(0x%08x):\n", j, (unsigned int)pii);
+			for (i =0; i<8; i++ ) {
+				printk("\t\t0x%08x\n", *pii++);
+			}
+		}*/
+	}
+}
+#else
+#define print_lcdc_registers()
+#endif
+
+struct lcd_cfb_info {
+	struct fb_info		fb;
+	struct {
+		u16 red, green, blue;
+	} palette[NR_PALETTE];
+
+	int b_lcd_display;
+	int b_lcd_pwm;
+	int backlight_level;
+};
+
+#define DMA_DESC_NUM 		6
+
+static unsigned char *lcd_palette;
+static unsigned char *lcd_frame0;
+static unsigned char *lcd_frame1;
+
+static struct jz4750_lcd_dma_desc *dma0_desc_cmd0, *dma0_desc_cmd;
+static unsigned char *lcd_cmdbuf;
+
+static void jz4750fb_set_mode( struct jz4750lcd_info * lcd_info );
+static void jz4750fb_deep_set_mode( struct jz4750lcd_info * lcd_info );
+
+static int jz4750fb_set_backlight_level(int n);
+
+static int screen_on(void);
+static int screen_off(void);
+
+static void ctrl_enable(void)
+{
+	REG_LCD_STATE = 0; /* clear lcdc status */
+	__lcd_slcd_special_on();
+	__lcd_clr_dis();
+	__lcd_set_ena(); /* enable lcdc */
+	
+	return;
+}
+
+static void ctrl_disable(void)
+{
+	if ( jz4750_lcd_info->panel.cfg & LCD_CFG_LCDPIN_SLCD || 
+			jz4750_lcd_info->panel.cfg & LCD_CFG_TVEN ) /*  */
+		__lcd_clr_ena(); /* Smart lcd and TVE mode only support quick disable */
+	else {
+		int cnt;
+		/* when CPU main freq is 336MHz,wait for 16ms */
+		cnt = 336000 * 16;
+		__lcd_set_dis(); /* regular disable */
+		while(!__lcd_disable_done() && cnt) {
+			cnt--;
+		}
+		if (cnt == 0)
+			printk("LCD disable timeout! REG_LCD_STATE=0x%08xx\n",REG_LCD_STATE);
+		REG_LCD_STATE &= ~LCD_STATE_LDD;
+	}
+	
+	return;
+}
+
+static inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+        chan &= 0xffff;
+        chan >>= 16 - bf->length;
+        return chan << bf->offset;
+}
+
+static int jz4750fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			  u_int transp, struct fb_info *info)
+{
+	struct lcd_cfb_info *cfb = (struct lcd_cfb_info *)info;
+	unsigned short *ptr, ctmp;
+
+//	D("regno:%d,RGBt:(%d,%d,%d,%d)\t", regno, red, green, blue, transp);
+	if (regno >= NR_PALETTE)
+		return 1;
+
+	cfb->palette[regno].red		= red ;
+	cfb->palette[regno].green	= green;
+	cfb->palette[regno].blue	= blue;
+	if (cfb->fb.var.bits_per_pixel <= 16) {
+		red	>>= 8;
+		green	>>= 8;
+		blue	>>= 8;
+
+		red	&= 0xff;
+		green	&= 0xff;
+		blue	&= 0xff;
+	}
+	switch (cfb->fb.var.bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+		if (((jz4750_lcd_info->panel.cfg & LCD_CFG_MODE_MASK) == LCD_CFG_MODE_SINGLE_MSTN ) ||
+		    ((jz4750_lcd_info->panel.cfg & LCD_CFG_MODE_MASK) == LCD_CFG_MODE_DUAL_MSTN )) {
+			ctmp = (77L * red + 150L * green + 29L * blue) >> 8;
+			ctmp = ((ctmp >> 3) << 11) | ((ctmp >> 2) << 5) |
+				(ctmp >> 3);
+		} else {
+			/* RGB 565 */
+			if (((red >> 3) == 0) && ((red >> 2) != 0))
+			red = 1 << 3;
+			if (((blue >> 3) == 0) && ((blue >> 2) != 0))
+				blue = 1 << 3;
+			ctmp = ((red >> 3) << 11) 
+				| ((green >> 2) << 5) | (blue >> 3);
+		}
+
+		ptr = (unsigned short *)lcd_palette;
+		ptr = (unsigned short *)(((u32)ptr)|0xa0000000);
+		ptr[regno] = ctmp;
+
+		break;
+		
+	case 15:
+		if (regno < 16)
+			((u32 *)cfb->fb.pseudo_palette)[regno] =
+				((red >> 3) << 10) | 
+				((green >> 3) << 5) |
+				(blue >> 3);
+		break;
+	case 16:
+		if (regno < 16) {
+			((u32 *)cfb->fb.pseudo_palette)[regno] =
+				((red >> 3) << 11) | 
+				((green >> 2) << 5) |
+				(blue >> 3); 
+		}
+		break;
+	case 17 ... 32:
+		if (regno < 16)
+			((u32 *)cfb->fb.pseudo_palette)[regno] =
+				(red << 16) | 
+				(green << 8) |
+				(blue << 0); 
+
+/*		if (regno < 16) {
+			unsigned val;
+                        val  = chan_to_field(red, &cfb->fb.var.red);
+                        val |= chan_to_field(green, &cfb->fb.var.green);
+                        val |= chan_to_field(blue, &cfb->fb.var.blue);
+			((u32 *)cfb->fb.pseudo_palette)[regno] = val;
+		}
+*/
+
+		break;
+	}
+	return 0;
+}
+
+
+/* 
+ * switch to tve mode from lcd mode
+ * mode:
+ * 	PANEL_MODE_TVE_PAL: switch to TVE_PAL mode
+ * 	PANEL_MODE_TVE_NTSC: switch to TVE_NTSC mode
+ */
+static void jz4750lcd_info_switch_to_TVE(int mode)
+{
+	struct jz4750lcd_info *info;
+	struct jz4750lcd_osd_t *osd_lcd;
+	int x, y, w, h;
+
+	info = jz4750_lcd_info = &jz4750_info_tve;
+	osd_lcd = &jz4750_lcd_panel.osd;
+
+	switch ( mode ) {
+	case PANEL_MODE_TVE_PAL:
+		info->panel.cfg |= LCD_CFG_TVEPEH; /* TVE PAL enable extra halfline signal */
+		info->panel.w = TVE_WIDTH_PAL;
+		info->panel.h = TVE_HEIGHT_PAL;
+		info->panel.fclk = TVE_FREQ_PAL;
+		w = ( osd_lcd->fg0.w < TVE_WIDTH_PAL )? osd_lcd->fg0.w:TVE_WIDTH_PAL;
+		h = ( osd_lcd->fg0.h < TVE_HEIGHT_PAL )?osd_lcd->fg0.h:TVE_HEIGHT_PAL;
+//		x = ((TVE_WIDTH_PAL - w) >> 2) << 1;
+//		y = ((TVE_HEIGHT_PAL - h) >> 2) << 1;
+		x = 0;
+		y = 0;
+
+		info->osd.fg0.bpp = osd_lcd->fg0.bpp;
+		info->osd.fg0.x = x;
+		info->osd.fg0.y = y;
+		info->osd.fg0.w = w;
+		info->osd.fg0.h = h;
+		w = ( osd_lcd->fg1.w < TVE_WIDTH_PAL )? osd_lcd->fg1.w:TVE_WIDTH_PAL;
+		h = ( osd_lcd->fg1.h < TVE_HEIGHT_PAL )?osd_lcd->fg1.h:TVE_HEIGHT_PAL;
+//		x = ((TVE_WIDTH_PAL-w) >> 2) << 1;
+//		y = ((TVE_HEIGHT_PAL-h) >> 2) << 1;
+		x = 0;
+		y = 0;
+
+		info->osd.fg1.bpp = 32;	/* use RGB888 in TVE mode*/
+		info->osd.fg1.x = x;
+		info->osd.fg1.y = y;
+		info->osd.fg1.w = w;
+		info->osd.fg1.h = h;
+		break;
+	case PANEL_MODE_TVE_NTSC:
+		info->panel.cfg &= ~LCD_CFG_TVEPEH; /* TVE NTSC disable extra halfline signal */
+		info->panel.w = TVE_WIDTH_NTSC;
+		info->panel.h = TVE_HEIGHT_NTSC;
+		info->panel.fclk = TVE_FREQ_NTSC;
+		w = ( osd_lcd->fg0.w < TVE_WIDTH_NTSC )? osd_lcd->fg0.w:TVE_WIDTH_NTSC;
+		h = ( osd_lcd->fg0.h < TVE_HEIGHT_NTSC)?osd_lcd->fg0.h:TVE_HEIGHT_NTSC;
+		x = ((TVE_WIDTH_NTSC - w) >> 2) << 1;
+		y = ((TVE_HEIGHT_NTSC - h) >> 2) << 1;
+//		x = 0;
+//		y = 0;
+		info->osd.fg0.bpp = osd_lcd->fg0.bpp;
+		info->osd.fg0.x = x;
+		info->osd.fg0.y = y;
+		info->osd.fg0.w = w;
+		info->osd.fg0.h = h;
+		w = ( osd_lcd->fg1.w < TVE_WIDTH_NTSC )? osd_lcd->fg1.w:TVE_WIDTH_NTSC;
+		h = ( osd_lcd->fg1.h < TVE_HEIGHT_NTSC)?osd_lcd->fg1.h:TVE_HEIGHT_NTSC;
+		x = ((TVE_WIDTH_NTSC - w) >> 2) << 1;
+		y = ((TVE_HEIGHT_NTSC - h) >> 2) << 1;
+		info->osd.fg1.bpp = 32;	/* use RGB888 int TVE mode */
+		info->osd.fg1.x = x;
+		info->osd.fg1.y = y;
+		info->osd.fg1.w = w;
+		info->osd.fg1.h = h;
+		break;
+	default:
+		printk("%s, %s: Unknown tve mode\n", __FILE__, __FUNCTION__);
+	}
+}
+
+static int jz4750fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+        void __user *argp = (void __user *)arg;
+
+	switch (cmd) {
+	case FBIOSETBACKLIGHT:
+		jz4750fb_set_backlight_level(arg);
+
+		break;
+
+	case FBIODISPON:
+		ctrl_enable();
+		screen_on();
+
+		break;
+
+	case FBIODISPOFF:
+		screen_off();
+		ctrl_disable();
+
+		break;
+
+	case FBIOPRINT_REG:
+		print_lcdc_registers();
+
+		break;
+
+	case FBIO_GET_MODE:
+		D("fbio get mode\n");
+
+		if (copy_to_user(argp, jz4750_lcd_info, sizeof(struct jz4750lcd_info)))
+			return -EFAULT;
+
+		break;
+
+	case FBIO_SET_MODE:
+		D("fbio set mode\n");
+
+		if (copy_from_user(jz4750_lcd_info, argp, sizeof(struct jz4750lcd_info)))
+			return -EFAULT;
+
+		/* set mode */
+		jz4750fb_set_mode(jz4750_lcd_info);
+
+		break;
+
+	case FBIO_DEEP_SET_MODE:
+		D("fbio deep set mode\n");
+
+		if (copy_from_user(jz4750_lcd_info, argp, sizeof(struct jz4750lcd_info)))
+			return -EFAULT;
+
+		jz4750fb_deep_set_mode(jz4750_lcd_info);
+
+		break;
+
+#ifdef CONFIG_FB_JZ4750_TVE
+	case FBIO_MODE_SWITCH:
+		D("FBIO_MODE_SWITCH");
+		switch (arg) {
+			case PANEL_MODE_TVE_PAL: 	/* switch to TVE_PAL mode */
+			case PANEL_MODE_TVE_NTSC: 	/* switch to TVE_NTSC mode */
+				jz4750lcd_info_switch_to_TVE(arg);
+				jz4750tve_init(arg); /* tve controller init */
+				udelay(100);
+				jz4750tve_enable_tve();
+				/* turn off lcd backlight */
+				screen_off();
+				break;
+			case PANEL_MODE_LCD_PANEL: 	/* switch to LCD mode */
+			default :
+				/* turn off TVE, turn off DACn... */
+				jz4750tve_disable_tve();
+				jz4750_lcd_info = &jz4750_lcd_panel;
+				/* turn on lcd backlight */
+				screen_on();
+				break;
+		}
+
+		jz4750fb_deep_set_mode(jz4750_lcd_info);
+
+		break;
+
+	case FBIO_GET_TVE_MODE:
+		D("fbio get TVE mode\n");
+		if (copy_to_user(argp, jz4750_tve_info, sizeof(struct jz4750tve_info)))
+			return -EFAULT;
+		break;
+	case FBIO_SET_TVE_MODE:
+		D("fbio set TVE mode\n");
+		if (copy_from_user(jz4750_tve_info, argp, sizeof(struct jz4750tve_info)))
+			return -EFAULT;
+		/* set tve mode */
+		jz4750tve_set_tve_mode(jz4750_tve_info);
+		break;
+#endif
+	default:
+		printk("%s, unknown command(0x%x)", __FILE__, cmd);
+		break;
+	}
+
+	return ret;
+}
+
+/* Use mmap /dev/fb can only get a non-cacheable Virtual Address. */
+static int jz4750fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	struct lcd_cfb_info *cfb = (struct lcd_cfb_info *)info;
+	unsigned long start;
+	unsigned long off;
+	u32 len;
+	D("%s, %s, %d\n", __FILE__, __FUNCTION__, __LINE__);
+	off = vma->vm_pgoff << PAGE_SHIFT;
+	//fb->fb_get_fix(&fix, PROC_CONSOLE(info), info);
+
+	/* frame buffer memory */
+	start = cfb->fb.fix.smem_start;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + cfb->fb.fix.smem_len);
+	start &= PAGE_MASK;
+
+	if ((vma->vm_end - vma->vm_start + off) > len)
+		return -EINVAL;
+	off += start;
+
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+	vma->vm_flags |= VM_IO;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);	/* Uncacheable */
+
+#if 1
+ 	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
+ 	pgprot_val(vma->vm_page_prot) |= _CACHE_UNCACHED;		/* Uncacheable */
+//	pgprot_val(vma->vm_page_prot) |= _CACHE_CACHABLE_NONCOHERENT;	/* Write-Back */
+#endif
+
+	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
+			       vma->vm_end - vma->vm_start,
+			       vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+/* checks var and eventually tweaks it to something supported,
+ * DO NOT MODIFY PAR */
+static int jz4750fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	#ifdef ANTONY_FIXME
+	printk("jz4750fb_check_var, not implement\n");
+	#endif
+	return 0;
+}
+
+
+/* 
+ * set the video mode according to info->var
+ */
+static int jz4750fb_set_par(struct fb_info *info)
+{
+	#ifdef ANTONY_FIXME
+	printk("jz4750fb_set_par, not implemented\n");
+	#endif
+	return 0;
+}
+
+
+/*
+ * (Un)Blank the display.
+ * Fix me: should we use VESA value?
+ */
+static int jz4750fb_blank(int blank_mode, struct fb_info *info)
+{
+	D("jz4750 fb_blank %d %p", blank_mode, info);
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		//case FB_BLANK_NORMAL:
+			/* Turn on panel */
+		__lcd_set_ena();
+		screen_on();
+
+		break;
+
+	case FB_BLANK_NORMAL:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_POWERDOWN:
+#if 0
+		/* Turn off panel */
+		__lcd_display_off();
+		__lcd_set_dis();
+#endif
+		break;
+	default:
+		break;
+
+	}
+	return 0;
+}
+
+/*
+ * pan display
+ */
+static int jz4750fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct lcd_cfb_info *cfb = (struct lcd_cfb_info *)info;
+	int dy;
+
+	if (!var || !cfb) {
+		return -EINVAL;
+	}
+
+	if (var->xoffset - cfb->fb.var.xoffset) {
+		/* No support for X panning for now! */
+		return -EINVAL;
+	}
+
+	dy = var->yoffset;
+	D("var.yoffset: %d", dy);
+	if (dy) {
+		dma0_desc0->databuf = (unsigned int)virt_to_phys((void *)lcd_frame0 + (cfb->fb.fix.line_length * dy));
+		dma_cache_wback((unsigned int)(dma0_desc0), sizeof(struct jz4750_lcd_dma_desc));
+
+	}
+	else {
+		dma0_desc0->databuf = (unsigned int)virt_to_phys((void *)lcd_frame0);
+		dma_cache_wback((unsigned int)(dma0_desc0), sizeof(struct jz4750_lcd_dma_desc));
+	}
+
+	return 0;
+}
+
+
+/* use default function cfb_fillrect, cfb_copyarea, cfb_imageblit */
+static struct fb_ops jz4750fb_ops = {
+	.owner			= THIS_MODULE,
+	.fb_setcolreg		= jz4750fb_setcolreg,
+	.fb_check_var 		= jz4750fb_check_var,
+	.fb_set_par 		= jz4750fb_set_par,
+	.fb_blank		= jz4750fb_blank,
+	.fb_pan_display		= jz4750fb_pan_display,
+	.fb_fillrect		= cfb_fillrect,
+	.fb_copyarea		= cfb_copyarea,
+	.fb_imageblit		= cfb_imageblit,
+	.fb_mmap		= jz4750fb_mmap,
+	.fb_ioctl		= jz4750fb_ioctl,
+};
+
+static int jz4750fb_set_var(struct fb_var_screeninfo *var, int con,
+			struct fb_info *info)
+{
+	struct lcd_cfb_info *cfb = (struct lcd_cfb_info *)info;
+	struct jz4750lcd_info *lcd_info = jz4750_lcd_info;
+	int chgvar = 0;
+
+	var->height	            = lcd_info->osd.fg0.h;	/* tve mode */
+	var->width	            = lcd_info->osd.fg0.w;
+	var->bits_per_pixel	    = lcd_info->osd.fg0.bpp;
+
+	var->vmode                  = FB_VMODE_NONINTERLACED;
+	var->activate               = cfb->fb.var.activate;
+	var->xres                   = var->width;
+	var->yres                   = var->height;
+	var->xres_virtual           = var->width;
+	var->yres_virtual           = var->height;
+	var->xoffset                = 0;
+	var->yoffset                = 0;
+	var->pixclock               = 0;
+	var->left_margin            = 0;
+	var->right_margin           = 0;
+	var->upper_margin           = 0;
+	var->lower_margin           = 0;
+	var->hsync_len              = 0;
+	var->vsync_len              = 0;
+	var->sync                   = 0;
+	var->activate              &= ~FB_ACTIVATE_TEST;
+
+	/*
+	 * CONUPDATE and SMOOTH_XPAN are equal.  However,
+	 * SMOOTH_XPAN is only used internally by fbcon.
+	 */
+	if (var->vmode & FB_VMODE_CONUPDATE) {
+		var->vmode |= FB_VMODE_YWRAP;
+		var->xoffset = cfb->fb.var.xoffset;
+		var->yoffset = cfb->fb.var.yoffset;
+	}
+
+	if (var->activate & FB_ACTIVATE_TEST)
+		return 0;
+
+	if ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NOW)
+		return -EINVAL;
+
+	if (cfb->fb.var.xres != var->xres)
+		chgvar = 1;
+	if (cfb->fb.var.yres != var->yres)
+		chgvar = 1;
+	if (cfb->fb.var.xres_virtual != var->xres_virtual)
+		chgvar = 1;
+	if (cfb->fb.var.yres_virtual != var->yres_virtual)
+		chgvar = 1;
+	if (cfb->fb.var.bits_per_pixel != var->bits_per_pixel)
+		chgvar = 1;
+
+	//display = fb_display + con;
+
+	var->red.msb_right	= 0;
+	var->green.msb_right	= 0;
+	var->blue.msb_right	= 0;
+
+	switch(var->bits_per_pixel){
+	case 1:	/* Mono */
+		cfb->fb.fix.visual	= FB_VISUAL_MONO01;
+		cfb->fb.fix.line_length	= (var->xres * var->bits_per_pixel) / 8;
+		break;
+	case 2:	/* Mono */
+		var->red.offset		= 0;
+		var->red.length		= 2;
+		var->green.offset	= 0;
+		var->green.length	= 2;
+		var->blue.offset	= 0;
+		var->blue.length	= 2;
+
+		cfb->fb.fix.visual	= FB_VISUAL_PSEUDOCOLOR;
+		cfb->fb.fix.line_length	= (var->xres * var->bits_per_pixel) / 8;
+		break;
+	case 4:	/* PSEUDOCOLOUR*/
+		var->red.offset		= 0;
+		var->red.length		= 4;
+		var->green.offset	= 0;
+		var->green.length	= 4;
+		var->blue.offset	= 0;
+		var->blue.length	= 4;
+
+		cfb->fb.fix.visual	= FB_VISUAL_PSEUDOCOLOR;
+		cfb->fb.fix.line_length	= var->xres / 2;
+		break;
+	case 8:	/* PSEUDOCOLOUR, 256 */
+		var->red.offset		= 0;
+		var->red.length		= 8;
+		var->green.offset	= 0;
+		var->green.length	= 8;
+		var->blue.offset	= 0;
+		var->blue.length	= 8;
+
+		cfb->fb.fix.visual	= FB_VISUAL_PSEUDOCOLOR;
+		cfb->fb.fix.line_length	= var->xres ;
+		break;
+	case 15: /* DIRECTCOLOUR, 32k */
+		var->bits_per_pixel	= 15;
+		var->red.offset		= 10;
+		var->red.length		= 5;
+		var->green.offset	= 5;
+		var->green.length	= 5;
+		var->blue.offset	= 0;
+		var->blue.length	= 5;
+
+		cfb->fb.fix.visual	= FB_VISUAL_DIRECTCOLOR;
+		cfb->fb.fix.line_length	= var->xres_virtual * 2;
+		break;
+	case 16: /* DIRECTCOLOUR, 64k */
+		var->bits_per_pixel	= 16;
+		var->red.offset		= 11;
+		var->red.length		= 5;
+		var->green.offset	= 5;
+		var->green.length	= 6;
+		var->blue.offset	= 0;
+		var->blue.length	= 5;
+
+		cfb->fb.fix.visual	= FB_VISUAL_TRUECOLOR;
+		cfb->fb.fix.line_length	= var->xres_virtual * 2;
+		break;
+	case 17 ... 32:
+		/* DIRECTCOLOUR, 256 */
+		var->bits_per_pixel	= 32;
+
+		var->red.offset		= 16;
+		var->red.length		= 8;
+		var->green.offset	= 8;
+		var->green.length	= 8;
+		var->blue.offset	= 0;
+		var->blue.length	= 8;
+		var->transp.offset  	= 24;
+		var->transp.length 	= 8;
+
+		cfb->fb.fix.visual	= FB_VISUAL_TRUECOLOR;
+		cfb->fb.fix.line_length	= var->xres_virtual * 4;
+		break;
+
+	default: /* in theory this should never happen */
+		printk(KERN_WARNING "%s: don't support for %dbpp\n",
+		       cfb->fb.fix.id, var->bits_per_pixel);
+		break;
+	}
+
+	cfb->fb.var = *var;
+	cfb->fb.var.activate &= ~FB_ACTIVATE_ALL;
+
+	/*
+	 * Update the old var.  The fbcon drivers still use this.
+	 * Once they are using cfb->fb.var, this can be dropped.
+	 *					--rmk
+	 */
+	//display->var = cfb->fb.var;
+	/*
+	 * If we are setting all the virtual consoles, also set the
+	 * defaults used to create new consoles.
+	 */
+	fb_set_cmap(&cfb->fb.cmap, &cfb->fb);
+
+	return 0;
+}
+
+static struct lcd_cfb_info * jz4750fb_alloc_fb_info(void)
+{
+	struct lcd_cfb_info *cfb;
+
+	cfb = kmalloc(sizeof(struct lcd_cfb_info) + sizeof(u32) * 16, GFP_KERNEL);
+
+	if (!cfb)
+		return NULL;
+
+	jz4750fb_info = cfb;
+
+	memset(cfb, 0, sizeof(struct lcd_cfb_info) );
+
+	cfb->backlight_level		= LCD_DEFAULT_BACKLIGHT;
+
+	strcpy(cfb->fb.fix.id, "jz-lcd");
+	cfb->fb.fix.type	= FB_TYPE_PACKED_PIXELS;
+	cfb->fb.fix.type_aux	= 0;
+	cfb->fb.fix.xpanstep	= 1;
+	cfb->fb.fix.ypanstep	= 1;
+	cfb->fb.fix.ywrapstep	= 0;
+	cfb->fb.fix.accel	= FB_ACCEL_NONE;
+
+	cfb->fb.var.nonstd	= 0;
+	cfb->fb.var.activate	= FB_ACTIVATE_NOW;
+	cfb->fb.var.height	= -1;
+	cfb->fb.var.width	= -1;
+	cfb->fb.var.accel_flags	= FB_ACCELF_TEXT;
+
+	cfb->fb.fbops		= &jz4750fb_ops;
+	cfb->fb.flags		= FBINFO_FLAG_DEFAULT;
+
+	cfb->fb.pseudo_palette	= (void *)(cfb + 1);
+
+	switch (jz4750_lcd_info->osd.fg0.bpp) {
+	case 1:
+		fb_alloc_cmap(&cfb->fb.cmap, 4, 0);
+		break;
+	case 2:
+		fb_alloc_cmap(&cfb->fb.cmap, 8, 0);
+		break;
+	case 4:
+		fb_alloc_cmap(&cfb->fb.cmap, 32, 0);
+		break;
+	case 8:
+
+	default:
+		fb_alloc_cmap(&cfb->fb.cmap, 256, 0);
+		break;
+	}
+	D("fb_alloc_cmap,fb.cmap.len:%d....\n", cfb->fb.cmap.len);
+
+	return cfb;
+}
+
+static int bpp_to_data_bpp(int bpp)
+{
+	switch (bpp) {
+		case 32:
+		case 16:
+			break;
+
+		case 15:
+			bpp = 16;
+			break;
+
+		default:
+			bpp = -EINVAL;
+	}
+
+	return bpp;
+}
+
+/*
+ * Map screen memory
+ */
+static int jz4750fb_map_smem(struct lcd_cfb_info *cfb)
+{
+	unsigned long page;
+	unsigned int page_shift, needroom, needroom1, bpp, w, h;
+
+	bpp = bpp_to_data_bpp(jz4750_lcd_info->osd.fg0.bpp);
+
+	D("FG0 BPP: %d, Data BPP: %d.", jz4750_lcd_info->osd.fg0.bpp, bpp);
+
+#ifndef CONFIG_FB_JZ4750_TVE
+	w = jz4750_lcd_info->osd.fg0.w;
+	h = jz4750_lcd_info->osd.fg0.h;
+#else
+	w = ( jz4750_lcd_info->osd.fg0.w > TVE_WIDTH_PAL )?jz4750_lcd_info->osd.fg0.w:TVE_WIDTH_PAL;
+	h = ( jz4750_lcd_info->osd.fg0.h > TVE_HEIGHT_PAL )?jz4750_lcd_info->osd.fg0.h:TVE_HEIGHT_PAL;
+#endif
+	needroom1 = needroom = ((w * bpp + 7) >> 3) * h;
+
+#if defined(CONFIG_FB_JZ4750_LCD_USE_2LAYER_FRAMEBUFFER)
+	bpp = bpp_to_data_bpp(jz4750_lcd_info->osd.fg1.bpp);
+
+	D("FG1 BPP: %d, Data BPP: %d.", jz4750_lcd_info->osd.fg1.bpp, bpp);
+
+#ifndef CONFIG_FB_JZ4750_TVE
+	w = jz4750_lcd_info->osd.fg1.w;
+	h = jz4750_lcd_info->osd.fg1.h;
+#else
+	w = ( jz4750_lcd_info->osd.fg1.w > TVE_WIDTH_PAL )?jz4750_lcd_info->osd.fg1.w:TVE_WIDTH_PAL;
+	h = ( jz4750_lcd_info->osd.fg1.h > TVE_HEIGHT_PAL )?jz4750_lcd_info->osd.fg1.h:TVE_HEIGHT_PAL;
+#endif
+	needroom += ((w * bpp + 7) >> 3) * h;
+#endif // two layer
+
+	for (page_shift = 0; page_shift < 12; page_shift++)
+		if ((PAGE_SIZE << page_shift) >= needroom)
+			break;
+	lcd_palette = (unsigned char *)__get_free_pages(GFP_KERNEL, 0);
+	lcd_frame0 = (unsigned char *)__get_free_pages(GFP_KERNEL, page_shift);
+#if JZ_FB_DEBUG
+	lcd_frame_test = (unsigned char * )__get_free_pages(GFP_KERNEL,page_shift);
+	lcd_frame_test1 = (unsigned char * )__get_free_pages(GFP_KERNEL,page_shift);
+	lcd_frame_size = PAGE_SIZE<<page_shift;
+#endif
+
+	if ((!lcd_palette) || (!lcd_frame0))
+		return -ENOMEM;
+	memset((void *)lcd_palette, 0, PAGE_SIZE);
+	memset((void *)lcd_frame0, 0, PAGE_SIZE << page_shift);
+#if JZ_FB_DEBUG
+	memset((void *)lcd_frame_test,0,PAGE_SIZE<<page_shift);
+	memset((void *)lcd_frame_test1,0,PAGE_SIZE<<page_shift);
+#endif
+
+	dma_desc_base = (struct jz4750_lcd_dma_desc *)((void*)lcd_palette + ((PALETTE_SIZE+3)/4)*4);
+
+#if defined(CONFIG_FB_JZ4750_SLCD)
+	lcd_cmdbuf = (unsigned char *)__get_free_pages(GFP_KERNEL, 0);
+	memset((void *)lcd_cmdbuf, 0, PAGE_SIZE);
+
+	{	int data, i, *ptr;
+		ptr = (unsigned int *)lcd_cmdbuf;
+		data = WR_GRAM_CMD;
+		data = ((data & 0xff) << 1) | ((data & 0xff00) << 2);
+		for(i = 0; i < 3; i++){
+			ptr[i] = data;
+		}
+	}
+#endif
+
+#if defined(CONFIG_FB_JZ4750_LCD_USE_2LAYER_FRAMEBUFFER)
+	lcd_frame1 = lcd_frame0 + needroom1;
+#endif
+
+	/*
+	 * Set page reserved so that mmap will work. This is necessary
+	 * since we'll be remapping normal memory.
+	 */
+	page = (unsigned long)lcd_palette;
+	SetPageReserved(virt_to_page((void*)page));
+
+	for (page = (unsigned long)lcd_frame0;
+	     page < PAGE_ALIGN((unsigned long)lcd_frame0 + (PAGE_SIZE<<page_shift));
+	     page += PAGE_SIZE) {
+		SetPageReserved(virt_to_page((void*)page));
+	}
+
+	cfb->fb.fix.smem_start = virt_to_phys((void *)lcd_frame0);
+	cfb->fb.fix.smem_len = (PAGE_SIZE << page_shift); /* page_shift/2 ??? */
+	cfb->fb.screen_base =
+		(unsigned char *)(((unsigned int)lcd_frame0&0x1fffffff) | 0xa0000000);
+
+	if (!cfb->fb.screen_base) {
+		printk("jz4750fb, %s: unable to map screen memory\n", cfb->fb.fix.id);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void jz4750fb_free_fb_info(struct lcd_cfb_info *cfb)
+{
+	if (cfb) {
+		fb_alloc_cmap(&cfb->fb.cmap, 0, 0);
+		kfree(cfb);
+	}
+}
+
+static void jz4750fb_unmap_smem(struct lcd_cfb_info *cfb)
+{
+	struct page * map = NULL;
+	unsigned char *tmp;
+	unsigned int page_shift, needroom, bpp, w, h;
+
+	bpp = jz4750_lcd_info->osd.fg0.bpp;
+	if ( bpp == 18 || bpp == 24)
+		bpp = 32;
+	if ( bpp == 15 )
+		bpp = 16;
+	w = jz4750_lcd_info->osd.fg0.w;
+	h = jz4750_lcd_info->osd.fg0.h;
+	needroom = ((w * bpp + 7) >> 3) * h;
+#if defined(CONFIG_FB_JZ4750_LCD_USE_2LAYER_FRAMEBUFFER)
+	bpp = jz4750_lcd_info->osd.fg1.bpp;
+	if ( bpp == 18 || bpp == 24)
+		bpp = 32;
+	if ( bpp == 15 )
+		bpp = 16;
+	w = jz4750_lcd_info->osd.fg1.w;
+	h = jz4750_lcd_info->osd.fg1.h;
+	needroom += ((w * bpp + 7) >> 3) * h;
+#endif
+
+	for (page_shift = 0; page_shift < 12; page_shift++)
+		if ((PAGE_SIZE << page_shift) >= needroom)
+			break;
+
+	if (cfb && cfb->fb.screen_base) {
+		iounmap(cfb->fb.screen_base);
+		cfb->fb.screen_base = NULL;
+		release_mem_region(cfb->fb.fix.smem_start,
+				   cfb->fb.fix.smem_len);
+	}
+
+	if (lcd_palette) {
+		map = virt_to_page(lcd_palette);
+		clear_bit(PG_reserved, &map->flags);
+		free_pages((int)lcd_palette, 0);
+	}
+
+	if (lcd_frame0) {
+		for (tmp=(unsigned char *)lcd_frame0; 
+		     tmp < lcd_frame0 + (PAGE_SIZE << page_shift); 
+		     tmp += PAGE_SIZE) {
+			map = virt_to_page(tmp);
+			clear_bit(PG_reserved, &map->flags);
+		}
+		free_pages((int)lcd_frame0, page_shift);
+	#if JZ_FB_DEBUG
+		free_pages((int)lcd_frame_test,page_shift);
+		free_pages((int)lcd_frame_test1,page_shift);
+	#endif
+	}
+}
+
+/* initial dma descriptors */
+static void jz4750fb_descriptor_init( struct jz4750lcd_info * lcd_info )
+{
+	unsigned int pal_size;
+
+	switch ( lcd_info->osd.fg0.bpp ) {
+	case 1:
+		pal_size = 4;
+		break;
+	case 2:
+		pal_size = 8;
+		break;
+	case 4:
+		pal_size = 32;
+		break;
+	case 8:
+	default:
+		pal_size = 512;
+	}
+
+	pal_size /= 4;
+
+	dma0_desc_palette 	= dma_desc_base + 0;
+	dma0_desc0 		= dma_desc_base + 1;
+	dma0_desc1 		= dma_desc_base + 2;
+	dma0_desc_cmd0 		= dma_desc_base + 3; /* use only once */
+	dma0_desc_cmd 		= dma_desc_base + 4;
+	dma1_desc0 		= dma_desc_base + 5;
+	dma1_desc1 		= dma_desc_base + 6;
+
+	/*
+	 * Normal TFT panel's DMA Chan0:
+	 *	TO LCD Panel:
+	 * 		no palette:	dma0_desc0 <<==>> dma0_desc0
+	 * 		palette :	dma0_desc_palette <<==>> dma0_desc0
+	 *	TO TV Encoder:
+	 * 		no palette:	dma0_desc0 <<==>> dma0_desc1
+	 * 		palette:	dma0_desc_palette --> dma0_desc0
+	 * 				--> dma0_desc1 --> dma0_desc_palette --> ...
+	 *
+	 * SMART LCD TFT panel(dma0_desc_cmd)'s DMA Chan0:
+	 *	TO LCD Panel:
+	 * 		no palette:	dma0_desc_cmd <<==>> dma0_desc0
+	 * 		palette :	dma0_desc_palette --> dma0_desc_cmd
+	 * 				--> dma0_desc0 --> dma0_desc_palette --> ...
+	 *	TO TV Encoder:
+	 * 		no palette:	dma0_desc_cmd --> dma0_desc0
+	 * 				--> dma0_desc1 --> dma0_desc_cmd --> ...
+	 * 		palette:	dma0_desc_palette --> dma0_desc_cmd 
+	 * 				--> dma0_desc0 --> dma0_desc1
+	 * 				--> dma0_desc_palette --> ...
+	 * DMA Chan1:
+	 *	TO LCD Panel:
+	 * 		dma1_desc0 <<==>> dma1_desc0
+	 *	TO TV Encoder:
+	 * 		dma1_desc0 <<==>> dma1_desc1
+	 */
+
+#if defined(CONFIG_FB_JZ4750_SLCD)
+	/* First CMD descriptors, use only once, cmd_num isn't 0 */
+	dma0_desc_cmd0->next_desc 	= (unsigned int)virt_to_phys(dma0_desc0);
+	dma0_desc_cmd0->databuf 	= (unsigned int)virt_to_phys((void *)lcd_cmdbuf);
+	dma0_desc_cmd0->frame_id 	= (unsigned int)0x0da0cad0; /* dma0's cmd0 */
+	dma0_desc_cmd0->cmd 		= LCD_CMD_CMD | 3; /* command */
+	dma0_desc_cmd0->offsize 	= 0;
+	dma0_desc_cmd0->page_width 	= 0;
+	dma0_desc_cmd0->cmd_num 	= 3;
+
+	/* Dummy Command Descriptor, cmd_num is 0 */
+	dma0_desc_cmd->next_desc 	= (unsigned int)virt_to_phys(dma0_desc0);
+	dma0_desc_cmd->databuf 		= 0;
+	dma0_desc_cmd->frame_id 	= (unsigned int)0x0da000cd; /* dma0's cmd0 */
+	dma0_desc_cmd->cmd 		= LCD_CMD_CMD | 0; /* dummy command */
+	dma0_desc_cmd->cmd_num 		= 0;
+	dma0_desc_cmd->offsize 		= 0;
+	dma0_desc_cmd->page_width 	= 0;
+
+	/* Palette Descriptor */
+	dma0_desc_palette->next_desc 	= (unsigned int)virt_to_phys(dma0_desc_cmd0);
+#else
+	/* Palette Descriptor */
+	dma0_desc_palette->next_desc 	= (unsigned int)virt_to_phys(dma0_desc0);
+#endif
+	dma0_desc_palette->databuf 	= (unsigned int)virt_to_phys((void *)lcd_palette);
+	dma0_desc_palette->frame_id 	= (unsigned int)0xaaaaaaaa;
+	dma0_desc_palette->cmd 		= LCD_CMD_PAL | pal_size; /* Palette Descriptor */
+
+	/* DMA0 Descriptor0 */
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) /* TVE mode */
+		dma0_desc0->next_desc 	= (unsigned int)virt_to_phys(dma0_desc1);
+	else{			/* Normal TFT LCD */
+#if defined(CONFIG_FB_JZ4750_SLCD)
+			dma0_desc0->next_desc = (unsigned int)virt_to_phys(dma0_desc_cmd);
+#else
+			dma0_desc0->next_desc = (unsigned int)virt_to_phys(dma0_desc0);
+#endif
+	}
+
+	dma0_desc0->databuf = virt_to_phys((void *)lcd_frame0);
+	dma0_desc0->frame_id = (unsigned int)0x0000da00; /* DMA0'0 */
+
+	/* DMA0 Descriptor1 */
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) { /* TVE mode */
+
+
+		if (lcd_info->osd.fg0.bpp <= 8) /* load palette only once at setup */
+			dma0_desc1->next_desc = (unsigned int)virt_to_phys(dma0_desc_palette);
+		else
+#if defined(CONFIG_FB_JZ4750_SLCD)  /* for smatlcd */
+			dma0_desc1->next_desc = (unsigned int)virt_to_phys(dma0_desc_cmd);
+#else
+			dma0_desc1->next_desc = (unsigned int)virt_to_phys(dma0_desc0);
+#endif
+		dma0_desc1->frame_id = (unsigned int)0x0000da01; /* DMA0'1 */
+	}
+
+	if (lcd_info->osd.fg0.bpp <= 8) /* load palette only once at setup */
+		REG_LCD_DA0 = virt_to_phys(dma0_desc_palette);
+	else {
+#if defined(CONFIG_FB_JZ4750_SLCD)  /* for smartlcd */
+		REG_LCD_DA0 = virt_to_phys(dma0_desc_cmd0); //smart lcd
+#else
+		REG_LCD_DA0 = virt_to_phys(dma0_desc0); //tft
+#endif
+	}
+
+	/* DMA1 Descriptor0 */
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) /* TVE mode */
+		dma1_desc0->next_desc = (unsigned int)virt_to_phys(dma1_desc1);
+	else			/* Normal TFT LCD */
+		dma1_desc0->next_desc = (unsigned int)virt_to_phys(dma1_desc0);
+
+	dma1_desc0->databuf = virt_to_phys((void *)lcd_frame1);
+	dma1_desc0->frame_id = (unsigned int)0x0000da10; /* DMA1'0 */
+
+	/* DMA1 Descriptor1 */
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) { /* TVE mode */
+		dma1_desc1->next_desc = (unsigned int)virt_to_phys(dma1_desc0);
+		dma1_desc1->frame_id = (unsigned int)0x0000da11; /* DMA1'1 */
+	}
+
+	REG_LCD_DA1 = virt_to_phys(dma1_desc0);	/* set Dma-chan1's Descripter Addrress */
+	dma_cache_wback_inv((unsigned int)(dma_desc_base), (DMA_DESC_NUM)*sizeof(struct jz4750_lcd_dma_desc));
+
+#if 0
+	/* Palette Descriptor */
+	if ( lcd_info->panel.cfg & LCD_CFG_LCDPIN_SLCD )
+//		dma0_desc_palette->next_desc = (unsigned int)virt_to_phys(dma0_desc_cmd);
+		dma0_desc_palette->next_desc = (unsigned int)virt_to_phys(dma0_desc_cmd1);
+	else
+		dma0_desc_palette->next_desc = (unsigned int)virt_to_phys(dma0_desc0);
+	dma0_desc_palette->databuf = (unsigned int)virt_to_phys((void *)lcd_palette);
+	dma0_desc_palette->frame_id = (unsigned int)0xaaaaaaaa;
+	dma0_desc_palette->cmd 	= LCD_CMD_PAL | pal_size; /* Palette Descriptor */
+
+	/* Dummy Command Descriptor, cmd_num is 0 */
+	dma0_desc_cmd->next_desc = (unsigned int)virt_to_phys(dma0_desc0);
+	dma0_desc_cmd->databuf 	= (unsigned int)virt_to_phys((void *)lcd_cmdbuf);
+	dma0_desc_cmd->frame_id = (unsigned int)0x0da0cad0; /* dma0's cmd0 */
+	dma0_desc_cmd->cmd 	= LCD_CMD_CMD | 3; /* dummy command */
+	dma0_desc_cmd->offsize 	= 0; /* dummy command */
+	dma0_desc_cmd->page_width = 0; /* dummy command */
+	dma0_desc_cmd->cmd_num 	= 3;
+
+//---------------------------------
+	dma0_desc_cmd1->next_desc = (unsigned int)virt_to_phys(dma0_desc0);
+	dma0_desc_cmd1->databuf 	= 0; 
+	dma0_desc_cmd1->frame_id = (unsigned int)0x0da0cad1; /* dma0's cmd0 */
+	dma0_desc_cmd1->cmd 	= LCD_CMD_CMD | 0; /* dummy command */
+	dma0_desc_cmd1->cmd_num 	= 0;
+	dma0_desc_cmd1->offsize 	= 0; /* dummy command */
+	dma0_desc_cmd1->page_width = 0; /* dummy command */
+//-----------------------------------
+	/* DMA0 Descriptor0 */
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) /* TVE mode */
+		dma0_desc0->next_desc = (unsigned int)virt_to_phys(dma0_desc1);
+	else{			/* Normal TFT LCD */
+		if (lcd_info->osd.fg0.bpp <= 8) /* load palette only once at setup?? */
+//			dma0_desc0->next_desc = (unsigned int)virt_to_phys(dma0_desc_palette); //tft
+			dma0_desc0->next_desc = (unsigned int)virt_to_phys(dma0_desc_cmd); // smart lcd
+		else if ( lcd_info->panel.cfg & LCD_CFG_LCDPIN_SLCD ) 
+			dma0_desc0->next_desc = (unsigned int)virt_to_phys(dma0_desc_cmd1);
+//			dma0_desc0->next_desc = (unsigned int)virt_to_phys(dma0_desc_cmd);
+		else 
+			dma0_desc0->next_desc = (unsigned int)virt_to_phys(dma0_desc0);
+	}
+
+	dma0_desc0->databuf = virt_to_phys((void *)lcd_frame0);
+	dma0_desc0->frame_id = (unsigned int)0x0000da00; /* DMA0'0 */
+
+	/* DMA0 Descriptor1 */
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) { /* TVE mode */
+		if (lcd_info->osd.fg0.bpp <= 8) /* load palette only once at setup?? */
+			dma0_desc1->next_desc = (unsigned int)virt_to_phys(dma0_desc_palette);
+		
+		else if ( lcd_info->panel.cfg & LCD_CFG_LCDPIN_SLCD ) 
+			dma0_desc1->next_desc = (unsigned int)virt_to_phys(dma0_desc_cmd);
+		else 
+			dma0_desc1->next_desc = (unsigned int)virt_to_phys(dma0_desc0);
+		dma0_desc1->frame_id = (unsigned int)0x0000da01; /* DMA0'1 */
+	}
+
+	/* DMA1 Descriptor0 */
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) /* TVE mode */
+		dma1_desc0->next_desc = (unsigned int)virt_to_phys(dma1_desc1);
+	else			/* Normal TFT LCD */
+		dma1_desc0->next_desc = (unsigned int)virt_to_phys(dma1_desc0);
+
+	dma1_desc0->databuf = virt_to_phys((void *)lcd_frame1);
+	dma1_desc0->frame_id = (unsigned int)0x0000da10; /* DMA1'0 */
+
+	/* DMA1 Descriptor1 */
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) { /* TVE mode */
+		dma1_desc1->next_desc = (unsigned int)virt_to_phys(dma1_desc0);
+		dma1_desc1->frame_id = (unsigned int)0x0000da11; /* DMA1'1 */
+	}
+
+	if (lcd_info->osd.fg0.bpp <= 8) /* load palette only once at setup?? */
+		REG_LCD_DA0 = virt_to_phys(dma0_desc_palette);
+	else
+//		REG_LCD_DA0 = virt_to_phys(dma0_desc_cmd); //smart lcd
+		REG_LCD_DA0 = virt_to_phys(dma0_desc0); //tft
+	REG_LCD_DA1 = virt_to_phys(dma1_desc0);	/* set Dma-chan1's Descripter Addrress */
+	dma_cache_wback_inv((unsigned int)(dma_desc_base), (DMA_DESC_NUM)*sizeof(struct jz4750_lcd_dma_desc));
+#endif
+}
+
+static void jz4750fb_set_panel_mode( struct jz4750lcd_info * lcd_info )
+{
+	struct jz4750lcd_panel_t *panel = &lcd_info->panel;
+
+	/* set bpp */
+	lcd_info->panel.ctrl &= ~LCD_CTRL_BPP_MASK;
+	if ( lcd_info->osd.fg0.bpp == 1 )
+		lcd_info->panel.ctrl |= LCD_CTRL_BPP_1;
+	else if ( lcd_info->osd.fg0.bpp == 2 )
+		lcd_info->panel.ctrl |= LCD_CTRL_BPP_2;
+	else if ( lcd_info->osd.fg0.bpp == 4 )
+		lcd_info->panel.ctrl |= LCD_CTRL_BPP_4;
+	else if ( lcd_info->osd.fg0.bpp == 8 )
+		lcd_info->panel.ctrl |= LCD_CTRL_BPP_8;
+	else if ( lcd_info->osd.fg0.bpp == 15 )
+		lcd_info->panel.ctrl |= LCD_CTRL_BPP_16 | LCD_CTRL_RGB555;
+	else if ( lcd_info->osd.fg0.bpp == 16 )
+		lcd_info->panel.ctrl |= LCD_CTRL_BPP_16 | LCD_CTRL_RGB565;
+	else if ( lcd_info->osd.fg0.bpp > 16 && lcd_info->osd.fg0.bpp < 32+1 ) {
+		lcd_info->osd.fg0.bpp = 32;
+		lcd_info->panel.ctrl |= LCD_CTRL_BPP_18_24;
+	}
+	else {
+		printk("The BPP %d is not supported\n", lcd_info->osd.fg0.bpp);
+		lcd_info->osd.fg0.bpp = 32;
+		lcd_info->panel.ctrl |= LCD_CTRL_BPP_18_24;
+	}
+
+	lcd_info->panel.cfg |= LCD_CFG_NEWDES; /* use 8words descriptor always */
+
+	REG_LCD_CTRL = lcd_info->panel.ctrl; /* LCDC Controll Register */
+	REG_LCD_CFG = lcd_info->panel.cfg; /* LCDC Configure Register */
+	REG_SLCD_CFG = lcd_info->panel.slcd_cfg; /* Smart LCD Configure Register */
+
+	if ( lcd_info->panel.cfg & LCD_CFG_LCDPIN_SLCD ) /* enable Smart LCD DMA */
+		REG_SLCD_CTRL = SLCD_CTRL_DMA_EN;
+
+	switch ( lcd_info->panel.cfg & LCD_CFG_MODE_MASK ) {
+	case LCD_CFG_MODE_GENERIC_TFT:
+	case LCD_CFG_MODE_INTER_CCIR656:
+	case LCD_CFG_MODE_NONINTER_CCIR656:
+	case LCD_CFG_MODE_SLCD:
+	default:		/* only support TFT16 TFT32, not support STN and Special TFT by now(10-06-2008)*/
+		REG_LCD_VAT = (((panel->blw + panel->w + panel->elw + panel->hsw)) << 16) | (panel->vsw + panel->bfw + panel->h + panel->efw);
+		REG_LCD_DAH = ((panel->hsw + panel->blw) << 16) | (panel->hsw + panel->blw + panel->w);
+		REG_LCD_DAV = ((panel->vsw + panel->bfw) << 16) | (panel->vsw + panel->bfw + panel->h);
+		REG_LCD_HSYNC = (0 << 16) | panel->hsw;
+		REG_LCD_VSYNC = (0 << 16) | panel->vsw;
+		break;
+	}
+}
+
+static void jz4750fb_set_osd_mode( struct jz4750lcd_info * lcd_info )
+{
+	D("%s, %d\n", __FILE__, __LINE__ );
+	lcd_info->osd.osd_ctrl &= ~(LCD_OSDCTRL_OSDBPP_MASK);
+	if ( lcd_info->osd.fg1.bpp == 15 )
+		lcd_info->osd.osd_ctrl |= LCD_OSDCTRL_OSDBPP_15_16|LCD_OSDCTRL_RGB555;
+	else if ( lcd_info->osd.fg1.bpp == 16 )
+		lcd_info->osd.osd_ctrl |= LCD_OSDCTRL_OSDBPP_15_16|LCD_OSDCTRL_RGB565;
+	else {
+		lcd_info->osd.fg1.bpp = 32;
+		lcd_info->osd.osd_ctrl |= LCD_OSDCTRL_OSDBPP_18_24;
+	}
+
+	REG_LCD_OSDC 	= lcd_info->osd.osd_cfg; /* F0, F1, alpha, */
+
+	REG_LCD_OSDCTRL = lcd_info->osd.osd_ctrl; /* IPUEN, bpp */
+	REG_LCD_RGBC  	= lcd_info->osd.rgb_ctrl;
+	REG_LCD_BGC  	= lcd_info->osd.bgcolor;
+	REG_LCD_KEY0 	= lcd_info->osd.colorkey0;
+	REG_LCD_KEY1 	= lcd_info->osd.colorkey1;
+	REG_LCD_ALPHA 	= lcd_info->osd.alpha;
+	REG_LCD_IPUR 	= lcd_info->osd.ipu_restart;
+}
+
+static void jz4750fb_foreground_resize( struct jz4750lcd_info * lcd_info )
+{
+	int fg0_line_size, fg0_frm_size, fg1_line_size, fg1_frm_size;
+	/*
+	 * NOTE:
+	 * Foreground change sequence:
+	 * 	1. Change Position Registers -> LCD_OSDCTL.Change;
+	 * 	2. LCD_OSDCTRL.Change -> descripter->Size
+	 * Foreground, only one of the following can be change at one time:
+	 * 	1. F0 size;
+	 *	2. F0 position
+	 * 	3. F1 size
+	 *	4. F1 position
+	 */
+
+	/*
+	 * The rules of f0, f1's position:
+	 * 	f0.x + f0.w <= panel.w;
+	 * 	f0.y + f0.h <= panel.h;
+	 *
+	 * When output is LCD panel, fg.y and fg.h can be odd number or even number.
+	 * When output is TVE, as the TVE has odd frame and even frame,
+	 * to simplified operation, fg.y and fg.h should be even number always.
+	 *
+	 */
+
+	/* Foreground 0  */
+	if ( lcd_info->osd.fg0.x >= lcd_info->panel.w )
+		lcd_info->osd.fg0.x = lcd_info->panel.w;
+	if ( lcd_info->osd.fg0.y >= lcd_info->panel.h )
+		lcd_info->osd.fg0.y = lcd_info->panel.h;
+	if ( lcd_info->osd.fg0.x + lcd_info->osd.fg0.w > lcd_info->panel.w )
+		lcd_info->osd.fg0.w = lcd_info->panel.w - lcd_info->osd.fg0.x;
+	if ( lcd_info->osd.fg0.y + lcd_info->osd.fg0.h > lcd_info->panel.h )
+		lcd_info->osd.fg0.h = lcd_info->panel.h - lcd_info->osd.fg0.y;
+
+#if 0
+	/* Foreground 1 */
+	/* Case TVE ??? TVE 720x573 or 720x480*/
+	if ( lcd_info->osd.fg1.x >= lcd_info->panel.w )
+		lcd_info->osd.fg1.x = lcd_info->panel.w;
+	if ( lcd_info->osd.fg1.y >= lcd_info->panel.h )
+		lcd_info->osd.fg1.y = lcd_info->panel.h;
+	if ( lcd_info->osd.fg1.x + lcd_info->osd.fg1.w > lcd_info->panel.w )
+		lcd_info->osd.fg1.w = lcd_info->panel.w - lcd_info->osd.fg1.x;
+	if ( lcd_info->osd.fg1.y + lcd_info->osd.fg1.h > lcd_info->panel.h )
+		lcd_info->osd.fg1.h = lcd_info->panel.h - lcd_info->osd.fg1.y;
+#endif
+//	fg0_line_size = lcd_info->osd.fg0.w*((lcd_info->osd.fg0.bpp+7)/8);
+	fg0_line_size = (lcd_info->osd.fg0.w*(lcd_info->osd.fg0.bpp)/8);
+	fg0_line_size = ((fg0_line_size+3)>>2)<<2; /* word aligned */
+	fg0_frm_size = fg0_line_size * lcd_info->osd.fg0.h;
+
+	fg1_line_size = lcd_info->osd.fg1.w*((lcd_info->osd.fg1.bpp+7)/8);
+	fg1_line_size = ((fg1_line_size+3)>>2)<<2; /* word aligned */
+	fg1_frm_size = fg1_line_size * lcd_info->osd.fg1.h;
+
+	if ( lcd_info->osd.fg_change ) {
+		if ( lcd_info->osd.fg_change & FG0_CHANGE_POSITION ) { /* F1 change position */
+			REG_LCD_XYP0 = lcd_info->osd.fg0.y << 16 | lcd_info->osd.fg0.x;
+		}
+		if ( lcd_info->osd.fg_change & FG1_CHANGE_POSITION ) { /* F1 change position */
+			REG_LCD_XYP1 = lcd_info->osd.fg1.y << 16 | lcd_info->osd.fg1.x;
+		}
+
+		/* set change */
+		if ( !(lcd_info->osd.osd_ctrl & LCD_OSDCTRL_IPU) && 
+		     (lcd_info->osd.fg_change != FG_CHANGE_ALL) )
+			REG_LCD_OSDCTRL |= LCD_OSDCTRL_CHANGES;
+
+		/* wait change ready??? */
+//		while ( REG_LCD_OSDS & LCD_OSDS_READY )	/* fix in the future, Wolfgang, 06-20-2008 */
+		D("wait LCD_OSDS_READY\n");
+
+		if ( lcd_info->osd.fg_change & FG0_CHANGE_SIZE ) { /* change FG0 size */
+			if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) { /* output to TV */
+				dma0_desc0->cmd = dma0_desc1->cmd = (fg0_frm_size/4)/2;
+				dma0_desc0->offsize = dma0_desc1->offsize
+					= fg0_line_size/4;
+				dma0_desc0->page_width = dma0_desc1->page_width
+					= fg0_line_size/4;
+				dma0_desc1->databuf = virt_to_phys((void *)(lcd_frame0 + fg0_line_size));
+				REG_LCD_DA0 = virt_to_phys(dma0_desc0); //tft
+			}
+			else {
+				dma0_desc0->cmd = dma0_desc1->cmd = fg0_frm_size/4;
+				dma0_desc0->offsize = dma0_desc1->offsize =0;
+				dma0_desc0->page_width = dma0_desc1->page_width = 0;
+			}
+
+			dma0_desc0->desc_size = dma0_desc1->desc_size 
+				= lcd_info->osd.fg0.h << 16 | lcd_info->osd.fg0.w;
+			REG_LCD_SIZE0 = (lcd_info->osd.fg0.h<<16)|lcd_info->osd.fg0.w;
+
+		}
+
+		if ( lcd_info->osd.fg_change & FG1_CHANGE_SIZE ) { /* change FG1 size*/
+			if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) { /* output to TV */
+				dma1_desc0->cmd = dma1_desc1->cmd = (fg1_frm_size/4)/2;
+				dma1_desc0->offsize = dma1_desc1->offsize = fg1_line_size/4;
+				dma1_desc0->page_width = dma1_desc1->page_width = fg1_line_size/4;
+				dma1_desc1->databuf = virt_to_phys((void *)(lcd_frame1 + fg1_line_size));
+				REG_LCD_DA1 = virt_to_phys(dma0_desc1); //tft
+
+			}
+			else {
+				dma1_desc0->cmd = dma1_desc1->cmd = fg1_frm_size/4;
+				dma1_desc0->offsize = dma1_desc1->offsize = 0;
+				dma1_desc0->page_width = dma1_desc1->page_width = 0;
+			}
+
+			dma1_desc0->desc_size = dma1_desc1->desc_size 
+				= lcd_info->osd.fg1.h << 16 | lcd_info->osd.fg1.w;
+			REG_LCD_SIZE1 = lcd_info->osd.fg1.h << 16|lcd_info->osd.fg1.w;
+		}
+
+		dma_cache_wback((unsigned int)(dma_desc_base), (DMA_DESC_NUM)*sizeof(struct jz4750_lcd_dma_desc));
+		lcd_info->osd.fg_change = FG_NOCHANGE; /* clear change flag */
+	}
+}
+
+static void jz4750fb_change_clock( struct jz4750lcd_info * lcd_info )
+{
+	unsigned int val = 0;
+	unsigned int pclk;
+	/* Timing setting */
+	__cpm_stop_lcd();
+
+	val = lcd_info->panel.fclk; /* frame clk */
+
+	if ( (lcd_info->panel.cfg & LCD_CFG_MODE_MASK) != LCD_CFG_MODE_SERIAL_TFT) {
+		pclk = val * (lcd_info->panel.w + lcd_info->panel.hsw + lcd_info->panel.elw + lcd_info->panel.blw) * (lcd_info->panel.h + lcd_info->panel.vsw + lcd_info->panel.efw + lcd_info->panel.bfw); /* Pixclk */
+	}
+	else {
+		/* serial mode: Hsync period = 3*Width_Pixel */
+		pclk = val * (lcd_info->panel.w*3 + lcd_info->panel.hsw + lcd_info->panel.elw + lcd_info->panel.blw) * (lcd_info->panel.h + lcd_info->panel.vsw + lcd_info->panel.efw + lcd_info->panel.bfw); /* Pixclk */
+	}
+
+	/********* In TVE mode PCLK = 27MHz ***********/
+	if ( lcd_info->panel.cfg & LCD_CFG_TVEN ) { 		/* LCDC output to TVE */
+		REG_CPM_LPCDR  |= CPM_LPCDR_LTCS;
+		pclk = 27000000;
+		val = __cpm_get_pllout2() / pclk; /* pclk */
+		val--;
+		__cpm_set_pixdiv(val);
+
+		D("REG_CPM_LPCDR = 0x%08x\n", REG_CPM_LPCDR);
+		__cpm_select_pixclk_tve();
+
+		REG_CPM_CPCCR |= CPM_CPCCR_CE ; /* update divide */
+	}
+	else {	/* LCDC output to  LCD panel */
+		val = __cpm_get_pllout2() / pclk; /* pclk */
+		val--;
+		D("ratio: val = %d\n", val);
+		if ( val > 0x7ff ) {
+			printk("pixel clock divid is too large, set it to 0x7ff\n");
+			val = 0x7ff;
+		}
+
+		__cpm_set_pixdiv(val);
+
+		D("REG_CPM_LPCDR = 0x%08x\n", REG_CPM_LPCDR);
+		REG_CPM_CPCCR |= CPM_CPCCR_CE ; /* update divide */
+
+	}
+
+	D("REG_CPM_LPCDR=0x%08x\n", REG_CPM_LPCDR);
+	D("REG_CPM_CPCCR=0x%08x\n", REG_CPM_CPCCR);
+
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	printk("LCDC: PixClock:%d\n", jz_clocks.pixclk);
+
+	__cpm_start_lcd();
+	udelay(1000);
+	/*
+	 * set lcd device clock and lcd pixel clock.
+	 * what about TVE mode???
+	 *
+	 */
+}
+
+/*
+ * jz4750fb_set_mode(), set osd configure, resize foreground
+ *
+ */
+static void jz4750fb_set_mode( struct jz4750lcd_info * lcd_info )
+{
+	struct lcd_cfb_info *cfb = jz4750fb_info;
+
+	jz4750fb_set_osd_mode(lcd_info);
+	jz4750fb_foreground_resize(lcd_info);
+	jz4750fb_set_var(&cfb->fb.var, -1, &cfb->fb);
+}
+
+/*
+ * jz4750fb_deep_set_mode,
+ *
+ */
+static void jz4750fb_deep_set_mode( struct jz4750lcd_info * lcd_info )
+{
+	/* configurate sequence:
+	 * 1. disable lcdc.
+	 * 2. init frame descriptor.
+	 * 3. set panel mode
+	 * 4. set osd mode
+	 * 5. start lcd clock in CPM
+	 * 6. enable lcdc.
+	 */
+
+	__lcd_clr_ena();	/* Quick Disable */
+	lcd_info->osd.fg_change = FG_CHANGE_ALL; /* change FG0, FG1 size, postion??? */
+	jz4750fb_descriptor_init(lcd_info);
+	jz4750fb_set_panel_mode(lcd_info);
+	jz4750fb_set_mode(lcd_info);
+	jz4750fb_change_clock(lcd_info);
+	__lcd_set_ena();	/* enable lcdc */
+}
+
+
+static irqreturn_t jz4750fb_interrupt_handler(int irq, void *dev_id)
+{
+	unsigned int state;
+	static int irqcnt=0;
+
+	state = REG_LCD_STATE;
+	D("In the lcd interrupt handler, state=0x%x\n", state);
+
+	if (state & LCD_STATE_EOF) /* End of frame */
+		REG_LCD_STATE = state & ~LCD_STATE_EOF;
+
+	if (state & LCD_STATE_IFU0) {
+		printk("%s, InFiFo0 underrun\n", __FUNCTION__);
+		REG_LCD_STATE = state & ~LCD_STATE_IFU0;
+	}
+
+	if (state & LCD_STATE_IFU1) {
+		printk("%s, InFiFo1 underrun\n", __FUNCTION__);
+		REG_LCD_STATE = state & ~LCD_STATE_IFU1;
+	}
+
+	if (state & LCD_STATE_OFU) { /* Out fifo underrun */
+		REG_LCD_STATE = state & ~LCD_STATE_OFU;
+		if ( irqcnt++ > 100 ) {
+			__lcd_disable_ofu_intr();
+			printk("disable Out FiFo underrun irq.\n");
+		}
+		printk("%s, Out FiFo underrun.\n", __FUNCTION__);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PM
+
+/*
+ * Suspend the LCDC.
+ */
+static int jz4750_fb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	printk("%s(): called.\n", __func__);
+
+	screen_off();
+	ctrl_disable();
+
+	__cpm_stop_lcd();
+
+	return 0;
+}
+
+/*
+ * Resume the LCDC.
+ */
+static int jz4750_fb_resume(struct platform_device *pdev)
+{
+	struct lcd_cfb_info *cfb = jz4750fb_info;
+
+	printk("%s(): called.\n", __func__);
+
+	__cpm_start_lcd();
+	ctrl_enable();
+	screen_on();
+
+#if JZ_FB_DEBUG
+	display_h_color_bar(jz4750_lcd_info->osd.fg0.w, jz4750_lcd_info->osd.fg0.h, jz4750_lcd_info->osd.fg0.bpp);
+	mdelay(1000);
+#endif
+	return 0;
+}
+
+#else
+#define jzfb_suspend      NULL
+#define jzfb_resume       NULL
+#endif /* CONFIG_PM */
+
+/* The following routine is only for test */
+
+#if JZ_FB_DEBUG
+static void test_gpio(int gpio_num, int delay)	{
+	__gpio_as_output(gpio_num);
+	while(1) {
+		__gpio_set_pin(gpio_num);
+		udelay(delay);
+		__gpio_clear_pin(gpio_num);
+		udelay(delay);
+	}
+}
+static void display_v_color_bar(int w, int h, int bpp) {
+	int i, j, wpl, data = 0;
+	int *ptr;
+	ptr = (int *)lcd_frame0;
+//	ptr = (int *)lcd_frame1;
+	wpl = w*bpp/32;
+	if (!(bpp > 8))
+		switch(bpp){
+		case 1:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					*ptr++ = 0x00ff00ff;
+				}
+			break;
+		case 2:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					data = (i%4)*0x55555555;
+					*ptr++ = data;
+				}
+			break;
+		case 4:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					data = (i%16)*0x11111111;
+					*ptr++ = data;
+				}
+			break;
+		case 8:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i+=2) {
+					data = (i%(256))*0x01010101;
+					*ptr++ = data;
+					*ptr++ = data;
+				}
+			break;
+		}
+	else {
+		switch(bpp) {
+		case 16:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					if((i/4)%8==0)
+						*ptr++ = 0xffffffff;
+					else if ((i/4)%8==1)
+						*ptr++ = 0xf800f800;
+					else if ((i/4)%8==2)
+						*ptr++ = 0xffe0ffe0;
+					else if ((i/4)%8==3)
+						*ptr++ = 0x07e007e0;
+					else if ((i/4)%8==4)
+						*ptr++ = 0x07ff07ff;
+					else if ((i/4)%8==5)
+						*ptr++ = 0x001f001f;
+					else if ((i/4)%8==6)
+						*ptr++ = 0xf81ff81f;
+					else if ((i/4)%8==7)
+						*ptr++ = 0x00000000;
+				}
+			break;
+		case 18:
+		case 24:
+		case 32:
+		default:
+#if 1
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					if((i/8)%8==7) 
+						*ptr++ = 0xffffff;
+					else if ((i/8)%8==1)
+						*ptr++ = 0xff0000;
+					else if ((i/8)%8==2)
+						*ptr++ = 0xffff00;
+					else if ((i/8)%8==3)
+						*ptr++ = 0x00ff00;
+					else if ((i/8)%8==4)
+						*ptr++ = 0x00ffff;
+					else if ((i/8)%8==5)
+						*ptr++ = 0x0000ff;
+					else if ((i/8)%8==6)
+						*ptr++ = 0xff00ff;
+					else if ((i/8)%8==0)
+						*ptr++ = 0x000000;
+				}
+#else
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					if((i/8)%8==7)
+						*ptr++ = 0x00ff0000;
+					else if ((i/8)%8==1)
+						*ptr++ = 0xffff0000;
+					else if ((i/8)%8==2)
+						*ptr++ = 0x20ff0000;
+					else if ((i/8)%8==3)
+						*ptr++ = 0x40ff0000;
+					else if ((i/8)%8==4)
+						*ptr++ = 0x60ff0000;
+					else if ((i/8)%8==5)
+						*ptr++ = 0x80ff0000;
+					else if ((i/8)%8==6)
+						*ptr++ = 0xa0ff0000;
+					else if ((i/8)%8==0)
+						*ptr++ = 0xc0ff0000;
+				}
+#endif
+			break;
+		}
+	}
+}
+#if 1
+extern void jz_flush_cache_all(void);
+static void display_h_color_bar(int w, int h, int bpp)
+{
+	int i, j,data = 0;
+	unsigned int *ptr;
+	unsigned int *ptr1;
+	int wpl; //word_per_line
+	ptr = (unsigned int *)lcd_frame_test;
+	ptr1 = (unsigned int *)lcd_frame_test1;
+
+	while(1)
+	{
+		for(i=0;i<272;i++)
+		for(j=0;j<480;j++)
+		{
+			*(ptr+i*480+j) =0xff0000;
+		}
+		//memcpy((void *)lcd_frame0,(void *)lcd_frame_test,lcd_frame_size);mdelay(1000);
+		dma0_desc0->databuf = (unsigned int)virt_to_phys((void *)lcd_frame_test);
+		dma_cache_wback((unsigned int)(dma0_desc0), sizeof(struct jz4750_lcd_dma_desc));
+		mdelay(1000);
+
+		for(i=0;i<272;i++)
+		for(j=0;j<480;j++)
+		{
+			*(ptr1+i*480+j) =0x00ff00;
+		}
+		//memcpy((void *)lcd_frame0,(void *)lcd_frame_test,lcd_frame_size);mdelay(1000);
+		dma0_desc0->databuf = (unsigned int)virt_to_phys((void *)lcd_frame_test1);
+		dma_cache_wback((unsigned int)(dma0_desc0), sizeof(struct jz4750_lcd_dma_desc));
+		mdelay(1000);
+	}
+}
+#else
+static void display_h_color_bar(int w, int h, int bpp) {
+	int i, data = 0;
+	int *ptr;
+	int wpl; //word_per_line
+	ptr = (int *)lcd_frame0;
+//	ptr = (int *)lcd_frame1;
+	wpl = w*bpp/32;
+	if (!(bpp > 8))
+		for (i = 0;i < wpl*h;i++) {
+			switch(bpp){
+			case 1:
+				if(i%(wpl*8)==0)
+					data = ((i/(wpl*8))%2)*0xffffffff;
+					*ptr++ = data;
+				break;
+			case 2:
+				if(i%(wpl*8)==0)
+					data = ((i/(wpl*8))%4)*0x55555555;
+					*ptr++ = data;
+				break;
+			case 4:
+				if(i%(wpl*8)==0)
+					data = ((i/(wpl*8))%16)*0x11111111;
+				*ptr++ = data;
+				break;
+			case 8:
+				if(i%(wpl*8)==0)
+					data = ((i/(wpl*8))%256)*0x01010101;
+				*ptr++ = data;
+				break;
+			}
+		}
+	else {
+
+		switch(bpp) {
+		case 15:
+		case 16:
+			for (i = 0;i < wpl*h;i++) {
+				if (((i/(wpl*8)) % 8) == 0)
+					*ptr++ = 0xffffffff;
+				else if (((i/(wpl*8)) % 8) == 1)
+					*ptr++ = 0xf800f800;
+				else if (((i/(wpl*8)) % 8) == 2)
+					*ptr++ = 0xffe0ffe0;
+				else if (((i/(wpl*8)) % 8) == 3)
+					*ptr++ = 0x07e007e0;
+				else if (((i/(wpl*8)) % 8) == 4)
+					*ptr++ = 0x07ff07ff;
+				else if (((i/(wpl*8)) % 8) == 5)
+					*ptr++ = 0x001f001f;
+				else if (((i/(wpl*8)) % 8) == 6)
+					*ptr++ = 0xf81ff81f;
+				else if (((i/(wpl*8)) % 8) == 7)
+					*ptr++ = 0x00000000;
+			}
+				break;
+		case 18:
+		case 24:
+		case 32:
+		default:
+			for (i = 0;i < wpl*h;i++) {
+				if (((i/(wpl*8)) % 8) == 7)
+					*ptr++ = 0xffffff;
+				else if (((i/(wpl*8)) % 8) == 2)
+					*ptr++ = 0xff0000;
+				else if (((i/(wpl*8)) % 8) == 4)
+					*ptr++ = 0xffff00;
+				else if (((i/(wpl*8)) % 8) == 6)
+					*ptr++ = 0x00ff00;
+				else if (((i/(wpl*8)) % 8) == 1)
+					*ptr++ = 0x00ffff;
+				else if (((i/(wpl*8)) % 8) == 3)
+					*ptr++ = 0x0000ff;
+				else if (((i/(wpl*8)) % 8) == 5)
+					*ptr++ = 0x000000;
+				else if (((i/(wpl*8)) % 8) == 0)
+					*ptr++ = 0xff00ff;
+			}
+			break;
+		}
+
+	}
+
+}
+#endif
+#endif
+
+/* Backlight Control Interface via sysfs
+ *
+ * LCDC:
+ * Enabling LCDC when LCD backlight is off will only affects cfb->display.
+ *
+ * Backlight:
+ * Changing the value of LCD backlight when LCDC is off will only affect the cfb->backlight_level.
+ *
+ * - River.
+ */
+static int screen_off(void)
+{
+	struct lcd_cfb_info *cfb = jz4750fb_info;
+
+	__lcd_close_backlight();
+	__lcd_display_off();
+
+#ifdef HAVE_LCD_PWM_CONTROL
+	if (cfb->b_lcd_pwm) {
+		__lcd_pwm_stop();
+		cfb->b_lcd_pwm = 0;
+	}
+#endif
+
+	cfb->b_lcd_display = 0;
+
+	return 0;
+}
+
+static int screen_on(void)
+{
+	struct lcd_cfb_info *cfb = jz4750fb_info;
+
+	__lcd_display_on();
+	mdelay(200);//
+	/* Really restore LCD backlight when LCD backlight is turned on. */
+	if (cfb->backlight_level) {
+#ifdef HAVE_LCD_PWM_CONTROL
+		if (!cfb->b_lcd_pwm) {
+			__lcd_pwm_start();
+			cfb->b_lcd_pwm = 1;
+		}
+#endif
+		__lcd_set_backlight_level(cfb->backlight_level);
+
+	}
+
+	cfb->b_lcd_display = 1;
+
+	return 0;
+}
+
+static int jz4750fb_set_backlight_level(int n)
+{
+	struct lcd_cfb_info *cfb = jz4750fb_info;
+
+	if (n) {
+		if (n > LCD_MAX_BACKLIGHT)
+			n = LCD_MAX_BACKLIGHT;
+
+		if (n < LCD_MIN_BACKLIGHT)
+			n = LCD_MIN_BACKLIGHT;
+
+		/* Really change the value of backlight when LCDC is enabled. */
+		if (cfb->b_lcd_display) {
+#ifdef HAVE_LCD_PWM_CONTROL
+			if (!cfb->b_lcd_pwm) {
+				__lcd_pwm_start();
+				cfb->b_lcd_pwm = 1;
+			}
+#endif
+			__lcd_set_backlight_level(n);
+		}
+	}else{
+		/* Turn off LCD backlight. */
+		__lcd_close_backlight();
+
+#ifdef HAVE_LCD_PWM_CONTROL
+		if (cfb->b_lcd_pwm) {
+			__lcd_pwm_stop();
+			cfb->b_lcd_pwm = 0;
+		}
+#endif
+	}
+
+	cfb->backlight_level = n;
+
+	return 0;
+}
+
+static ssize_t show_bl_level(struct device *device,
+			     struct device_attribute *attr, char *buf)
+{
+	struct lcd_cfb_info *cfb = jz4750fb_info;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", cfb->backlight_level);
+}
+
+static ssize_t store_bl_level(struct device *device,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int n;
+	char *ep;
+
+	n = simple_strtoul(buf, &ep, 0);
+	if (*ep && *ep != '\n')
+		return -EINVAL;
+
+	jz4750fb_set_backlight_level(n);
+
+	return count;
+}
+
+static struct device_attribute device_attrs[] = {
+	__ATTR(backlight_level, S_IRUGO | S_IWUSR, show_bl_level, store_bl_level),
+};
+
+static int jz4750fb_device_attr_register(struct fb_info *fb_info)
+{
+	int error = 0;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(device_attrs); i++) {
+		error = device_create_file(fb_info->dev, &device_attrs[i]);
+
+		if (error)
+			break;
+	}
+
+	if (error) {
+		while (--i >= 0)
+			device_remove_file(fb_info->dev, &device_attrs[i]);
+	}
+
+	return 0;
+}
+
+static int jz4750fb_device_attr_unregister(struct fb_info *fb_info)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(device_attrs); i++)
+		device_remove_file(fb_info->dev, &device_attrs[i]);
+
+	return 0;
+}
+/* End */
+
+static void gpio_init(void)
+{
+	__lcd_display_pin_init();
+
+	/* gpio init __gpio_as_lcd */
+	if (jz4750_lcd_info->panel.cfg & LCD_CFG_MODE_TFT_16BIT)
+		__gpio_as_lcd_16bit();
+	else if (jz4750_lcd_info->panel.cfg & LCD_CFG_MODE_TFT_24BIT)
+		__gpio_as_lcd_24bit();
+	else
+ 		__gpio_as_lcd_18bit();
+
+	/* In special mode, we only need init special pin,
+	 * as general lcd pin has init in uboot */
+
+	switch (jz4750_lcd_info->panel.cfg & LCD_CFG_MODE_MASK) {
+	case LCD_CFG_MODE_SPECIAL_TFT_1:
+	case LCD_CFG_MODE_SPECIAL_TFT_2:
+	case LCD_CFG_MODE_SPECIAL_TFT_3:
+		__gpio_as_lcd_special();
+		break;
+	default:
+		;
+	}
+
+	return;
+}
+
+static void set_bpp_to_ctrl_bpp(void)
+{
+	switch (jz4750_lcd_info->osd.fg0.bpp) {
+		case 15:
+		case 16:
+			break;
+
+		case 17 ... 32:
+			jz4750_lcd_info->osd.fg0.bpp = 32;
+			break;
+
+		default:
+			E("FG0: BPP (%d) not support, Set BPP 32.\n", 
+					jz4750_lcd_info->osd.fg0.bpp);
+
+			jz4750_lcd_info->osd.fg0.bpp = 32;
+			break;
+	}
+
+	switch (jz4750_lcd_info->osd.fg1.bpp) {
+		case 15:
+		case 16:
+			break;
+
+		case 17 ... 32:
+			jz4750_lcd_info->osd.fg1.bpp = 32;
+			break;
+
+		default:
+			E("FG1: BPP (%d) not support, Set BPP 32.\n", 
+					jz4750_lcd_info->osd.fg1.bpp);
+
+			jz4750_lcd_info->osd.fg1.bpp = 32;
+			break;
+	}
+
+	return;
+}
+
+static void slcd_init(void)
+{
+	/* Configure SLCD module for setting smart lcd control registers */
+#if defined(CONFIG_FB_JZ4750_SLCD)
+	__lcd_as_smart_lcd();
+	__slcd_disable_dma();
+	__init_slcd_bus();	/* Note: modify this depend on you lcd */
+
+#endif
+	return;
+}
+
+static int __devinit jz4750_fb_probe(struct platform_device *dev)
+{
+	struct lcd_cfb_info *cfb;
+
+	int rv = 0;
+
+	cfb = jz4750fb_alloc_fb_info();
+	if (!cfb)
+		goto failed;
+
+	screen_off();
+	ctrl_disable();
+
+	gpio_init();
+	slcd_init();
+
+	set_bpp_to_ctrl_bpp();
+
+	/* init clk */
+	jz4750fb_change_clock(jz4750_lcd_info);
+
+	rv = jz4750fb_map_smem(cfb);
+	if (rv)
+		goto failed;
+
+	jz4750fb_deep_set_mode(jz4750_lcd_info);
+
+	rv = register_framebuffer(&cfb->fb);
+	if (rv < 0) {
+		D("Failed to register framebuffer device.");
+		goto failed;
+	}
+
+	printk("fb%d: %s frame buffer device, using %dK of video memory\n",
+	       cfb->fb.node, cfb->fb.fix.id, cfb->fb.fix.smem_len>>10);
+
+	jz4750fb_device_attr_register(&cfb->fb);
+
+	if (request_irq(IRQ_LCD, jz4750fb_interrupt_handler, IRQF_DISABLED,
+				"lcd", 0)) {
+		D("Faield to request LCD IRQ.\n");
+		rv = -EBUSY;
+		goto failed;
+	}
+
+	ctrl_enable();
+	screen_on();
+
+#if JZ_FB_DEBUG
+	display_h_color_bar(jz4750_lcd_info->osd.fg0.w, jz4750_lcd_info->osd.fg0.h, jz4750_lcd_info->osd.fg0.bpp);
+
+	//print_lcdc_registers();
+#endif
+
+	return 0;
+
+failed:
+	jz4750fb_unmap_smem(cfb);
+	jz4750fb_free_fb_info(cfb);
+
+	return rv;
+}
+
+static int __devexit jz4750_fb_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver jz4750_fb_driver = {
+	.probe	= jz4750_fb_probe,
+	.remove = jz4750_fb_remove,
+	.suspend = jz4750_fb_suspend,
+	.resume = jz4750_fb_resume,
+	.driver = {
+		.name = "jz-lcd",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init jz4750_fb_init(void)
+{
+	return platform_driver_register(&jz4750_fb_driver);
+}
+
+static void __exit jz4750_fb_cleanup(void)
+{
+	platform_driver_unregister(&jz4750_fb_driver);
+}
+
+module_init(jz4750_fb_init);
+module_exit(jz4750_fb_cleanup);
diff --git a/drivers/video/jz4750_lcd.h b/drivers/video/jz4750_lcd.h
new file mode 100644
index 0000000..fea77d2
--- /dev/null
+++ b/drivers/video/jz4750_lcd.h
@@ -0,0 +1,269 @@
+/*
+ * linux/drivers/video/jz4750_lcd.h -- Ingenic Jz4750 On-Chip LCD frame buffer device
+ *
+ * Copyright (C) 2005-2008, Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __JZ4750_LCD_H__
+#define __JZ4750_LCD_H__
+
+#define NR_PALETTE	256
+#define PALETTE_SIZE	(NR_PALETTE*2)
+
+/* use new descriptor(8 words) */
+struct jz4750_lcd_dma_desc {
+	unsigned int next_desc;		/* LCDDAx */
+	unsigned int databuf;		/* LCDSAx */
+	unsigned int frame_id;		/* LCDFIDx */
+	unsigned int cmd;		/* LCDCMDx */
+	unsigned int offsize;		/* Stride Offsize(in word) */
+	unsigned int page_width;	/* Stride Pagewidth(in word) */
+	unsigned int cmd_num;		/* Command Number(for SLCD) */
+	unsigned int desc_size;		/* Foreground Size */
+};
+
+struct jz4750lcd_panel_t {
+	unsigned int cfg;	/* panel mode and pin usage etc. */
+	unsigned int slcd_cfg;	/* Smart lcd configurations */
+	unsigned int ctrl;	/* lcd controll register */
+	unsigned int w;		/* Panel Width(in pixel) */
+	unsigned int h;		/* Panel Height(in line) */
+	unsigned int fclk;	/* frame clk */
+	unsigned int hsw;	/* hsync width, in pclk */
+	unsigned int vsw;	/* vsync width, in line count */
+	unsigned int elw;	/* end of line, in pclk */
+	unsigned int blw;	/* begin of line, in pclk */
+	unsigned int efw;	/* end of frame, in line count */
+	unsigned int bfw;	/* begin of frame, in line count */
+};
+
+
+struct jz4750lcd_fg_t {
+	int bpp;	/* foreground bpp */
+	int x;		/* foreground start position x */
+	int y;		/* foreground start position y */
+	int w;		/* foreground width */
+	int h;		/* foreground height */
+};
+
+struct jz4750lcd_osd_t {
+	unsigned int osd_cfg;	/* OSDEN, ALHPAEN, F0EN, F1EN, etc */
+	unsigned int osd_ctrl;	/* IPUEN, OSDBPP, etc */
+	unsigned int rgb_ctrl;	/* RGB Dummy, RGB sequence, RGB to YUV */
+	unsigned int bgcolor;	/* background color(RGB888) */
+	unsigned int colorkey0;	/* foreground0's Colorkey enable, Colorkey value */
+	unsigned int colorkey1; /* foreground1's Colorkey enable, Colorkey value */
+	unsigned int alpha;	/* ALPHAEN, alpha value */
+	unsigned int ipu_restart; /* IPU Restart enable, ipu restart interval time */
+
+#define FG_NOCHANGE		0x0000
+#define FG0_CHANGE_SIZE		0x0001
+#define FG0_CHANGE_POSITION	0x0002
+#define FG1_CHANGE_SIZE		0x0010
+#define FG1_CHANGE_POSITION	0x0020
+#define FG_CHANGE_ALL		( FG0_CHANGE_SIZE | FG0_CHANGE_POSITION | \
+				  FG1_CHANGE_SIZE | FG1_CHANGE_POSITION )
+	int fg_change;
+	struct jz4750lcd_fg_t fg0;	/* foreground 0 */
+	struct jz4750lcd_fg_t fg1;	/* foreground 1 */
+};
+
+struct jz4750lcd_info {
+	struct jz4750lcd_panel_t panel;
+	struct jz4750lcd_osd_t osd;
+};
+
+
+/* Jz LCDFB supported I/O controls. */
+#define FBIOSETBACKLIGHT	0x4688 /* set back light level */
+#define FBIODISPON		0x4689 /* display on */
+#define FBIODISPOFF		0x468a /* display off */
+#define FBIORESET		0x468b /* lcd reset */
+#define FBIOPRINT_REG		0x468c /* print lcd registers(debug) */
+#define FBIOROTATE		0x46a0 /* rotated fb */
+#define FBIOGETBUFADDRS		0x46a1 /* get buffers addresses */
+#define FBIO_GET_MODE		0x46a2 /* get lcd info */
+#define FBIO_SET_MODE		0x46a3 /* set osd mode */
+#define FBIO_DEEP_SET_MODE	0x46a4 /* set panel and osd mode */
+#define FBIO_MODE_SWITCH	0x46a5 /* switch mode between LCD and TVE */
+#define FBIO_GET_TVE_MODE	0x46a6 /* get tve info */
+#define FBIO_SET_TVE_MODE	0x46a7 /* set tve mode */
+
+/*
+ * LCD panel specific definition
+ */
+/* AUO */
+#if defined(CONFIG_JZ4750_LCD_AUO_A043FL01V2)
+#if defined(CONFIG_JZ4750D_CETUS) /* board pavo */
+	#define SPEN		(32*5+13)       /*LCD_CS*/
+	#define SPCK		(32*5+10)       /*LCD_SCL*/
+	#define SPDA		(32*5+11)       /*LCD_SDA*/
+	#define LCD_RET		(32*4+18)       /*LCD_DISP_N use for lcd reset*/
+#else
+#error "driver/video/Jzlcd.h, please define SPI pins on your board."
+#endif
+
+#define __spi_write_reg(reg, val)		\
+	do {					\
+		unsigned char no;		\
+		unsigned short value;		\
+		unsigned char a=0;		\
+		unsigned char b=0;		\
+		__gpio_as_output(SPEN); /* use SPDA */	\
+		__gpio_as_output(SPCK); /* use SPCK */	\
+		__gpio_as_output(SPDA); /* use SPDA */	\
+		a=reg;				\
+		b=val;				\
+		__gpio_set_pin(SPEN);		\
+		__gpio_clear_pin(SPCK);		\
+		udelay(50);			\
+		__gpio_clear_pin(SPDA);		\
+		__gpio_clear_pin(SPEN);		\
+		udelay(50);			\
+		value=((a<<8)|(b&0xFF));	\
+		for(no=0;no<16;no++)		\
+		{				\
+			if((value&0x8000)==0x8000){	      \
+				__gpio_set_pin(SPDA);}	      \
+			else{				      \
+				__gpio_clear_pin(SPDA); }     \
+			udelay(50);			\
+			__gpio_set_pin(SPCK);		\
+			value=(value<<1);		\
+			udelay(50);			\
+			__gpio_clear_pin(SPCK);		\
+		}					\
+		__gpio_set_pin(SPEN);			\
+		udelay(400);				\
+	} while (0)
+#define __spi_read_reg(reg,val)			\
+	do{					\
+		unsigned char no;		\
+		unsigned short value;			\
+		__gpio_as_output(SPEN); /* use SPDA */	\
+		__gpio_as_output(SPCK); /* use SPCK */	\
+		__gpio_as_output(SPDA); /* use SPDA */	\
+		value = ((reg << 0) | (1 << 7));	\
+		val = 0;				\
+		__gpio_as_output(SPDA);			\
+		__gpio_set_pin(SPEN);			\
+		__gpio_clear_pin(SPCK);			\
+		udelay(50);				\
+		__gpio_clear_pin(SPDA);			\
+		__gpio_clear_pin(SPEN);			\
+		udelay(50);				\
+		for (no = 0; no < 16; no++ ) {		\
+			udelay(50);			\
+			if(no < 8)			\
+			{						\
+				if (value & 0x80) /* send data */	\
+					__gpio_set_pin(SPDA);		\
+				else					\
+					__gpio_clear_pin(SPDA);		\
+				udelay(50);				\
+				__gpio_set_pin(SPCK);			\
+				value = (value << 1);			\
+				udelay(50);				\
+				__gpio_clear_pin(SPCK);			\
+				if(no == 7)				\
+					__gpio_as_input(SPDA);		\
+			}						\
+			else						\
+			{						\
+				udelay(100);				\
+				__gpio_set_pin(SPCK);			\
+				udelay(50);				\
+				val = (val << 1);			\
+				val |= __gpio_get_pin(SPDA);		\
+				__gpio_clear_pin(SPCK);			\
+			}						\
+		}							\
+		__gpio_as_output(SPDA);					\
+		__gpio_set_pin(SPEN);					\
+		udelay(400);						\
+	} while(0)
+
+#define __lcd_special_pin_init()		\
+	do {						\
+		__gpio_as_output(SPEN); /* use SPDA */	\
+		__gpio_as_output(SPCK); /* use SPCK */	\
+		__gpio_as_output(SPDA); /* use SPDA */	\
+		__gpio_as_output(LCD_RET);		\
+		udelay(50);				\
+		__gpio_clear_pin(LCD_RET);		\
+		udelay(100);				\
+		__gpio_set_pin(LCD_RET);		\
+	} while (0)
+#define __lcd_special_on()			     \
+	do {					     \
+		udelay(50);			     \
+		__gpio_clear_pin(LCD_RET);	     \
+		udelay(100);			     \
+		__gpio_set_pin(LCD_RET);	     \
+} while (0)
+
+	#define __lcd_special_off() \
+	do { \
+		__gpio_clear_pin(LCD_RET);		\
+	} while (0)
+
+#endif	/* CONFIG_JZLCD_AUO_A030FL01_V1 */
+
+#ifndef __lcd_special_pin_init
+#define __lcd_special_pin_init()
+#endif
+#ifndef __lcd_special_on
+#define __lcd_special_on()
+#endif
+#ifndef __lcd_special_off
+#define __lcd_special_off()
+#endif
+
+/*
+ * Platform specific definition
+ */
+#if defined(CONFIG_JZ4750D_CETUS)/* board apus */
+#define __lcd_display_pin_init() \
+do { \
+	__gpio_as_output(GPIO_LCD_VCC_EN_N);	 \
+	__lcd_special_pin_init();	   \
+} while (0)
+
+#define __lcd_display_on() \
+do { \
+	__gpio_set_pin(GPIO_LCD_VCC_EN_N);	\
+	__lcd_special_on();			\
+} while (0)
+
+#define __lcd_display_off() \
+do { \
+	__lcd_special_off();	 \
+} while (0)
+#endif
+
+/*****************************************************************************
+ * LCD display pin dummy macros
+ *****************************************************************************/
+
+#ifndef __lcd_display_pin_init
+#define __lcd_display_pin_init()
+#endif
+#ifndef __lcd_slcd_special_on
+#define __lcd_slcd_special_on()
+#endif
+#ifndef __lcd_display_on
+#define __lcd_display_on()
+#endif
+#ifndef __lcd_display_off
+#define __lcd_display_off()
+#endif
+#ifndef __lcd_set_backlight_level
+#define __lcd_set_backlight_level(n)
+#endif
+
+#endif /* __JZ4750_LCD_H__ */
diff --git a/drivers/video/jz4750_tve.c b/drivers/video/jz4750_tve.c
new file mode 100644
index 0000000..3a4ea61
--- /dev/null
+++ b/drivers/video/jz4750_tve.c
@@ -0,0 +1,104 @@
+
+/*
+ * linux/drivers/video/jz4750_tve.c -- Ingenic Jz4750 TVE Controller operation
+ * interface.
+ * Copyright (C) 2005-2008, Ingenic Semiconductor Inc.
+ * Author: Wolfgang Wang, <lgwang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#include <asm/jzsoc.h>
+#include "jz4750_tve.h"
+
+struct jz4750tve_info jz4750_tve_info_PAL = {
+	.ctrl = (4 << TVE_CTRL_YCDLY_BIT) | TVE_CTRL_SYNCT | TVE_CTRL_PAL | TVE_CTRL_SWRST,	/* PAL, SVIDEO */
+	.frcfg = (23 << TVE_FRCFG_L1ST_BIT) | (625 << TVE_FRCFG_NLINE_BIT),
+	.slcfg1 = (800<<TVE_SLCFG1_WHITEL_BIT) | (282<<TVE_SLCFG1_BLACKL_BIT),
+	.slcfg2 = (296<<TVE_SLCFG2_VBLANKL_BIT) | (240<<TVE_SLCFG2_BLANKL_BIT),
+	.slcfg3 = (72 <<TVE_SLCFG3_SYNCL_BIT),
+	.ltcfg1 = (20<<TVE_LTCFG1_FRONTP_BIT) | (63<<TVE_LTCFG1_HSYNCW_BIT) | (78<<TVE_LTCFG1_BACKP_BIT),
+	.ltcfg2 = (1440 << TVE_LTCFG2_ACTLIN_BIT) | (24 << TVE_LTCFG2_PREBW_BIT) | (68 << TVE_LTCFG2_BURSTW_BIT),
+	.cfreq = 0x2a098acb,
+	.cphase = (0 << TVE_CPHASE_INITPH_BIT) | (0 << TVE_CPHASE_ACTPH_BIT) | (1 << TVE_CPHASE_CCRSTP_BIT),
+	.cbcrcfg = (32<<TVE_CBCRCFG_CBBA_BIT) | (59<<TVE_CBCRCFG_CRBA_BIT) | (137<<TVE_CBCRCFG_CBGAIN_BIT) | (137<<TVE_CBCRCFG_CRGAIN_BIT), /* CBGAIN CRGAIN??? */
+	.wsscr = 0x00000070,	/* default value */
+	.wsscfg1 = 0x0,
+	.wsscfg2 = 0x0,
+	.wsscfg3 = 0x0,
+};
+
+struct jz4750tve_info jz4750_tve_info_NTSC = {
+	.ctrl = (4 << TVE_CTRL_YCDLY_BIT) | TVE_CTRL_SWRST,	/* NTSC, SVIDEO */
+	.frcfg = (21 << TVE_FRCFG_L1ST_BIT) | (525 << TVE_FRCFG_NLINE_BIT),
+	.slcfg1 = (800<<TVE_SLCFG1_WHITEL_BIT) | (282<<TVE_SLCFG1_BLACKL_BIT),
+	.slcfg2 = (296<<TVE_SLCFG2_VBLANKL_BIT) | (240<<TVE_SLCFG2_BLANKL_BIT),
+	.slcfg3 = (72 <<TVE_SLCFG3_SYNCL_BIT),
+	.ltcfg1 = (16<<TVE_LTCFG1_FRONTP_BIT) | (63<<TVE_LTCFG1_HSYNCW_BIT) | (59<<TVE_LTCFG1_BACKP_BIT),
+	.ltcfg2 = (1440 << TVE_LTCFG2_ACTLIN_BIT) | (22 << TVE_LTCFG2_PREBW_BIT) | (68 << TVE_LTCFG2_BURSTW_BIT),
+	.cfreq = 0x21f07c1f,
+	.cphase = (0x17 << TVE_CPHASE_INITPH_BIT) | (0 << TVE_CPHASE_ACTPH_BIT) | (1 << TVE_CPHASE_CCRSTP_BIT),
+	.cbcrcfg = (59<<TVE_CBCRCFG_CBBA_BIT) | (0<<TVE_CBCRCFG_CRBA_BIT) | (137<<TVE_CBCRCFG_CBGAIN_BIT) | (137<<TVE_CBCRCFG_CRGAIN_BIT),
+	.wsscr = 0x00000070,	/* default value */
+	.wsscfg1 = 0x0,
+	.wsscfg2 = 0x0,
+	.wsscfg3 = 0x0,
+};
+
+struct jz4750tve_info *jz4750_tve_info = &jz4750_tve_info_PAL; /* default as PAL mode */
+
+void jz4750tve_enable_tve(void)
+{
+	/* enable tve controller, enable DACn??? */
+	jz4750_tve_info->ctrl = (jz4750_tve_info->ctrl | TVE_CTRL_DAPD) & ( ~( TVE_CTRL_DAPD1 | TVE_CTRL_DAPD2));
+	jz4750_tve_info->ctrl &= ~TVE_CTRL_SWRST;
+	REG_TVE_CTRL = jz4750_tve_info->ctrl;
+}
+
+/* turn off TVE, turn off DACn... */
+void jz4750tve_disable_tve(void)
+{
+	jz4750_tve_info->ctrl &= ~TVE_CTRL_DAPD;/* DACn disabled??? */
+	jz4750_tve_info->ctrl |= TVE_CTRL_SWRST;/* DACn disabled??? */
+	REG_TVE_CTRL = jz4750_tve_info->ctrl;
+}
+
+void jz4750tve_set_tve_mode( struct jz4750tve_info *tve )
+{
+	REG_TVE_CTRL 		= tve->ctrl;
+	REG_TVE_FRCFG 		= tve->frcfg;
+	REG_TVE_SLCFG1 		= tve->slcfg1;
+	REG_TVE_SLCFG2 		= tve->slcfg2;
+	REG_TVE_SLCFG3 		= tve->slcfg3;
+	REG_TVE_LTCFG1 		= tve->ltcfg1;
+	REG_TVE_LTCFG2 		= tve->ltcfg2;
+	REG_TVE_CFREQ 		= tve->cfreq;
+	REG_TVE_CPHASE 		= tve->cphase;
+	REG_TVE_CBCRCFG 	= tve->cbcrcfg;
+	REG_TVE_WSSCR 		= tve->wsscr;
+	REG_TVE_WSSCFG1 	= tve->wsscfg1;
+	REG_TVE_WSSCFG2 	= tve->wsscfg2;
+	REG_TVE_WSSCFG3 	= tve->wsscfg3;
+}
+
+void jz4750tve_init( int tve_mode )
+{
+	switch ( tve_mode ) {
+	case PANEL_MODE_TVE_PAL:
+		jz4750_tve_info = &jz4750_tve_info_PAL;
+		break;
+	case PANEL_MODE_TVE_NTSC:
+		jz4750_tve_info = &jz4750_tve_info_NTSC;
+		break;
+	}
+
+	jz4750tve_set_tve_mode( jz4750_tve_info );
+//	jz4750tve_enable_tve();
+}
diff --git a/drivers/video/jz4750_tve.h b/drivers/video/jz4750_tve.h
new file mode 100644
index 0000000..00eefe9
--- /dev/null
+++ b/drivers/video/jz4750_tve.h
@@ -0,0 +1,45 @@
+#ifndef __JZ4750_TVE_H__
+#define __JZ4750_TVE_H__
+
+
+#define PANEL_MODE_LCD_PANEL	0
+#define PANEL_MODE_TVE_PAL	1
+#define PANEL_MODE_TVE_NTSC	2
+
+/* TV parameter */
+#define TVE_WIDTH_PAL 		720
+#define TVE_HEIGHT_PAL 		573
+#define TVE_FREQ_PAL 		50
+#define TVE_WIDTH_NTSC 		720
+#define TVE_HEIGHT_NTSC 	482
+#define TVE_FREQ_NTSC 		60
+
+
+/* Structure for TVE */
+struct jz4750tve_info {
+	unsigned int ctrl;
+	unsigned int frcfg;
+	unsigned int slcfg1;
+	unsigned int slcfg2;
+	unsigned int slcfg3;
+	unsigned int ltcfg1;
+	unsigned int ltcfg2;
+	unsigned int cfreq;
+	unsigned int cphase;
+	unsigned int cbcrcfg;
+	unsigned int wsscr;
+	unsigned int wsscfg1;
+	unsigned int wsscfg2;
+	unsigned int wsscfg3;
+};
+
+extern struct jz4750tve_info *jz4750_tve_info;
+
+extern void jz4750tve_enable_tve(void);
+extern void jz4750tve_disable_tve(void);
+
+extern void jz4750tve_set_tve_mode( struct jz4750tve_info *tve );
+extern void jz4750tve_init( int tve_mode );
+
+
+#endif	/* __JZ4750_TVE_H__ */
diff --git a/drivers/video/jz475x/Makefile b/drivers/video/jz475x/Makefile
new file mode 100644
index 0000000..684d3e1
--- /dev/null
+++ b/drivers/video/jz475x/Makefile
@@ -0,0 +1 @@
+obj-y += jz-fb.o
diff --git a/drivers/video/jz475x/abi.h b/drivers/video/jz475x/abi.h
new file mode 100644
index 0000000..d103b7c
--- /dev/null
+++ b/drivers/video/jz475x/abi.h
@@ -0,0 +1,114 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * ABI between Kernel Driver and Userspace Driver
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __JZ_FB_ABI_H__
+#define __JZ_FB_ABI_H__
+
+#include "config.h"
+
+/* Window Attribute. */
+struct jz_fb_win_attr_info {
+	int enable;
+
+	unsigned int x;
+	unsigned int y;
+	unsigned int w;
+	unsigned int h;
+
+	unsigned int bpp;
+};
+
+/* Output Panel State. */
+enum {
+	JZ_FB_PANEL_STATE_POWER_OFF = 0,
+	JZ_FB_PANEL_STATE_POWER_ON,
+	JZ_FB_PANEL_STATE_SCREEN_OFF,
+	JZ_FB_PANEL_STATE_SCREEN_ON,
+};
+
+/* ----------- Common --------------- */
+enum {
+	JZ_FB_CMD_COMMON_GET_STATE = 0,
+	JZ_FB_CMD_COMMON_SET_POWER,
+	JZ_FB_CMD_COMMON_SET_SCREEN,
+	
+	JZ_FB_CMD_COMMON_GET_WIN_ATTR,
+	JZ_FB_CMD_COMMON_SET_WIN_ATTR,
+	
+	JZ_FB_CMD_COMMON_SELECT_OT,
+	JZ_FB_CMD_COMMON_END,
+};
+
+struct jz_fb_common_control {
+	int id;
+	int command;
+	int v;
+
+	/* TODO: We may support runtime changes in future. */
+	int active_now;	
+
+	struct jz_fb_win_attr_info win_attr[JZ_FB_NR_MAX_FG];
+};
+
+/* Command: GET_STATE. Return value: */
+enum {
+	JZ_FB_CMD_COMMON_STATE_OT_POWER = (1 << 0),
+	JZ_FB_CMD_COMMON_STATE_OT_ENABLE = (1 << 1),
+	JZ_FB_CMD_COMMON_STATE_CTRL_ENABLE = (1 << 2),
+};
+
+/* --------- OUTPUT PATH: LCD --------------- */
+
+/* COMMAND. */
+enum {
+	JZ_FB_CMD_LCD_GET_BACKLIGHT = JZ_FB_CMD_COMMON_END,
+	JZ_FB_CMD_LCD_SET_BACKLIGHT,
+};
+
+struct jz_fb_lcd_control {
+	struct jz_fb_common_control common;
+};
+
+/* -------- OUTPUT PATH: TV NTSC/PAL -------- */
+/* COMMAND. */
+enum {
+	JZ_FB_CMD_TVE_GET_PATH = JZ_FB_CMD_COMMON_END,
+	JZ_FB_CMD_TVE_SET_PATH,
+};
+
+/* TVE Output Path. */
+enum {
+	JZ_FB_TVE_PATH_CVBS = 0,
+	JZ_FB_TVE_PATH_SVIDEO,
+
+#ifdef CONFIG_SOC_JZ4750D
+	JZ_FB_TVE_PATH_YUV,
+#endif
+
+};
+
+struct jz_fb_tve_control {
+	struct jz_fb_common_control common;
+};
+
+#endif /* Define __JZ_FB_ABI_H__ */
diff --git a/drivers/video/jz475x/common.c b/drivers/video/jz475x/common.c
new file mode 100644
index 0000000..6464289
--- /dev/null
+++ b/drivers/video/jz475x/common.c
@@ -0,0 +1,33 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Common Routines.
+ *
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+static inline unsigned long dma_align_size(unsigned long size)
+{
+	unsigned long align = JZ_FB_DMA_ALIGN;
+
+	size = (size + align - 1) / align * align;
+
+	return size;
+}
+
+
diff --git a/drivers/video/jz475x/config.h b/drivers/video/jz475x/config.h
new file mode 100644
index 0000000..1cf20f2
--- /dev/null
+++ b/drivers/video/jz475x/config.h
@@ -0,0 +1,104 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * SOC & Driver Config.
+ *
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __JZ_FB_CONFIG_H__
+#define __JZ_FB_CONFIG_H__
+
+#ifdef __KERNEL__
+#include <linux/autoconf.h>
+#else
+#include "userspace-config.h"
+#endif
+
+#ifdef __KERNEL__
+/* DEBUG. */
+#define JZ_FB_DEBUG		0
+#define JZ_FB_DEBUG_DUMP	0	/* Dump Structures. */
+#endif
+
+/* --------------- CONFIG FOR JZ4750 ---------------- */
+#ifdef CONFIG_SOC_JZ4750
+
+/* Limits. */
+#define JZ_FB_NR_MAX_DMA_DESC	6
+#define JZ_FB_NR_MAX_FB_MEM	3
+#define JZ_FB_NR_MAX_FG 	2
+
+/* REVIST: ALIGN. */
+#define JZ_FB_DMA_ALIGN		4
+#define JZ_FB_WIN_POS_ALIGN	2
+#define JZ_FB_WIN_SIZE_ALIGN	2
+
+/* Config. */
+#define JZ_FB_8WORD_DMA_DESC	1
+
+#define HAVE_TVE		1
+
+#endif
+
+/* --------------- CONFIG FOR JZ4755 ---------------- */
+#ifdef CONFIG_SOC_JZ4750D
+
+/* Limits. */
+#define JZ_FB_NR_MAX_DMA_DESC	6
+#define JZ_FB_NR_MAX_FB_MEM	3
+#define JZ_FB_NR_MAX_FG 	2
+
+/* REVIST: ALIGN. */
+#define JZ_FB_DMA_ALIGN		4
+#define JZ_FB_WIN_POS_ALIGN	2
+#define JZ_FB_WIN_SIZE_ALIGN	2
+
+/* Config. */
+#define JZ_FB_8WORD_DMA_DESC	1
+
+#define HAVE_TVE		1
+#endif
+
+#ifdef __KERNEL__
+
+/* ------------- JZ_FB_DEBUG ----------- */
+#if JZ_FB_DEBUG
+#define D(fmt, args...) \
+	printk(KERN_ERR "%s(): LINE: %d "fmt"\n", __func__, __LINE__, ##args)
+#else
+#define D(fmt, args...)
+#endif
+
+/* ------------- JZ_FB_DEBUG_DUMP ------------- */
+#if JZ_FB_DEBUG_DUMP
+#define DUMP(fmt, args...) \
+	printk(KERN_ERR "%s(): "fmt"\n", __func__, ##args)
+#else
+#define DUMP(fmt, args...)
+#endif
+
+#define E(fmt, args...) \
+	printk(KERN_ERR "%s(): "fmt"\n", __func__, ##args)
+
+#define I(fmt, args...) \
+	printk(KERN_INFO JZ_SOC_NAME": "DRV_NAME": "fmt"\n", ##args) 
+
+#endif	/* Define __KERNEL__ */
+
+#endif
diff --git a/drivers/video/jz475x/core/desc.c b/drivers/video/jz475x/core/desc.c
new file mode 100644
index 0000000..e6a4bd4
--- /dev/null
+++ b/drivers/video/jz475x/core/desc.c
@@ -0,0 +1,346 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * DMA Descirptor Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+static void dump_desc(struct jz_fb_dma_desc *desc)
+{
+	DUMP("HW_DESC: Virt: 0x%08lx, Phys: 0x%08lx", &desc->hw_desc, 
+			virt_to_phys(&desc->hw_desc));
+	DUMP("=================================================");
+	DUMP("next_desc: 0x%08lx.", desc->hw_desc.next_desc);
+	DUMP("databuf: 0x%08lx.", desc->hw_desc.databuf);
+	DUMP("frame_id: 0x%08lx.", desc->hw_desc.frame_id);
+	DUMP("cmd: 0x%08lx.", desc->hw_desc.cmd);
+
+#ifdef JZ_FB_8WORD_DMA_DESC
+	DUMP("offsize: 0x%08lx.", desc->hw_desc.offsize);
+	DUMP("page_width: 0x%08lx.", desc->hw_desc.page_width);
+	DUMP("cmd_num: 0x%08lx.", desc->hw_desc.cmd_num);
+	DUMP("desc_size: 0x%08lx.", desc->hw_desc.desc_size);
+#endif
+
+	return;
+}
+
+static inline void dma_desc_wback_inv(struct jz_fb_dma_desc *desc)
+{
+	dma_cache_wback((unsigned long)&desc->hw_desc, sizeof(dma_desc_t));
+
+	return;
+}
+
+static unsigned long dma_desc_pool_init(struct jz_fb_win_info *win)
+{
+	void *mem = win->dma_desc_pool;
+
+	int i;
+	
+	win->dma_desc_data_start = NULL;
+	win->dma_desc_last_no_data = NULL;
+
+	for (i = 0; i < JZ_FB_NR_MAX_DMA_DESC; i++) {
+		win->dma_desc[i] = mem;
+
+		win->dma_desc[i]->use = 0;
+		win->dma_desc[i]->mem = NULL;
+
+		win->dma_desc[i]->index = i;
+		win->dma_desc[i]->win = win;
+
+		mem += sizeof(struct jz_fb_dma_desc);
+	}
+		
+	return sizeof(struct jz_fb_dma_desc) * JZ_FB_NR_MAX_DMA_DESC;
+}
+
+static struct jz_fb_dma_desc *dma_desc_get(struct jz_fb_win_info *win)
+{
+	struct jz_fb_dma_desc *desc;
+	
+	int i;
+
+	for (i = 0; i < JZ_FB_NR_MAX_DMA_DESC; i++) {
+		if (!win->dma_desc[i]->use) {
+			desc = win->dma_desc[i];		
+			desc->use = 1;
+
+			memset(&desc->hw_desc, 0, sizeof(dma_desc_t));
+
+			return desc;
+		}
+	}
+	
+	return NULL;
+}
+
+static void dma_desc_put(struct jz_fb_dma_desc *desc)
+{
+	desc->use = 0;
+	
+	return;
+}
+
+static void dma_desc_init(struct jz_fb_dma_desc *desc)
+{
+	/* TODO: Setup DMA Descriptor as static/dynamic config. 
+		like EOF etc.
+	*/
+
+	desc->hw_desc.next_desc = virt_to_phys(&desc->hw_desc);
+	desc->hw_desc.frame_id = desc->index;
+
+	INIT_LIST_HEAD(&desc->list);
+	INIT_LIST_HEAD(&desc->group);
+
+	return;
+}
+
+static void dma_desc_set_mem(struct jz_fb_dma_desc *desc, void *mem)
+{
+	desc->mem = mem;
+	desc->hw_desc.databuf = virt_to_phys(mem);
+
+	return;
+}
+
+static void dma_desc_set_data_size(struct jz_fb_dma_desc *desc, 
+					unsigned long size)
+{
+	desc->hw_desc.cmd |= dma_align_size(size) / 4;	/* Word. */
+	
+	return;
+}
+
+static void dma_desc_set_area_size(struct jz_fb_dma_desc *desc, unsigned int w,
+			unsigned int h)
+{
+	desc->hw_desc.desc_size = HW_AREA_SIZE(w, h);
+
+	return;
+}
+
+/* REVIST: The exact meaning of offsize and page_width. */
+void dma_desc_set_stride(struct jz_fb_dma_desc *desc, 
+		unsigned long offsize, unsigned long page_width)
+{
+	desc->hw_desc.offsize = dma_align_size(offsize) / 4;
+	desc->hw_desc.page_width = dma_align_size(page_width) / 4;
+
+	return;
+}
+
+static void dma_desc_set_as_palette(struct jz_fb_dma_desc *desc)
+{
+	desc->hw_desc.cmd |= LCD_CMD_PAL;
+	
+	return;
+}
+
+static void dma_desc_set_as_cmd(struct jz_fb_dma_desc *desc)
+{
+	desc->hw_desc.cmd |= LCD_CMD_CMD;
+	
+	return;
+}
+
+static void dma_desc_set_chain_head(struct jz_fb_dma_desc *desc)
+{
+	struct jz_fb_ot_info *ot = desc->win->ctrl->ot;
+	struct jz_fb_reg_info *reg = &ot->reg_info;
+
+	int win_index = desc->win->index;
+	
+	dma_desc_wback_inv(desc);
+
+	if (win_index == 0) {
+		REG_LCD_DA0 = reg->lcd_da0 = virt_to_phys(&desc->hw_desc);
+	}else{
+		REG_LCD_DA1 = reg->lcd_da1 = virt_to_phys(&desc->hw_desc);
+	}
+	
+	return;
+}
+
+static void dma_desc_set_data_head(struct jz_fb_dma_desc *desc)
+{
+	struct jz_fb_win_info *win = desc->win;
+
+	if (!win->dma_desc_last_no_data) {
+		dma_desc_set_chain_head(desc);
+	}else{
+		win->dma_desc_last_no_data->hw_desc.next_desc = virt_to_phys(&desc->hw_desc);
+
+		dma_desc_wback_inv(win->dma_desc_last_no_data);
+		dma_desc_wback_inv(desc);
+	}
+
+
+	return;
+}
+
+static struct jz_fb_dma_desc *dma_desc_mem_to_desc(struct jz_fb_win_info *win, void *mem)
+{
+	int i;
+
+	for (i = 0; i < JZ_FB_NR_MAX_DMA_DESC; i++) {
+		if (win->dma_desc[i]->use 
+			&& win->dma_desc[i]->mem == mem) {
+
+			return win->dma_desc[i];
+		}
+	}
+
+	return NULL;
+}
+
+/* Add a node to a group. */
+static void dma_desc_group_add(struct jz_fb_dma_desc *desc, 
+		struct jz_fb_dma_desc *head)
+{
+	struct jz_fb_dma_desc *tail;
+	
+	tail = list_entry(head->group.prev, struct jz_fb_dma_desc, group);
+
+	tail->hw_desc.next_desc = virt_to_phys(&desc->hw_desc);
+	desc->hw_desc.next_desc = virt_to_phys(&head->hw_desc);
+	
+	dma_desc_wback_inv(desc);
+	dma_desc_wback_inv(tail);
+
+	list_add_tail(&desc->group, &head->group);
+
+	return;
+}
+
+/* Add a group or node to DMA Chain. */
+static void dma_desc_chain_add_tail(struct jz_fb_dma_desc *desc, 
+		struct jz_fb_dma_desc *chain_head)
+{
+	struct jz_fb_dma_desc *chain_tail, *desc_tail;
+	
+	chain_tail = list_entry(chain_head->list.prev, struct jz_fb_dma_desc, list);
+
+	if (!list_empty(&desc->group)) {
+		desc_tail = list_entry(desc->group.prev, struct jz_fb_dma_desc, group);
+	}else{
+		desc_tail = desc;
+	}
+	
+	dma_desc_wback_inv(desc);
+
+	desc_tail->hw_desc.next_desc = virt_to_phys(&chain_head->hw_desc);
+	chain_tail->hw_desc.next_desc = virt_to_phys(&desc->hw_desc);
+	
+	dma_desc_wback_inv(desc_tail);
+	dma_desc_wback_inv(chain_tail);
+
+	list_add_tail(&desc->list, &chain_head->list);
+
+	return;
+}
+
+/* Delete a node / group from DMA Chain. */
+static void dma_desc_chain_del(struct jz_fb_dma_desc *desc)
+{	
+	struct jz_fb_dma_desc *prev, *prev_tail, *next;
+	struct jz_fb_win_info *win = desc->win;
+
+	if (list_empty(&desc->list)) /* Always deleted ? */
+		return;
+
+	prev = list_entry(desc->list.prev, struct jz_fb_dma_desc, list);
+	
+	/* Prev is in group ? */
+	if (!list_empty(&prev->group)) {
+		/* Get Prev group tail. */
+		prev_tail = list_entry(prev->group.prev, struct jz_fb_dma_desc, group);
+	}else{
+		prev_tail = prev;
+	}
+
+	next = list_entry(desc->list.next, struct jz_fb_dma_desc, list);
+
+	/* Should we choose new data head ? */
+	if (desc == win->dma_desc_data_start) {
+		/* Setup New data head. */
+		if(!win->dma_desc_last_no_data) {
+			dma_desc_set_chain_head(next);
+		}else{
+			dma_desc_set_data_head(next);			
+		}
+
+		win->dma_desc_data_start = next;
+	}
+
+	/* Remove us from the chain Prev group tail -> next group Head. */
+	prev_tail->hw_desc.next_desc = virt_to_phys(&next->hw_desc);
+
+	dma_desc_wback_inv(prev_tail);
+
+	list_del(&desc->list);
+
+	return;
+}
+
+static void dma_desc_add_to_chain(struct jz_fb_dma_desc *desc)
+{
+	struct jz_fb_win_info *win = desc->win;
+
+	if (!win->dma_desc_data_start) {
+		/* Empty. */
+		if (!win->dma_desc_last_no_data) {
+			/* Chain head. */
+			dma_desc_set_chain_head(desc);
+		}else{
+			/* Only Data head. */
+			dma_desc_set_data_head(desc);
+		}
+
+		win->dma_desc_data_start = desc;
+
+		return;
+	}else{
+		/* Link node or group to the end of the DMA chain. */
+		dma_desc_chain_add_tail(desc, win->dma_desc_data_start);
+	}
+
+	dma_desc_wback_inv(desc);
+
+	return;
+}
+
+static void dma_desc_del_from_chain(struct jz_fb_dma_desc *desc)
+{
+	struct jz_fb_win_info *win = desc->win;
+
+	if (!win->dma_desc_data_start) /* Data Chain is empty. */
+		return;
+	
+	/* Must be 1 node / group in Data chain. */
+	if (list_empty(&win->dma_desc_data_start->list))
+		return;
+
+	dma_desc_chain_del(desc);
+
+	return;
+}
+
diff --git a/drivers/video/jz475x/core/framebuffer.c b/drivers/video/jz475x/core/framebuffer.c
new file mode 100644
index 0000000..fae3958
--- /dev/null
+++ b/drivers/video/jz475x/core/framebuffer.c
@@ -0,0 +1,356 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Framebuffer Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+/* ------------ Framebuffer ----------------- */
+static void dump_fb_info_var(struct fb_var_screeninfo *var)
+{
+	DUMP("Framebuffer VAR Info: ");
+	DUMP("=============================================");
+
+	DUMP("var->xres: 0x%08lx.",var->xres);
+	DUMP("var->yres: 0x%08lx.",var->yres);
+	DUMP("var->xres_virtual: 0x%08lx.",var->xres_virtual);
+	DUMP("var->yres_virtual: 0x%08lx.",var->yres_virtual);
+	DUMP("var->xoffset: 0x%08lx.",var->xoffset);
+	DUMP("var->yoffset: 0x%08lx.",var->yoffset);
+	DUMP("var->bits_per_pixel: 0x%08lx.",var->bits_per_pixel);
+	DUMP("var->grayscale: 0x%08lx.",var->grayscale);
+	DUMP("var->nonstd: 0x%08lx.",var->nonstd);
+	DUMP("var->activate: 0x%08lx.",var->activate);
+	DUMP("var->height: 0x%08lx.",var->height);
+	DUMP("var->width: 0x%08lx.",var->width);
+	DUMP("var->accel_flags: 0x%08lx.",var->accel_flags);
+	DUMP("var->pixclock: 0x%08lx.",var->pixclock);
+	DUMP("var->left_margin: 0x%08lx.",var->left_margin);
+	DUMP("var->right_margin: 0x%08lx.",var->right_margin);
+	DUMP("var->upper_margin: 0x%08lx.",var->upper_margin);
+	DUMP("var->lower_margin: 0x%08lx.",var->lower_margin);
+	DUMP("var->hsync_len: 0x%08lx.",var->hsync_len);
+	DUMP("var->vsync_len: 0x%08lx.",var->vsync_len);
+	DUMP("var->sync: 0x%08lx.",var->sync);
+	DUMP("var->vmode: 0x%08lx.",var->vmode);
+	DUMP("var->rotate: 0x%08lx.",var->rotate);
+
+	return;
+}
+
+static void dump_fb_info_fix(struct fb_fix_screeninfo *fix)
+{
+	DUMP("Framebuffer FIX Info: ");
+	DUMP("=============================================");
+
+	DUMP("fix->id: %s.",fix->id);
+
+	DUMP("fix->smem_start: 0x%08lx.",fix->smem_start);
+	DUMP("fix->smem_len: 0x%08lx.",fix->smem_len);
+	DUMP("fix->type: 0x%08lx.",fix->type);
+	DUMP("fix->type_aux: 0x%08lx.",fix->type_aux);
+	DUMP("fix->visual: 0x%08lx.",fix->visual);
+	DUMP("fix->xpanstep: 0x%08lx.",fix->xpanstep);
+	DUMP("fix->ypanstep: 0x%08lx.",fix->ypanstep);
+	DUMP("fix->ywrapstep: 0x%08lx.",fix->ywrapstep);
+	DUMP("fix->line_length: 0x%08lx.",fix->line_length);
+	DUMP("fix->mmio_start: 0x%08lx.",fix->mmio_start);
+	DUMP("fix->mmio_len: 0x%08lx.",fix->mmio_len);
+	DUMP("fix->accel: 0x%08lx.",fix->accel);
+
+	return;
+}
+
+static inline int bpp_to_data_bpp(int bpp)
+{
+	switch (bpp) {
+		case 32:
+		case 16:
+			break;
+
+		case 15:
+			bpp = 16;
+			break;
+
+		default:
+			bpp = -EINVAL;
+	}
+
+	return bpp;
+}
+
+static void *alloc_framebuffer(unsigned long len)
+{
+	void *mem;
+
+	unsigned int page_shift;
+	unsigned long page;
+
+	for (page_shift = 0; page_shift < 12; page_shift++)
+		if ((PAGE_SIZE << page_shift) >= len)
+			break;
+
+	mem = (void *)__get_free_pages(GFP_KERNEL, page_shift);
+	if (!mem) {
+		return NULL;
+	}
+
+	for (page = (unsigned long)mem;
+			page < PAGE_ALIGN((unsigned long)mem + (PAGE_SIZE << page_shift));
+			page += PAGE_SIZE) {
+		SetPageReserved(virt_to_page((void*)page));
+	}
+
+	memset(mem, 0, PAGE_SIZE << page_shift);	
+
+	D("Allocate framebuffer: Real Size: 0x%08lx, Virt: 0x%08lx, Phys: 0%08lx", 
+			PAGE_SIZE << page_shift, (unsigned long)mem, virt_to_phys(mem));
+
+	return mem;
+}
+
+static int free_framebuffer(void *mem)
+{
+	return 0;
+}
+
+/* Add framebuffer to Win Framebuffer Pool. */
+static int add_framebuffer_to_win(struct jz_fb_win_info *win, void *mem)
+{
+	int i;
+
+	D("Called.");
+
+	for (i = 0; i < JZ_FB_NR_MAX_FB_MEM; i++) {
+		if (!win->fb_mem[i]) {
+			win->fb_mem[i] = mem;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int set_drv_framebuffer(struct jz_fb_win_info *win, void *mem)
+{
+	D("Called.");
+
+	win->fb.fix.smem_start = virt_to_phys(mem);
+	win->fb.fix.smem_len = win->fb_mem_len;
+	win->fb.screen_base = (unsigned char *)(((unsigned long)mem&0x1fffffff) | 0xa0000000);
+
+	return 0;
+}
+
+static int alloc_cmap(struct jz_fb_win_info *win, unsigned int bpp)
+{
+	int rv;
+
+	switch (bpp) {
+		case 1:
+			rv = fb_alloc_cmap(&win->fb.cmap, 4, 0);
+			break;
+		case 2:
+			rv = fb_alloc_cmap(&win->fb.cmap, 8, 0);
+			break;
+		case 4:
+			rv = fb_alloc_cmap(&win->fb.cmap, 32, 0);
+			break;
+		case 8:
+
+		default:
+			rv = fb_alloc_cmap(&win->fb.cmap, 256, 0);
+			break;
+	}
+
+	return rv;
+}
+
+static void free_cmap(struct jz_fb_win_info *win) 
+{
+	fb_dealloc_cmap(&win->fb.cmap);
+
+	return;
+}
+
+static struct fb_ops jz_fb_ops;
+
+static int fb_info_set_color(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+
+	D("Called.");
+
+	dump_fb_info_var(var);
+
+	switch (var->bits_per_pixel) {
+		case 1:	/* Mono */
+			fix->visual		= FB_VISUAL_MONO01;
+			fix->line_length	= (var->xres * var->bits_per_pixel) / 8;
+
+			break;
+
+		case 2:	/* Mono */
+			var->red.offset		= 0;
+			var->red.length		= 2;
+			var->green.offset	= 0;
+			var->green.length	= 2;
+			var->blue.offset	= 0;
+			var->blue.length	= 2;
+
+			fix->visual		= FB_VISUAL_PSEUDOCOLOR;
+			fix->line_length	= (var->xres * var->bits_per_pixel) / 8;
+
+			break;
+
+		case 4:	/* PSEUDOCOLOUR */
+			var->red.offset		= 0;
+			var->red.length		= 4;
+			var->green.offset	= 0;
+			var->green.length	= 4;
+			var->blue.offset	= 0;
+			var->blue.length	= 4;
+
+			fix->visual		= FB_VISUAL_PSEUDOCOLOR;
+			fix->line_length	= var->xres / 2;
+
+			break;
+
+		case 8:	/* PSEUDOCOLOUR, 256 */
+			var->red.offset		= 0;
+			var->red.length		= 8;
+			var->green.offset	= 0;
+			var->green.length	= 8;
+			var->blue.offset	= 0;
+			var->blue.length	= 8;
+
+			fix->visual		= FB_VISUAL_PSEUDOCOLOR;
+			fix->line_length	= var->xres;
+
+			break;
+
+		case 15: /* DIRECTCOLOUR, 32k */
+			var->red.offset		= 10;
+			var->red.length		= 5;
+			var->green.offset	= 5;
+			var->green.length	= 5;
+			var->blue.offset	= 0;
+			var->blue.length	= 5;
+
+			fix->visual		= FB_VISUAL_DIRECTCOLOR;
+			fix->line_length	= var->xres_virtual * 2;
+
+			break;
+
+		case 16: /* DIRECTCOLOUR, 64k */
+			var->red.offset		= 11;
+			var->red.length		= 5;
+			var->green.offset	= 5;
+			var->green.length	= 6;
+			var->blue.offset	= 0;
+			var->blue.length	= 5;
+
+			fix->visual		= FB_VISUAL_TRUECOLOR;
+			fix->line_length	= var->xres_virtual * 2;
+
+			break;
+
+		case 17 ... 32:
+			/* DIRECTCOLOUR, 256 */
+			var->bits_per_pixel	= 32;
+
+			var->red.offset		= 16;
+			var->red.length		= 8;
+			var->green.offset	= 8;
+			var->green.length	= 8;
+			var->blue.offset	= 0;
+			var->blue.length	= 8;
+			var->transp.offset  	= 24;
+			var->transp.length 	= 8;
+
+			fix->visual		= FB_VISUAL_TRUECOLOR;
+			fix->line_length	= var->xres_virtual * 4;
+
+			break;
+
+		default:
+			E("BPP %d not support.", var->bits_per_pixel);
+
+			return -EINVAL;
+	}
+
+	D("fix->line_length: 0x%08x.", fix->line_length);
+
+	fb_set_cmap(&info->cmap, info);
+
+	return 0;
+}
+
+/* Fiil FB Info. */
+static int win_fb_info_setup(struct jz_fb_win_info *win)
+{
+	struct jz_fb_ctrl *ctrl = win->ctrl;
+
+	int rv;
+
+	strcpy(win->fb.fix.id, DRV_NAME);
+
+	win->fb.fix.type		   = FB_TYPE_PACKED_PIXELS;
+	win->fb.fix.type_aux		   = 0;
+	win->fb.fix.xpanstep		   = 0;
+	win->fb.fix.ypanstep		   = 1;
+	win->fb.fix.ywrapstep		   = 0;
+	win->fb.fix.accel		   = FB_ACCEL_NONE;
+
+	win->fb.fbops			   = &jz_fb_ops;
+	win->fb.flags			   = FBINFO_FLAG_DEFAULT;
+
+	win->fb.var.nonstd		   = 0;
+	win->fb.var.activate		   = FB_ACTIVATE_NOW;
+	win->fb.var.accel_flags		   = 0;
+	win->fb.var.vmode                  = FB_VMODE_NONINTERLACED;
+
+	win->fb.var.xres                   = WIN_W(win);
+	win->fb.var.yres                   = WIN_H(win);
+	win->fb.var.xres_virtual           = WIN_W(win);
+	win->fb.var.yres_virtual           = WIN_H(win);
+	win->fb.var.bits_per_pixel	   = WIN_BPP(win);
+	win->fb.var.xoffset                = 0;
+	win->fb.var.yoffset                = 0;
+
+	win->fb.var.pixclock               = ctrl->pixclock;
+
+	win->fb.var.left_margin            = 0;
+	win->fb.var.right_margin           = 0;
+	win->fb.var.upper_margin           = 0;
+	win->fb.var.lower_margin           = 0;
+	win->fb.var.hsync_len              = 0;
+	win->fb.var.vsync_len              = 0;
+	win->fb.var.sync                   = 0;
+
+	win->fb.pseudo_palette		   = (void *)(win + 1);
+
+	rv = fb_info_set_color(&win->fb);
+	if (rv) {
+		return rv;
+	}
+
+	return rv;
+}
diff --git a/drivers/video/jz475x/core/hw.c b/drivers/video/jz475x/core/hw.c
new file mode 100644
index 0000000..6ce59e8
--- /dev/null
+++ b/drivers/video/jz475x/core/hw.c
@@ -0,0 +1,632 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * HW Controller Routines.
+ *
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+static int jz_fb_hw_bpp_to_palette_size(unsigned int bpp)
+{
+	int size;
+
+	/* More details can be found in LCDC Spec. */
+	switch (bpp) {
+		case 1:
+			size = 1;	/* 1 word. */
+			break;
+		case 2:
+			size = 2;	/* 2 words. */
+			break;
+		case 4:
+			size = 8;	/* 8 words. */
+			break;
+		case 8:
+			size = 128;	/* 128 words. */
+			break;
+
+		default:
+			return -1;
+	}
+
+	return size * 4;	
+}
+
+static void jz_fb_hw_ot_power_on(struct jz_fb_ctrl *ctrl, int force)
+{
+	struct jz_fb_ot_info *ot = ctrl->ot;
+
+	D("Called.");
+	
+	if (!force && ot->power) {
+		D("Already Power ON.");
+		return;
+	}
+
+	if (ot) {
+		if (ot->ops->start)
+			ot->ops->start(ot);
+
+		ot->power = 1;
+	}else{
+		E("No output attached.");
+	}
+	
+	return;
+}
+
+static void jz_fb_hw_ot_power_off(struct jz_fb_ctrl *ctrl, int force)
+{
+	struct jz_fb_ot_info *ot = ctrl->ot;
+
+	D("Called.");
+	
+	if (!force && !ot->power) {
+		D("Already Power Down.");
+		return;
+	}
+
+	if (ot) {
+		if (ot->ops->stop)
+			ot->ops->stop(ot);
+
+		ot->power = 0;
+	}else{
+		E("No output attached.");
+	}
+
+	return;
+}
+
+static void jz_fb_hw_ot_enable(struct jz_fb_ctrl *ctrl, int force)
+{
+	struct jz_fb_ot_info *ot = ctrl->ot;
+	
+	unsigned int delay;
+
+	D("Called.");
+	
+	if (!force && ot->state) {
+		D("Already enable.");
+		return;
+	}
+
+	if (ot) {
+		delay = ot->config->enable_delay_ms;
+
+		if (ot->ops->enable) {
+			if (delay)
+				mdelay(delay);
+
+			ot->ops->enable(ot);
+		}
+
+		ot->state = 1;
+	}else{
+		E("No output attached.");
+	}
+
+	return;
+}
+
+static void jz_fb_hw_ot_disable(struct jz_fb_ctrl *ctrl, int force)
+{
+	struct jz_fb_ot_info *ot = ctrl->ot;
+
+	D("Called.");
+	
+	if (!force && !ot->state) {
+		D("Already Disable.");
+		return;
+	}
+
+	if (ot) {
+		if (ot->ops->disable) 
+			ot->ops->disable(ot);
+
+		ot->state = 0;
+	}else{
+		E("No output attached.");
+	}
+
+	return;
+}
+
+static void jz_fb_hw_ctrl_enable(struct jz_fb_ctrl *ctrl, int force)
+{
+	D("Called.");
+	
+	if (!force && ctrl->state) {
+		D("Already Enable.");
+		return;
+	}
+
+	REG_LCD_STATE = 0; /* clear lcdc status */
+
+	__lcd_clr_dis();
+	__lcd_set_ena(); /* enable lcdc */
+	
+	ctrl->state = 1;
+
+	return;
+}
+
+static void jz_fb_hw_ctrl_disable(struct jz_fb_ctrl *ctrl, int force)
+{
+	D("Called.");
+
+	if (!force && !ctrl->state) {
+		D("Already Disable.");
+		return;
+	}
+
+	if (ctrl->ot->use_quick_disable) {
+		D("Quick Disable");
+		__lcd_clr_ena();
+	}else {
+		/* when CPU main freq is 336MHz,wait for 16ms */
+		int cnt = 336000 * 16;
+
+		__lcd_set_dis(); /* regular disable */
+		while(!__lcd_disable_done() && cnt) {
+			cnt--;
+		}
+
+		D("Normal Disable");
+		if (cnt == 0)
+			E("LCD disable timeout! REG_LCD_STATE=0x%08xx", REG_LCD_STATE);
+
+		REG_LCD_STATE &= ~LCD_STATE_LDD;
+	}
+
+	ctrl->state = 0;
+
+	return;
+}
+
+static void jz_fb_hw_set_panel_info(struct jz_fb_ctrl *ctrl)
+{
+	struct jz_fb_panel_info *panel = ctrl->ot->config->panel;
+	struct jz_fb_reg_info *reg = &ctrl->ot->reg_info;
+
+	D("Called.");
+
+	/* Collect Panel Config. */
+	reg->lcd_cfg |= panel->lcd_cfg;
+	reg->lcd_ctrl |= panel->lcd_ctrl;
+
+	switch (panel->lcd_cfg & LCD_CFG_MODE_MASK ) {
+		case LCD_CFG_MODE_GENERIC_TFT:
+		case LCD_CFG_MODE_INTER_CCIR656:
+		case LCD_CFG_MODE_NONINTER_CCIR656:
+		default:
+			reg->lcd_vat = (((panel->blw + panel->w + panel->elw + panel->hsw)) << 16) | (panel->vsw + panel->bfw + panel->h + panel->efw);
+			reg->lcd_dah = ((panel->hsw + panel->blw) << 16) | (panel->hsw + panel->blw + panel->w);
+			reg->lcd_dav = ((panel->vsw + panel->bfw) << 16) | (panel->vsw + panel->bfw + panel->h);
+			reg->lcd_hsync = (0 << 16) | panel->hsw;
+			reg->lcd_vsync = (0 << 16) | panel->vsw;
+			break;
+	}
+
+	return;
+}
+
+static void jz_fb_hw_set_ot_info(struct jz_fb_ctrl *ctrl)
+{
+	struct jz_fb_reg_info *reg = &ctrl->ot->reg_info;
+	
+	D("Called.");
+	
+	/* Use RGB -> YUV? */
+	if (ctrl->ot->use_rgb_to_yuv) {
+		D("Use RGB->YUV.");
+
+		reg->lcd_rgbc |= LCD_RGBC_YCC;
+	}
+
+	/* Set Panel Background Color. */	
+	reg->lcd_bgc = ctrl->ot->config->background_color;
+
+	return;
+}
+
+static int jz_fb_hw_set_win_bpp(struct jz_fb_win_info *win, unsigned int bpp)
+{
+	struct jz_fb_reg_info *reg = &win->ctrl->ot->reg_info;
+
+	D("Called.");
+
+	if (win->index == 0) {
+		reg->lcd_ctrl &= ~LCD_CTRL_BPP_MASK;
+
+		if (bpp == 1)
+			reg->lcd_ctrl |= LCD_CTRL_BPP_1;
+		else if (bpp == 2)
+			reg->lcd_ctrl |= LCD_CTRL_BPP_2;
+		else if (bpp == 4)
+			reg->lcd_ctrl |= LCD_CTRL_BPP_4;
+		else if (bpp == 8)
+			reg->lcd_ctrl |= LCD_CTRL_BPP_8;
+		else if (bpp == 15)
+			reg->lcd_ctrl |= LCD_CTRL_BPP_16 | LCD_CTRL_RGB555;
+		else if (bpp == 16)
+			reg->lcd_ctrl |= LCD_CTRL_BPP_16 | LCD_CTRL_RGB565;
+		else if (bpp > 16 && bpp <= 32) 
+			reg->lcd_ctrl |= LCD_CTRL_BPP_18_24;
+		else
+			return -1;
+
+	}else if (win->index == 1) {
+		reg->lcd_osdctrl &= ~LCD_CTRL_BPP_MASK;
+
+		if (bpp == 15)
+			reg->lcd_osdctrl |= LCD_CTRL_BPP_16 | LCD_CTRL_RGB555;
+		else if (bpp == 16)
+			reg->lcd_osdctrl |= LCD_CTRL_BPP_16 | LCD_CTRL_RGB565;
+		else if (bpp > 16 && bpp <= 32) 
+			reg->lcd_osdctrl |= LCD_CTRL_BPP_18_24;
+		else
+			return -1;
+	}
+
+	return 0;
+}
+
+static void jz_fb_hw_set_win_enable(struct jz_fb_win_info *win, int enable)
+{
+	struct jz_fb_reg_info *reg = &win->ctrl->ot->reg_info;
+	
+	D("Called.");
+
+	if (win->index == 0) {
+		if (enable) 
+			reg->lcd_osdc |= LCD_OSDC_F0EN;
+		else
+			reg->lcd_osdc &= ~LCD_OSDC_F0EN; 
+	}else if (win->index == 1) {
+		if (enable)
+			reg->lcd_osdc |= LCD_OSDC_F1EN; 
+		else
+			reg->lcd_osdc &= ~LCD_OSDC_F1EN;
+	}
+	
+	return;
+}
+
+static void jz_fb_hw_set_win_area(struct jz_fb_win_info *win, unsigned int x,
+	unsigned int y, unsigned int w, unsigned int h)
+{
+	struct jz_fb_reg_info *reg = &win->ctrl->ot->reg_info;
+	
+	D("Called.");
+
+	if (win->index == 0) {
+		reg->lcd_xyp0 = HW_AREA_POS(x, y);
+		reg->lcd_size0 = HW_AREA_SIZE(w, h);
+	}else if (win->index == 1) {
+		reg->lcd_xyp1 = HW_AREA_POS(x, y);
+		reg->lcd_size1 = HW_AREA_SIZE(w, h);
+	}
+
+	return;
+}
+
+static void jz_fb_hw_set_dma_desc_format(struct jz_fb_ctrl *ctrl)
+{
+	struct jz_fb_reg_info *reg = &ctrl->ot->reg_info;	
+
+#ifdef JZ_FB_8WORD_DMA_DESC
+	reg->lcd_cfg |= LCD_CFG_NEWDES;
+#else
+	reg->lcd_cfg &= ~LCD_CFG_NEWDES;
+#endif
+
+	return;
+}
+
+static void jz_fb_hw_set_win_info(struct jz_fb_ctrl *ctrl)
+{
+	struct jz_fb_win_info *win;
+	struct jz_fb_win_attr_info *wa;
+	
+	struct jz_fb_reg_info *reg = &ctrl->ot->reg_info;	
+
+	int i;
+	
+	D("Called.");
+	
+	/* REVIST: Can we leave OSDEN set when F0EN and F1EN is disabled? */
+	reg->lcd_osdc |= LCD_OSDC_OSDEN;
+	
+	for (i = 0; i < JZ_FB_NR_MAX_FG; i++) {
+		win = ctrl->win[i];
+		wa = &win->attr;
+
+		jz_fb_hw_set_win_enable(win, wa->enable);	
+		jz_fb_hw_set_win_area(win, wa->x, wa->y, wa->w, wa->h);
+		jz_fb_hw_set_win_bpp(win, wa->bpp);
+	}
+	
+	return;
+}
+
+static inline void dump_registers(void)
+{
+	DUMP("Dump LCDC Registers: ");
+	DUMP("======================================");
+	DUMP("REG_LCD_CFG:\t0x%08x", REG_LCD_CFG);
+	DUMP("REG_LCD_CTRL:\t0x%08x", REG_LCD_CTRL);
+	DUMP("REG_LCD_STATE:\t0x%08x", REG_LCD_STATE);
+	DUMP("REG_LCD_OSDC:\t0x%08x", REG_LCD_OSDC);
+	DUMP("REG_LCD_OSDCTRL:\t0x%08x", REG_LCD_OSDCTRL);
+	DUMP("REG_LCD_OSDS:\t0x%08x", REG_LCD_OSDS);
+	DUMP("REG_LCD_BGC:\t0x%08x", REG_LCD_BGC);
+	DUMP("REG_LCD_KEK0:\t0x%08x", REG_LCD_KEY0);
+	DUMP("REG_LCD_KEY1:\t0x%08x", REG_LCD_KEY1);
+	DUMP("REG_LCD_ALPHA:\t0x%08x", REG_LCD_ALPHA);
+	DUMP("REG_LCD_IPUR:\t0x%08x", REG_LCD_IPUR);
+	DUMP("REG_LCD_VAT:\t0x%08x", REG_LCD_VAT);
+	DUMP("REG_LCD_DAH:\t0x%08x", REG_LCD_DAH);
+	DUMP("REG_LCD_DAV:\t0x%08x", REG_LCD_DAV);
+	DUMP("REG_LCD_XYP0:\t0x%08x", REG_LCD_XYP0);
+	DUMP("REG_LCD_XYP1:\t0x%08x", REG_LCD_XYP1);
+	DUMP("REG_LCD_SIZE0:\t0x%08x", REG_LCD_SIZE0);
+	DUMP("REG_LCD_SIZE1:\t0x%08x", REG_LCD_SIZE1);
+	DUMP("REG_LCD_RGBC\t0x%08x", REG_LCD_RGBC);
+	DUMP("REG_LCD_VSYNC:\t0x%08x", REG_LCD_VSYNC);
+	DUMP("REG_LCD_HSYNC:\t0x%08x", REG_LCD_HSYNC);
+	DUMP("REG_LCD_PS:\t0x%08x", REG_LCD_PS);
+	DUMP("REG_LCD_CLS:\t0x%08x", REG_LCD_CLS);
+	DUMP("REG_LCD_SPL:\t0x%08x", REG_LCD_SPL);
+	DUMP("REG_LCD_REV:\t0x%08x", REG_LCD_REV);
+	DUMP("REG_LCD_IID:\t0x%08x", REG_LCD_IID);
+	DUMP("REG_LCD_DA0:\t0x%08x", REG_LCD_DA0);
+	DUMP("REG_LCD_SA0:\t0x%08x", REG_LCD_SA0);
+	DUMP("REG_LCD_FID0:\t0x%08x", REG_LCD_FID0);
+	DUMP("REG_LCD_CMD0:\t0x%08x", REG_LCD_CMD0);
+	DUMP("REG_LCD_OFFS0:\t0x%08x", REG_LCD_OFFS0);
+	DUMP("REG_LCD_PW0:\t0x%08x", REG_LCD_PW0);
+	DUMP("REG_LCD_CNUM0:\t0x%08x", REG_LCD_CNUM0);
+	DUMP("REG_LCD_DESSIZE0:\t0x%08x", REG_LCD_DESSIZE0);
+	DUMP("REG_LCD_DA1:\t0x%08x", REG_LCD_DA1);
+	DUMP("REG_LCD_SA1:\t0x%08x", REG_LCD_SA1);
+	DUMP("REG_LCD_FID1:\t0x%08x", REG_LCD_FID1);
+	DUMP("REG_LCD_CMD1:\t0x%08x", REG_LCD_CMD1);
+	DUMP("REG_LCD_OFFS1:\t0x%08x", REG_LCD_OFFS1);
+	DUMP("REG_LCD_PW1:\t0x%08x", REG_LCD_PW1);
+	DUMP("REG_LCD_CNUM1:\t0x%08x", REG_LCD_CNUM1);
+	DUMP("REG_LCD_DESSIZE1:\t0x%08x", REG_LCD_DESSIZE1);
+	DUMP("==================================");
+	DUMP("REG_LCD_VSYNC:\t%d:%d", REG_LCD_VSYNC>>16, REG_LCD_VSYNC&0xfff);
+	DUMP("REG_LCD_HSYNC:\t%d:%d", REG_LCD_HSYNC>>16, REG_LCD_HSYNC&0xfff);
+	DUMP("REG_LCD_VAT:\t%d:%d", REG_LCD_VAT>>16, REG_LCD_VAT&0xfff);
+	DUMP("REG_LCD_DAH:\t%d:%d", REG_LCD_DAH>>16, REG_LCD_DAH&0xfff);
+	DUMP("REG_LCD_DAV:\t%d:%d", REG_LCD_DAV>>16, REG_LCD_DAV&0xfff);
+	DUMP("==================================");
+	/* Smart LCD Controller Resgisters */
+	DUMP("REG_SLCD_CFG:\t0x%08x", REG_SLCD_CFG);
+	DUMP("REG_SLCD_CTRL:\t0x%08x", REG_SLCD_CTRL);
+	DUMP("REG_SLCD_STATE:\t0x%08x", REG_SLCD_STATE);
+	DUMP("==================================");
+	/* TVE Controller Resgisters */
+	DUMP("REG_TVE_CTRL:\t0x%08x", REG_TVE_CTRL);
+	DUMP("REG_TVE_FRCFG:\t0x%08x", REG_TVE_FRCFG);
+	DUMP("REG_TVE_SLCFG1:\t0x%08x", REG_TVE_SLCFG1);
+	DUMP("REG_TVE_SLCFG2:\t0x%08x", REG_TVE_SLCFG2);
+	DUMP("REG_TVE_SLCFG3:\t0x%08x", REG_TVE_SLCFG3);
+	DUMP("REG_TVE_LTCFG1:\t0x%08x", REG_TVE_LTCFG1);
+	DUMP("REG_TVE_LTCFG2:\t0x%08x", REG_TVE_LTCFG2);
+	DUMP("REG_TVE_CFREQ:\t0x%08x", REG_TVE_CFREQ);
+	DUMP("REG_TVE_CPHASE:\t0x%08x", REG_TVE_CPHASE);
+	DUMP("REG_TVE_CBCRCFG:\t0x%08x", REG_TVE_CBCRCFG);
+	DUMP("REG_TVE_WSSCR:\t0x%08x", REG_TVE_WSSCR);
+	DUMP("REG_TVE_WSSCFG1:\t0x%08x", REG_TVE_WSSCFG1);
+	DUMP("REG_TVE_WSSCFG2:\t0x%08x", REG_TVE_WSSCFG2);
+	DUMP("REG_TVE_WSSCFG3:\t0x%08x", REG_TVE_WSSCFG3);
+	DUMP("==================================");
+	
+	return;
+}
+
+void dump_reg_info(struct jz_fb_reg_info *reg)
+{
+	DUMP("Dump reg_info: ");
+	DUMP("======================================");
+
+	DUMP("reg->lcd_cfg: 0x%08lx.", reg->lcd_cfg);	
+	DUMP("reg->lcd_ctrl: 0x%08lx.", reg->lcd_ctrl);	
+	DUMP("reg->lcd_vat: 0x%08lx.", reg->lcd_vat);	
+	DUMP("reg->lcd_dah: 0x%08lx.", reg->lcd_dah);	
+	DUMP("reg->lcd_dav: 0x%08lx.", reg->lcd_dav);	
+	DUMP("reg->lcd_hsync: 0x%08lx.", reg->lcd_hsync);	
+	DUMP("reg->lcd_vsync: 0x%08lx.", reg->lcd_vsync);	
+	DUMP("reg->lcd_bgc: 0x%08lx.", reg->lcd_bgc);
+	DUMP("reg->lcd_da0: 0x%08lx.", reg->lcd_da0);
+	DUMP("reg->lcd_da1: 0x%08lx.", reg->lcd_da1);
+
+	return;
+}
+
+static void jz_fb_hw_write_reg(struct jz_fb_ctrl *ctrl)
+{
+	struct jz_fb_reg_info *reg = &ctrl->ot->reg_info;	
+	
+	D("Called.");
+
+	/* TODO:
+	   Use flags in reg_info to divide function blocks regs IO.
+	*/
+
+	REG_LCD_CFG	= reg->lcd_cfg; /* LCDC Configure Register */
+	REG_LCD_CTRL	= reg->lcd_ctrl; /* LCDC Controll Register */
+	REG_LCD_OSDC 	= reg->lcd_osdc; /* F0, F1, alpha, */
+	REG_LCD_OSDCTRL = reg->lcd_osdctrl; /* IPUEN, bpp */
+	REG_LCD_BGC  	= reg->lcd_bgc;
+	REG_LCD_KEY0 	= reg->lcd_key0;
+	REG_LCD_KEY1 	= reg->lcd_key1;
+	REG_LCD_ALPHA 	= reg->lcd_alpha;
+	REG_LCD_IPUR 	= reg->lcd_ipur;
+	REG_LCD_RGBC  	= reg->lcd_rgbc;
+	REG_LCD_VAT	= reg->lcd_vat;
+	REG_LCD_DAH	= reg->lcd_dah;
+	REG_LCD_DAV	= reg->lcd_dav;
+	REG_LCD_VSYNC	= reg->lcd_vsync;
+	REG_LCD_HSYNC	= reg->lcd_hsync;
+	REG_LCD_PS	= reg->lcd_ps;
+	REG_LCD_REV	= reg->lcd_rev;
+	REG_LCD_XYP0	= reg->lcd_xyp0;
+	REG_LCD_XYP1	= reg->lcd_xyp1;
+	REG_LCD_SIZE0	= reg->lcd_size0;
+	REG_LCD_SIZE1	= reg->lcd_size1;
+	REG_LCD_DA0	= reg->lcd_da0;
+	REG_LCD_DA1	= reg->lcd_da1;
+
+	dump_registers();
+
+	return;
+}
+
+static void jz_fb_hw_set_pixclock(struct jz_fb_ctrl *ctrl)
+{
+	struct jz_fb_ot_info *ot = ctrl->ot;
+	struct jz_fb_panel_info *panel = ot->config->panel;
+
+	unsigned int pixclock, refresh_rate;
+	unsigned int w, h;
+
+	unsigned int v;
+
+	D("Called.");
+
+	refresh_rate = panel->fclk;
+
+	if (ot->use_tve) {
+		pixclock = 27000000;
+	}else{
+		if ((panel->lcd_cfg & LCD_CFG_MODE_MASK) == LCD_CFG_MODE_SERIAL_TFT) {
+			/* serial mode: Hsync period = 3*Width_Pixel */
+			w = (panel->w * 3 + panel->hsw + panel->elw + panel->blw);
+			h = (panel->h + panel->vsw + panel->efw + panel->bfw);
+
+			pixclock = w * h * refresh_rate;
+		}else {
+			w = (panel->w + panel->hsw + panel->elw + panel->blw);
+			h = (panel->h + panel->vsw + panel->efw + panel->bfw);
+
+			pixclock = w * h * refresh_rate;
+		}
+	}
+
+	ctrl->pixclock = pixclock;
+
+	/* ------------ HW: Set LCD Controller ---------------- */
+	__cpm_stop_lcd();
+
+	if (ot->use_tve) {
+		REG_CPM_LPCDR |= CPM_LPCDR_LTCS;
+		__cpm_select_pixclk_tve();
+	}else{
+		REG_CPM_LPCDR &= ~CPM_LPCDR_LTCS;
+		__cpm_select_pixclk_lcd();
+	}
+	
+	v = __cpm_get_pllout2() / pixclock;
+	v--;
+
+	__cpm_set_pixdiv(v);
+
+#if defined(CONFIG_SOC_JZ4750) /* Jz4750D don't use LCLK */
+	v = pixclock * 3 ;	/* LCDClock > 2.5*Pixclock */
+
+	v = (__cpm_get_pllout()) / v;
+	if (v > 0x1f) {
+		printk("lcd clock divide is too large, set it to 0x1f\n");
+		v = 0x1f;
+	}
+
+	__cpm_set_ldiv(v);
+#endif
+
+	REG_CPM_CPCCR |= CPM_CPCCR_CE; /* update divide */
+
+	jz_clocks.pixclk = __cpm_get_pixclk();
+
+#if defined(CONFIG_SOC_JZ4750) /* Jz4750D don't use LCLK */
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	I("LCD Controller Clock: %dMHz.", jz_clocks.lcdclk / 1000 / 1000);
+#endif
+
+	I("Pixel Clock: %dMHz.", pixclock / 1000 / 1000);
+
+	__cpm_start_lcd();
+
+	mdelay(1);
+
+	return;
+}
+
+static void jz_fb_hw_setup(struct jz_fb_ctrl *ctrl)
+{
+	struct jz_fb_ot_info *ot = ctrl->ot;
+	struct jz_fb_win_info *win;
+
+	int i, j;
+	
+	D("Called.");
+	
+	memset(&ot->reg_info, 0, (sizeof(struct jz_fb_reg_info)));
+
+	/* Step 1: Set Pixel Clock. */
+	jz_fb_hw_set_pixclock(ctrl);
+
+	/* Step 2: Build DMA Descriptor Chain. */
+	jz_fb_hw_set_dma_desc_format(ctrl);
+
+	for (i = 0; i < JZ_FB_NR_MAX_FG; i++) {
+		win = ctrl->win[i];
+
+		/* Prepare DMA Descriptors. */
+		ot->desc_ops->cleanup(win);
+		ot->desc_ops->setup(win);
+		
+		/* Attach All Framebuffer Memory Blocks. */
+		for (j = 0; j < JZ_FB_NR_MAX_FB_MEM; j++) {
+			if (win->fb_mem[j]) {
+				D("Win %d: Attach Framebufer : 0x%p.", i, win->fb_mem[j]);
+
+				ot->desc_ops->attach(win, win->fb_mem[j]);
+			}
+		}
+	}
+
+	/* Step 3: Set Panel Info. */
+	jz_fb_hw_set_panel_info(ctrl);
+	
+	/* Step 4: Set OT Info. */
+	jz_fb_hw_set_ot_info(ctrl);
+
+	/* Step 5: Set All Win Info. */
+	jz_fb_hw_set_win_info(ctrl);
+	
+	/* Step 6: Write all result to HW. */
+	jz_fb_hw_write_reg(ctrl);	
+	
+	/* Done. */
+	return;
+}
+
diff --git a/drivers/video/jz475x/core/ot.c b/drivers/video/jz475x/core/ot.c
new file mode 100644
index 0000000..a6053c8
--- /dev/null
+++ b/drivers/video/jz475x/core/ot.c
@@ -0,0 +1,167 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Output Control Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+struct jz_fb_ot_scan_info {
+	unsigned int max_w;
+	unsigned int max_h;
+	unsigned int max_bpp;
+};
+
+static inline unsigned int bpp_to_ctrl_bpp(int bpp)
+{
+	switch (bpp) {
+		case 15:
+		case 16:
+			break;
+
+		case 17 ... 32:
+			bpp = 32;
+
+			break;
+
+		default:
+			E("BPP (%d) not support, Set BPP 32.\n", bpp);
+
+			bpp = 32;
+
+			break;
+	}
+
+	return bpp;
+}
+
+static void jz_fb_ot_scan(struct jz_fb_ctrl *ctrl, 
+				struct jz_fb_ot_scan_info *info)
+{	
+	struct jz_fb_ot_info *o;
+	jz_fb_ot_init_t *init;
+
+	struct jz_fb_win_attr_info *a;
+
+	unsigned int n = sizeof(jz_fb_ots) / sizeof(struct jz_fb_ot_info *);
+
+	unsigned int i, j;
+	unsigned int v;
+	
+	info->max_w = info->max_h = info->max_bpp = 0;
+
+	for (i = 0; i < n; i++) {
+		o = jz_fb_ots[i];
+		init = jz_fb_ot_inits[i];
+
+		/* Step 1: OT ID & Parent. */
+		o->id = i;		
+		o->ctrl = ctrl;
+		
+		/* Step 2: OT Initializer. */
+		init(o);
+		
+		/* Step 3: Glue & Config. */
+		for (j = 0; j < JZ_FB_NR_MAX_FG; j++) {
+			a = &o->config->win_init_config[j];
+
+			/* Win BPP Glue.*/
+			a->bpp = bpp_to_ctrl_bpp(a->bpp);
+			
+			/* Load INIT config as first runtime config. */
+			o->config->win_runtime_config[j] = *a;
+		}
+		
+		/* Step 4: Collect Max Panel Info. */
+		v = o->config->panel->w;
+		if (info->max_w < v)
+			info->max_w = v;
+
+		v = o->config->panel->h;
+		if (info->max_h < v)
+			info->max_h = v;
+
+		/* Max Win BPP Glue. */
+		v = o->config->max_win_bpp;
+
+		o->config->max_win_bpp = bpp_to_ctrl_bpp(v);
+
+		if (info->max_bpp < v)
+			info->max_bpp = v;
+
+		D("Output: %s ID: %d Current Max w: %u, h: %u, bpp: %u.", 
+				o->name, o->id, info->max_w, 
+				info->max_h, info->max_bpp);
+
+		I("Found Output: %s, ID: %d.", o->name, o->id);
+	}
+	
+	return;
+}
+
+static int jz_fb_ot_load_runtime_config(struct jz_fb_ot_info *ot)
+{
+	struct jz_fb_win_info *win;
+	struct jz_fb_win_attr_info *a = ot->config->win_runtime_config;
+
+	int i;
+	
+	D("Called.");
+
+	for (i = 0; i < JZ_FB_NR_MAX_FG; i++) {
+		win = ot->ctrl->win[i];
+		D("Attr: enable: %d, w: %d, h: %d, x: %d, y: %d, bpp: %d.",
+				a->enable, a->w, a->h, a->x, a->y, a->bpp);
+
+		jz_fb_win_set_attr(win, a + i);
+	}
+	
+	return 0;
+}
+
+static int jz_fb_ot_set_current(struct jz_fb_ot_info *ot)
+{
+	struct jz_fb_ctrl *ctrl = &jz_fb_ctrl;
+	struct jz_fb_win_info *win;
+
+	int i;
+
+	jz_fb_hw_ot_disable(ctrl, 1);
+	jz_fb_hw_ctrl_disable(ctrl, 1);
+	jz_fb_hw_ot_power_off(ctrl, 1);
+
+	ctrl->ot = ot;
+
+	/* Load OT Runtime Config. */			
+	jz_fb_ot_load_runtime_config(ot);
+	
+	jz_fb_hw_setup(ctrl);
+
+	for (i = 0; i < JZ_FB_NR_MAX_FG; i++) {
+		win = ctrl->win[i];
+
+		/* Update FB_INFO. */
+		win_fb_info_setup(win);
+	}
+	
+	jz_fb_hw_ot_power_on(ctrl, 1);
+	jz_fb_hw_ctrl_enable(ctrl, 1);
+	jz_fb_hw_ot_enable(ctrl, 1);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/core/win.c b/drivers/video/jz475x/core/win.c
new file mode 100644
index 0000000..26343c4
--- /dev/null
+++ b/drivers/video/jz475x/core/win.c
@@ -0,0 +1,179 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Foreground Control Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+static void update_fb_data_size(struct jz_fb_win_info *win)
+{
+	struct jz_fb_win_attr_info *wa = &win->attr;
+	
+	D("Called.");
+
+	D("w: 0x%08x, h: 0x%08x, bpp: 0x%08x.", wa->w, wa->h, wa->bpp);
+
+	win->fb_line_len = dma_align_size(wa->w * bpp_to_data_bpp(wa->bpp) / 8);
+	win->fb_frame_len = win->fb_line_len * wa->h;
+	
+	D("win->fb_line_len: 0x%08x, win->fb_frame_len: 0x%08x",
+		win->fb_line_len, win->fb_frame_len);	
+	return;
+}
+
+static struct jz_fb_win_info *alloc_win(unsigned int w, unsigned int h, unsigned int bpp)
+{
+ 	struct jz_fb_win_info *win;
+
+	void *fb_mem;	
+	
+	unsigned long status = 0;
+
+	int rv;	
+	
+	D("Called.");
+
+	/* Step 1: FB Info. */
+	win = kzalloc(sizeof(struct jz_fb_win_info) + sizeof(u32) * 16, GFP_KERNEL);
+	if (!win) {
+		E("Failed to allocate framebuffer info.");
+		return NULL;
+	}
+	
+	set_bit(0, &status);
+
+	/* Step 2: DMA Palette and Descriptors. */
+	win->misc_mem_start = (void *)__get_free_page(GFP_KERNEL);
+	if (!win->misc_mem_start) {
+		E("Faield to allocate memory for palette and descriptor.");
+		goto err;
+	}
+	
+	D("Misc MEM start: Virt: 0x%p, Phys: 0x%08lx.", win->misc_mem_start,
+		virt_to_phys(win->misc_mem_start));	
+
+	set_bit(1, &status);
+
+	win->misc_mem_cur = win->misc_mem_start;	
+
+	/* Step 3: DMA Palette. */
+	win->dma_palette = win->misc_mem_cur;
+
+	D("DMA Palette MEM Start: Virt: 0x%p, Phys: 0x%08lx.", win->misc_mem_cur, 
+		virt_to_phys(win->misc_mem_cur));
+
+	win->misc_mem_cur += dma_align_size(PALETTE_SIZE);
+
+	D("DMA Palette MEM Size: 0x%lx", dma_align_size(PALETTE_SIZE));	
+
+	/* Step 4: DMA Descriptor Pool. */
+	D("DMA Descriptor Pool Start: Virt: 0x%p, Phys: 0x%08lx.", win->misc_mem_cur,
+		virt_to_phys(win->misc_mem_cur));	
+
+	win->dma_desc_pool = win->misc_mem_cur;
+	win->misc_mem_cur += dma_desc_pool_init(win);
+
+	/* Step 5: Framebuffer. */
+	bpp = bpp_to_data_bpp(bpp);
+
+	win->fb_mem_len = ((w * bpp + 7) >> 3) * h;
+	
+	fb_mem = alloc_framebuffer(win->fb_mem_len);
+	if (!fb_mem) {
+		E("Failed to allocate framebuffer.");
+		goto err;
+	}
+	
+	D("Framebuffer MEM Block Size: 0x%08x.", win->fb_mem_len);
+
+	set_bit(2, &status);
+
+	rv = add_framebuffer_to_win(win, fb_mem);
+	if (rv) {
+		E("Framebuffer Pool is Full. ");
+		goto err;
+	}
+	
+	/* Always set first block as DRV Framebuffer. */
+	set_drv_framebuffer(win, fb_mem);
+
+	rv = alloc_cmap(win, bpp);
+	if (rv) {
+		E("Failed to allocate color map.");
+		goto err;
+	}
+
+	return win;
+
+err:	
+	if (test_bit(2, &status))
+		free_framebuffer(win);
+	
+	if (test_bit(1, &status))
+		__free_page(win->misc_mem_start);
+
+	if (test_bit(0, &status)) 
+		kfree(win);
+
+	return NULL;	
+}
+
+static void free_win(struct jz_fb_win_info *win)
+{
+	int i;
+
+	D("Called.");
+	
+	/* Free all framebuffers in WIN. */
+	for (i = 0; i < JZ_FB_NR_MAX_FB_MEM; i++) {
+		if (win->fb_mem[i]) {
+			free_framebuffer(win->fb_mem[i]);
+		}
+	}
+	
+	/* Free color maps. */
+	free_cmap(win);
+	
+	/* Free Misc Memory. */
+	__free_page(win->misc_mem_start);
+	
+	/* Free Win. */
+	kfree(win);
+
+	return;
+}
+
+static int jz_fb_win_set_attr(struct jz_fb_win_info *win, struct jz_fb_win_attr_info *attr)
+{
+	D("Called.");
+
+	memcpy(&win->attr, attr, sizeof(struct jz_fb_win_attr_info));
+
+	update_fb_data_size(win);
+	
+	return 0;
+}
+
+static inline int jz_fb_win_active_attr(struct jz_fb_win_info *win)
+{
+	D("Called.");
+
+	/* Not implentmend yet. */
+	return 0;
+}
diff --git a/drivers/video/jz475x/drv/ctrl-drv.c b/drivers/video/jz475x/drv/ctrl-drv.c
new file mode 100644
index 0000000..06ee49b
--- /dev/null
+++ b/drivers/video/jz475x/drv/ctrl-drv.c
@@ -0,0 +1,122 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Control Driver.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#define CTRL_DRV_POSTFIX "-ctrl"
+
+static inline struct jz_fb_ot_info *minor_to_ot(int minor)
+{
+	struct jz_fb_ot_info *ot;
+
+	unsigned int i;
+
+	D("Called.");
+
+	for (i = 0; i < sizeof(jz_fb_ots) / sizeof(struct jz_fb_ot_info *); i++) {
+		ot = jz_fb_ots[i];
+		if (ot->miscdev->minor == minor) {
+			D("Output: %s is located.", ot->name);
+			return ot;
+		}
+	}
+
+	return NULL;
+}
+
+static int ctrl_drv_ioctl(struct inode *inode, 
+		struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct jz_fb_ot_info *ot;
+
+	int rv;
+
+	D("Called.");	
+
+	ot = minor_to_ot(iminor(inode));
+	if (!ot) {
+		E("Miscdevice (minor: %d) not found.", iminor(inode));
+		return -ENODEV;
+	}
+	
+	mutex_lock(&ot->ctrl_drv_lock);
+
+	/* Dispatch control to specific output. */
+	rv = ot->ops->control(ot, (void __user *)arg);
+
+	mutex_unlock(&ot->ctrl_drv_lock);
+
+	return rv;
+}
+
+static const struct file_operations ctrl_drv_misc_fops = {
+	.ioctl = ctrl_drv_ioctl,
+};
+
+static int ctrl_drv_setup(struct jz_fb_ot_info *ot)
+{
+	struct miscdevice *dev;
+	
+	void *mem;
+	
+	size_t size;
+
+	int rv;
+	
+	mutex_init(&ot->ctrl_drv_lock);
+
+	size = sizeof(struct miscdevice) + sizeof(ot->name) + sizeof(CTRL_DRV_POSTFIX);
+
+	mem = kzalloc(size, GFP_KERNEL);
+	if (!mem) {
+		return -ENOMEM;
+	}
+	
+	dev = mem;
+	dev->name = mem + sizeof(struct miscdevice);
+	
+	/* Control Path Name. */
+	strcpy((char *)dev->name, ot->name);
+	strcat((char *)dev->name, CTRL_DRV_POSTFIX);
+
+	dev->minor = MISC_DYNAMIC_MINOR;
+	dev->fops = &ctrl_drv_misc_fops;
+	
+	rv = misc_register(dev);
+	if (rv) {
+		kfree(dev);
+		return rv;
+	}
+
+	ot->miscdev = dev;
+
+	I("Create Control Path: %s, minor: %d.", dev->name, dev->minor);
+
+	return 0;	
+}
+
+static int ctrl_drv_cleanup(struct jz_fb_ot_info *ot)
+{
+	misc_deregister(ot->miscdev);
+	kfree(ot->miscdev);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/drv/fb-drv.c b/drivers/video/jz475x/drv/fb-drv.c
new file mode 100644
index 0000000..22ce518
--- /dev/null
+++ b/drivers/video/jz475x/drv/fb-drv.c
@@ -0,0 +1,303 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Linux Framebuffer Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+static inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+        chan &= 0xffff;
+        chan >>= 16 - bf->length;
+        return chan << bf->offset;
+}
+
+static int jz_fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			  u_int transp, struct fb_info *info)
+{
+	struct jz_fb_win_info *win = container_of(info, struct jz_fb_win_info, fb);
+	struct jz_fb_panel_info *panel = win->ctrl->ot->config->panel;
+
+	unsigned short *ptr, ctmp;
+
+#if 0	/* REVISIT. */
+	if (regno >= NR_PALETTE)
+		return 1;
+#endif
+
+	if (info->var.bits_per_pixel <= 16) {
+		red	>>= 8;
+		green	>>= 8;
+		blue	>>= 8;
+
+		red	&= 0xff;
+		green	&= 0xff;
+		blue	&= 0xff;
+	}
+
+	switch (info->var.bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+		if (((panel->lcd_cfg & LCD_CFG_MODE_MASK) == LCD_CFG_MODE_SINGLE_MSTN ) ||
+				((panel->lcd_cfg & LCD_CFG_MODE_MASK) == LCD_CFG_MODE_DUAL_MSTN )) {
+			ctmp = (77L * red + 150L * green + 29L * blue) >> 8;
+			ctmp = ((ctmp >> 3) << 11) | ((ctmp >> 2) << 5) |
+				(ctmp >> 3);
+		} else {
+			/* RGB 565 */
+			if (((red >> 3) == 0) && ((red >> 2) != 0))
+				red = 1 << 3;
+			if (((blue >> 3) == 0) && ((blue >> 2) != 0))
+				blue = 1 << 3;
+			ctmp = ((red >> 3) << 11) 
+				| ((green >> 2) << 5) | (blue >> 3);
+		}
+
+		ptr = (unsigned short *)win->dma_palette;
+		ptr = (unsigned short *)(((u32)ptr)|0xa0000000);
+		ptr[regno] = ctmp;
+
+		break;
+		
+	case 15:
+		if (regno < 16)
+			((u32 *)info->pseudo_palette)[regno] =
+				((red >> 3) << 10) | 
+				((green >> 3) << 5) |
+				(blue >> 3);
+		break;
+	case 16:
+		if (regno < 16) {
+			((u32 *)info->pseudo_palette)[regno] =
+				((red >> 3) << 11) | 
+				((green >> 2) << 5) |
+				(blue >> 3); 
+		}
+		break;
+	case 17 ... 32:
+		if (regno < 16)
+			((u32 *)info->pseudo_palette)[regno] =
+				(red << 16) | 
+				(green << 8) |
+				(blue << 0); 
+		break;
+	}
+
+	return 0;
+}
+
+static int jz_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	unsigned long start;
+	unsigned long off;
+	u32 len;
+
+	D("Called.");
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	/* frame buffer memory */
+	start = info->fix.smem_start;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
+	start &= PAGE_MASK;
+
+	if ((vma->vm_end - vma->vm_start + off) > len)
+		return -EINVAL;
+
+	off += start;
+
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+	vma->vm_flags |= VM_IO;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);	/* Uncacheable */
+
+ 	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
+ 	pgprot_val(vma->vm_page_prot) |= _CACHE_UNCACHED;		/* Uncacheable */
+
+	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
+			       vma->vm_end - vma->vm_start,
+			       vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int jz_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	D("Called.");
+
+	return 0;
+}
+
+static int jz_fb_set_par(struct fb_info *info)
+{
+	D("Called.");
+
+	return 0;
+}
+
+static int jz_fb_blank(int blank_mode, struct fb_info *info)
+{
+	struct jz_fb_ctrl *ctrl = &jz_fb_ctrl;
+
+	D("Called.");
+
+	switch (blank_mode) {
+		case FB_BLANK_UNBLANK:
+			jz_fb_hw_ot_power_on(ctrl, 1);
+			jz_fb_hw_ctrl_enable(ctrl, 1);
+			jz_fb_hw_ot_enable(ctrl, 1);
+
+			break;
+
+		case FB_BLANK_NORMAL:
+		case FB_BLANK_VSYNC_SUSPEND:
+		case FB_BLANK_HSYNC_SUSPEND:
+		case FB_BLANK_POWERDOWN:
+			jz_fb_hw_ot_disable(ctrl, 1);
+			jz_fb_hw_ctrl_disable(ctrl, 1);
+			jz_fb_hw_ot_power_off(ctrl, 1);
+
+
+			break;
+
+		default:
+			E("Unsupport blank mode.");
+			break;
+
+	}
+
+	return 0;
+}
+
+static int jz_fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	D("Called.");
+
+	return 0;
+}
+
+/* use default function cfb_fillrect, cfb_copyarea, cfb_imageblit */
+static struct fb_ops jz_fb_ops = {
+	.owner			= THIS_MODULE,
+	.fb_setcolreg		= jz_fb_setcolreg,
+	.fb_check_var 		= jz_fb_check_var,
+	.fb_set_par 		= jz_fb_set_par,
+	.fb_blank		= jz_fb_blank,
+	.fb_pan_display		= jz_fb_pan_display,
+	.fb_fillrect		= cfb_fillrect,
+	.fb_copyarea		= cfb_copyarea,
+	.fb_imageblit		= cfb_imageblit,
+	.fb_mmap		= jz_fb_mmap,
+};
+
+static irqreturn_t jz_fb_interrupt_handler(int irq, void *dev_id)
+{
+	unsigned int state;
+	static int irqcnt=0;
+
+	state = REG_LCD_STATE;
+	D("In the lcd interrupt handler, state=0x%x", state);
+
+	if (state & LCD_STATE_EOF) /* End of frame */
+		REG_LCD_STATE = state & ~LCD_STATE_EOF;
+
+	if (state & LCD_STATE_IFU0) {
+		printk("%s, InFiFo0 underrun\n", __FUNCTION__);
+		REG_LCD_STATE = state & ~LCD_STATE_IFU0;
+	}
+
+	if (state & LCD_STATE_IFU1) {
+		printk("%s, InFiFo1 underrun\n", __FUNCTION__);
+		REG_LCD_STATE = state & ~LCD_STATE_IFU1;
+	}
+
+	if (state & LCD_STATE_OFU) { /* Out fifo underrun */
+		REG_LCD_STATE = state & ~LCD_STATE_OFU;
+		if ( irqcnt++ > 100 ) {
+			__lcd_disable_ofu_intr();
+			printk("disable Out FiFo underrun irq.\n");
+		}
+		printk("%s, Out FiFo underrun.\n", __FUNCTION__);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PM
+
+/*
+ * Suspend the LCDC.
+ */
+static int jz_fb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct jz_fb_ctrl *ctrl = &jz_fb_ctrl;
+
+	D("Called.");
+
+	jz_fb_hw_ot_disable(ctrl, 1);
+	jz_fb_hw_ctrl_disable(ctrl, 1);
+	jz_fb_hw_ot_power_off(ctrl, 1);
+
+	return 0;
+}
+
+/*
+ * Resume the LCDC.
+ */
+static int jz_fb_resume(struct platform_device *pdev)
+{
+	struct jz_fb_ctrl *ctrl = &jz_fb_ctrl;
+
+	D("Called.");
+	
+	jz_fb_hw_ot_power_on(ctrl, 1);
+	jz_fb_hw_ctrl_enable(ctrl, 1);
+	jz_fb_hw_ot_enable(ctrl, 1);
+
+	return 0;
+}
+
+#else
+#define jzfb_suspend      NULL
+#define jzfb_resume       NULL
+#endif /* CONFIG_PM */
+
+static int fb_drv_setup(struct jz_fb_win_info *win)
+{
+	int rv;
+
+	dump_fb_info_fix(&win->fb.fix);	
+	dump_fb_info_var(&win->fb.var);	
+
+	rv = register_framebuffer(&win->fb);
+	if (rv) {
+		E("Failed to register Linux Framebuferr Driver.");
+		return rv;
+	}
+
+	return rv;
+}
+
+static int fb_drv_cleanup(struct jz_fb_win_info *win)
+{
+	return 0;	
+}
+
diff --git a/drivers/video/jz475x/jz-fb.c b/drivers/video/jz475x/jz-fb.c
new file mode 100644
index 0000000..4e2db74
--- /dev/null
+++ b/drivers/video/jz475x/jz-fb.c
@@ -0,0 +1,305 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *
+ *  Based on original version: 
+ *  Author: Wolfgang Wang, Lemon Liu, Emily Feng.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/processor.h>
+#include <asm/jzsoc.h>
+
+#include "jz-fb.h"
+
+#define DRV_NAME "jz-fb"
+#define DRV_VERSION "V0.1"
+
+static int default_output_id = 0;
+
+static struct jz_fb_ctrl jz_fb_ctrl;
+
+/* ----------------- COMMON Routines ---------------------- */
+#include "common.c"
+/* -------------------------------------------------------- */
+
+/* ----------------- OUTPUT Config ------------------------ */
+#include "output/config.c"
+/* -------------------------------------------------------- */
+
+/* ------------------ Core Function Block. ---------------- */
+#include "core/desc.c"
+#include "core/hw.c"
+#include "core/framebuffer.c"
+#include "core/win.c"
+#include "core/ot.c"
+/* -------------------------------------------------------- */
+
+/* ------------------ OUTPUT ------------------------------ */
+#include "output/output.c"
+/* -------------------------------------------------------- */
+
+/* ---------------- Driver Interface. --------------------- */
+#include "drv/fb-drv.c"
+#include "drv/ctrl-drv.c"
+/* -------------------------------------------------------- */
+
+static struct jz_fb_ot_info *id_to_ot(int id)
+{
+	int i;
+
+	for (i = 0; i < sizeof(jz_fb_ots) / sizeof(struct jz_fb_ot_info *); i++) {
+		if (jz_fb_ots[i]->id == id)
+			return jz_fb_ots[i];
+	}
+
+	return NULL;
+}
+
+static int jz_fb_drv_alloc(struct jz_fb_ctrl *ctrl,
+				struct jz_fb_ot_scan_info *scan)
+{
+	struct jz_fb_win_info *win;
+
+	int i;
+
+	int rv = 0;
+
+	for (i = 0; i < JZ_FB_NR_MAX_FG; i++) {
+		win = alloc_win(scan->max_w, 
+			scan->max_h, scan->max_bpp);
+
+		if (!win) {
+			E("Failed to allocate win info for FG %d.", i);
+			rv = -ENOMEM;
+
+			break;
+		}
+
+		win->index = i;
+		win->ctrl = ctrl;
+
+		ctrl->win[i] = win;
+	}
+	
+	D("Called.");
+
+	if (rv) {
+		while (--i >= 0) {
+			if (ctrl->win[i])
+				free_win(ctrl->win[i]);
+		}
+
+		return rv;
+	}
+
+	return 0;
+}
+
+static int jz_fb_drv_free(struct jz_fb_ctrl *ctrl)
+{
+	int i;
+
+	for (i = 0; i < JZ_FB_NR_MAX_FG; i++) {
+		if (ctrl->win[i])
+			free_win(ctrl->win[i]);
+	}
+
+	return 0;
+}
+
+static int jz_fb_drv_setup(struct jz_fb_ctrl *ctrl)
+{
+	int rv;
+
+	int i;
+
+	/* Setup Linux Framebuffer Driver for every window. */
+	for (i = 0; i < JZ_FB_NR_MAX_FG; i++) {
+		if (ctrl->win) {
+			rv = fb_drv_setup(ctrl->win[i]);
+			if (rv) {
+				return rv;
+			}
+		}
+	}
+
+	/* Setup Control Driver for every output path. */	
+	for (i = 0; i < sizeof(jz_fb_ots) / sizeof(struct jz_fb_ot_info *); i++) {
+		rv = ctrl_drv_setup(jz_fb_ots[i]);
+		if (rv) {
+			return rv;
+		}
+	}
+
+	return 0;
+}
+
+static int jz_fb_drv_cleanup(struct jz_fb_ctrl *ctrl)
+{
+	int rv;
+
+	int i;
+
+	for (i = 0; i < JZ_FB_NR_MAX_FG; i++) {
+		if (ctrl->win) {
+			rv = fb_drv_cleanup(ctrl->win[i]);
+			if (rv) {
+				return rv;
+			}
+		}
+	}
+
+	for (i = 0; i < sizeof(jz_fb_ots) / sizeof(struct jz_fb_ot_info *); i++) {
+		rv = ctrl_drv_cleanup(jz_fb_ots[i]);
+		if (rv) {
+			return rv;
+		}
+	}
+
+
+	return 0;
+}
+
+static int __devinit jz_fb_probe(struct platform_device *dev)
+{
+	struct jz_fb_ctrl *ctrl = &jz_fb_ctrl;
+	struct jz_fb_ot_scan_info scan;
+
+	unsigned long status = 0;
+
+	int rv = 0;
+
+	/* 1. Scan & Initialize All Outputs. */
+	jz_fb_ot_scan(ctrl, &scan);
+
+	D("Final: Max: w: %u, h: %u, bpp: %u.", scan.max_w, scan.max_h, scan.max_bpp);
+	
+	/* 2. Locate the default OT. */
+	ctrl->ot = id_to_ot(default_output_id);
+	if (!ctrl->ot) {
+		E("Default Output not found: ID: %d.\n", default_output_id);
+		return rv;
+	}
+	
+	/* 3. All allocations. */
+	rv = jz_fb_drv_alloc(ctrl, &scan);
+	if (rv) {
+		E("Failed to allocate FB Driver Layer.");
+		return rv;
+	}
+	
+	set_bit(0, &status);
+
+	/* 4. Select OT & Init HW & FB_INFO. */	
+	jz_fb_ot_set_current(ctrl->ot);
+	
+	if (request_irq(IRQ_LCD, jz_fb_interrupt_handler, IRQF_DISABLED,
+				DRV_NAME, 0)) {
+		E("Failed to request LCDC IRQ.");
+		rv = -EBUSY;
+		goto err;
+	}
+	
+	set_bit(1, &status);
+
+	/* 5. DRV Layer Setup. */
+	rv = jz_fb_drv_setup(ctrl);
+	if (rv) {
+		E("Failed to setup DRV layer.");
+		goto err;
+	}
+	
+	I("Registered.");
+
+	return rv;
+
+err:
+	if (test_bit(0, &status)) {
+		jz_fb_drv_free(ctrl);
+	}
+	
+	if (test_bit(1, &status)) {
+		jz_fb_hw_ot_disable(ctrl, 1);
+		jz_fb_hw_ctrl_disable(ctrl, 1);
+		jz_fb_hw_ot_power_off(ctrl, 1);
+
+		free_irq(IRQ_LCD, DRV_NAME);
+	}
+
+	return rv;
+}
+
+static int __devexit jz_fb_remove(struct platform_device *pdev)
+{
+	struct jz_fb_ctrl *ctrl= &jz_fb_ctrl;
+
+	jz_fb_hw_ot_disable(ctrl, 1);
+	jz_fb_hw_ctrl_disable(ctrl, 1);
+	jz_fb_hw_ot_power_off(ctrl, 1);
+
+	free_irq(IRQ_LCD, DRV_NAME);
+
+	jz_fb_drv_cleanup(ctrl);
+	jz_fb_drv_free(ctrl);
+
+	return 0;
+}
+
+static struct platform_driver jz_fb_driver = {
+	.probe	= jz_fb_probe,
+	.remove = jz_fb_remove,
+	.suspend = jz_fb_suspend,
+	.resume = jz_fb_resume,
+	.driver = {
+		.name = "jz-lcd",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init jz_fb_init(void)
+{
+	return platform_driver_register(&jz_fb_driver);
+}
+
+static void __exit jz_fb_cleanup(void)
+{
+	platform_driver_unregister(&jz_fb_driver);
+}
+
+module_init(jz_fb_init);
+module_exit(jz_fb_cleanup);
diff --git a/drivers/video/jz475x/jz-fb.h b/drivers/video/jz475x/jz-fb.h
new file mode 100644
index 0000000..9de42c7
--- /dev/null
+++ b/drivers/video/jz475x/jz-fb.h
@@ -0,0 +1,237 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __JZ_FB_H__
+#define __JZ_FB_H__
+
+#include <linux/miscdevice.h>
+
+#include "config.h"
+#include "abi.h"
+
+#define NR_PALETTE	256
+#define PALETTE_SIZE	(NR_PALETTE * 2)
+
+#define HW_AREA_POS(x, y)	( y << 16 | x)
+#define HW_AREA_SIZE(w, h)	( h << 16 | w)
+
+/* For 8 word DMA Descriptor. */
+#ifdef JZ_FB_8WORD_DMA_DESC
+struct jz_lcdc_8word_dma_desc {
+	uint32_t next_desc; 	/* LCDDAx */
+	uint32_t databuf;   	/* LCDSAx */
+	uint32_t frame_id;  	/* LCDFIDx */ 
+	uint32_t cmd; 		/* LCDCMDx */
+	uint32_t offsize;      	/* Stride Offsize(in word) */
+	uint32_t page_width; 	/* Stride Pagewidth(in word) */
+	uint32_t cmd_num; 	/* Command Number(for SLCD) */
+	uint32_t desc_size; 	/* Foreground Size */
+};
+
+typedef struct jz_lcdc_8word_dma_desc dma_desc_t;
+#endif
+
+/* For 4 word DMA Descriptor. */
+#ifdef JZ_FB_4WORD_DMA_DESC
+struct jz_lcdc_4word_dma_desc {
+	unsigned int next_desc; 	/* LCDDAx */
+	unsigned int databuf;   	/* LCDSAx */
+	unsigned int frame_id;  	/* LCDFIDx */ 
+	unsigned int cmd; 		/* LCDCMDx */
+};
+
+typedef struct jz_lcdc_4word_dma_desc dma_desc_t;
+#endif
+
+struct jz_fb_ot_info;
+struct jz_fb_win_info;
+
+struct jz_fb_dma_desc {
+	dma_desc_t hw_desc;
+
+	int index;
+	int use;
+	void *mem;	
+
+	struct jz_fb_win_info *win;
+	struct list_head list;
+	struct list_head group;
+};
+
+struct jz_fb_panel_ops {
+	int (*normal)(struct jz_fb_ot_info *ot);
+	int (*idle)(struct jz_fb_ot_info *ot);
+	int (*on)(struct jz_fb_ot_info *ot);
+	int (*off)(struct jz_fb_ot_info *ot);
+	int (*get_backlight)(struct jz_fb_ot_info *ot);
+	int (*set_backlight)(struct jz_fb_ot_info *ot, int value);
+};
+
+struct jz_fb_panel_info {
+	unsigned long lcd_ctrl;	/* panel mode and pin usage etc. */
+	unsigned long lcd_cfg;	/* panel mode and pin usage etc. */
+	unsigned int w;		/* Panel Width(in pixel) */
+	unsigned int h;		/* Panel Height(in line) */
+	unsigned int fclk;	/* frame clk */
+	unsigned int hsw;	/* hsync width, in pclk */
+	unsigned int vsw;	/* vsync width, in line count */
+	unsigned int elw;	/* end of line, in pclk */
+	unsigned int blw;	/* begin of line, in pclk */
+	unsigned int efw;	/* end of frame, in line count */
+	unsigned int bfw;	/* begin of frame, in line count */
+};
+
+struct jz_fb_panel_config {
+	struct jz_fb_panel_ops *ops;
+	struct jz_fb_panel_info *panel;
+
+	struct jz_fb_win_attr_info win_runtime_config[JZ_FB_NR_MAX_FG];
+	
+	/* For Panel Private Routines. */
+	void *priv;
+
+	struct jz_fb_win_attr_info *win_init_config;
+	
+	unsigned int enable_delay_ms;
+
+	int backlight;
+	int use_palette;
+	unsigned int background_color;
+	unsigned int max_win_bpp;
+};
+
+struct jz_fb_reg_info {
+	/* Used to config specified function block's register. */
+	unsigned long flags;
+
+	unsigned long lcd_cfg;
+	unsigned long lcd_ctrl;
+	unsigned long lcd_osdc;
+	unsigned long lcd_osdctrl;
+	unsigned long lcd_bgc;
+	unsigned long lcd_key0;
+	unsigned long lcd_key1;
+	unsigned long lcd_alpha;
+	unsigned long lcd_ipur;
+	unsigned long lcd_rgbc;
+	unsigned long lcd_vat;
+	unsigned long lcd_dah;
+	unsigned long lcd_dav;
+	unsigned long lcd_xyp0;
+	unsigned long lcd_xyp1;
+	unsigned long lcd_size0;
+	unsigned long lcd_size1;
+	unsigned long lcd_vsync;
+	unsigned long lcd_hsync;
+	unsigned long lcd_ps;
+	unsigned long lcd_rev;
+	unsigned long lcd_da0;
+	unsigned long lcd_da1;
+};
+
+struct jz_fb_ot_ops {
+	void (*enable)(struct jz_fb_ot_info *);
+	void (*disable)(struct jz_fb_ot_info *);
+	void (*start)(struct jz_fb_ot_info *);
+	void (*stop)(struct jz_fb_ot_info *);
+	int (*control)(struct jz_fb_ot_info *, void *);
+};
+
+struct jz_fb_ot_desc_ops {
+	int (*setup)(struct jz_fb_win_info *);
+	void (*cleanup)(struct jz_fb_win_info *);
+	int (*attach)(struct jz_fb_win_info *, void *);
+	int (*detach)(struct jz_fb_win_info *, void *);
+};
+
+struct jz_fb_ot_info {
+	char *name;
+	int id;
+	
+	int state;
+	int power;
+
+	int use_quick_disable;
+	int use_tve;
+	int use_rgb_to_yuv;
+
+	struct jz_fb_ot_ops *ops;
+	struct jz_fb_ot_desc_ops *desc_ops;
+	struct jz_fb_panel_config *config;
+
+	struct jz_fb_reg_info reg_info;
+	
+	struct mutex ctrl_drv_lock;
+	struct miscdevice *miscdev;
+
+	struct jz_fb_ctrl *ctrl;
+};
+
+struct jz_fb_ctrl;
+
+#define WIN_X(win) (win->attr.x)
+#define WIN_Y(win) (win->attr.y)
+
+#define WIN_W(win) (win->attr.w)
+#define WIN_H(win) (win->attr.h)
+
+#define WIN_BPP(win) (win->attr.bpp)
+
+struct jz_fb_win_info {
+	int index;
+
+	struct jz_fb_win_attr_info attr;
+
+	struct fb_info		fb;
+
+	/* DMA Descriptor Pool. */	
+	struct jz_fb_dma_desc *dma_desc[JZ_FB_NR_MAX_DMA_DESC];
+	struct jz_fb_dma_desc *dma_desc_data_start;
+	struct jz_fb_dma_desc *dma_desc_last_no_data;
+
+	void *dma_desc_pool;
+
+	/* Framebuffer Pool. */
+	void *fb_mem[JZ_FB_NR_MAX_FB_MEM];
+	unsigned int fb_mem_len;	/* Framebuffer Block Size. */
+
+	/* Runtime WIN data size. */
+	unsigned int fb_line_len;
+	unsigned int fb_frame_len;
+
+	void *dma_palette;
+	
+	void *misc_mem_start;
+	void *misc_mem_cur;
+
+	struct jz_fb_ctrl 	*ctrl;
+};
+
+struct jz_fb_ctrl {
+	int state;
+
+	unsigned int pixclock;
+	
+	struct jz_fb_ot_info *ot;
+	struct jz_fb_win_info *win[JZ_FB_NR_MAX_FG];
+};
+
+#endif /* __JZ_FB_H__ */
diff --git a/drivers/video/jz475x/output/config.c b/drivers/video/jz475x/output/config.c
new file mode 100644
index 0000000..fe15ba3
--- /dev/null
+++ b/drivers/video/jz475x/output/config.c
@@ -0,0 +1,75 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Output Config.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifdef CONFIG_FB_JZ475X_LCD_OUTPUT
+static struct jz_fb_ot_info jz_fb_lcd_ot_info;
+
+static int lcd_output_init(struct jz_fb_ot_info *);
+#endif
+
+#ifdef CONFIG_FB_JZ475X_TVE_PAL_OUTPUT
+static struct jz_fb_ot_info jz_fb_tve_pal_ot_info;
+
+static int tve_pal_output_init(struct jz_fb_ot_info *);
+#endif
+
+#ifdef CONFIG_FB_JZ475X_TVE_NTSC_OUTPUT
+static struct jz_fb_ot_info jz_fb_tve_ntsc_ot_info;
+
+static int tve_ntsc_output_init(struct jz_fb_ot_info *);
+#endif
+
+static struct jz_fb_ot_info *jz_fb_ots [] = {
+
+#ifdef CONFIG_FB_JZ475X_LCD_OUTPUT
+	&jz_fb_lcd_ot_info,
+#endif
+
+#ifdef CONFIG_FB_JZ475X_TVE_PAL_OUTPUT
+	&jz_fb_tve_pal_ot_info,
+#endif
+
+#ifdef CONFIG_FB_JZ475X_TVE_NTSC_OUTPUT
+	&jz_fb_tve_ntsc_ot_info,
+#endif
+	
+};
+
+typedef int jz_fb_ot_init_t(struct jz_fb_ot_info *);
+
+static jz_fb_ot_init_t *jz_fb_ot_inits [] = {
+
+#ifdef CONFIG_FB_JZ475X_LCD_OUTPUT
+	&lcd_output_init,
+#endif
+
+#ifdef CONFIG_FB_JZ475X_TVE_PAL_OUTPUT
+	&tve_pal_output_init,
+#endif
+
+#ifdef CONFIG_FB_JZ475X_TVE_NTSC_OUTPUT
+	&tve_ntsc_output_init,
+#endif
+	
+};
+
diff --git a/drivers/video/jz475x/output/control.c b/drivers/video/jz475x/output/control.c
new file mode 100644
index 0000000..f88b81d
--- /dev/null
+++ b/drivers/video/jz475x/output/control.c
@@ -0,0 +1,100 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Output Common Control Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+/* Handle Common Controls. */
+static int do_ot_common_control(struct jz_fb_ot_info *ot, 
+		struct jz_fb_common_control *c, void __user *p)
+{
+	int rv = 0;
+
+	int i;
+
+	switch (c->command) {
+		case JZ_FB_CMD_COMMON_GET_STATE:
+			c->v = 0;
+
+			if (ot->power)
+				c->v |= JZ_FB_CMD_COMMON_STATE_OT_POWER;
+			
+			if (ot->state)
+				c->v |= JZ_FB_CMD_COMMON_STATE_OT_ENABLE;
+			
+			if (ot->ctrl->state)
+				c->v |= JZ_FB_CMD_COMMON_STATE_CTRL_ENABLE;
+
+			if (copy_to_user(p, c, sizeof(struct jz_fb_common_control))) 
+				rv = -EFAULT;
+			
+			break;
+
+		case JZ_FB_CMD_COMMON_SET_POWER:
+			if (c->v) {
+				jz_fb_hw_ot_power_on(ot->ctrl, 0);
+			}else{
+				jz_fb_hw_ot_power_off(ot->ctrl, 0);
+			}
+
+			break;
+
+		case JZ_FB_CMD_COMMON_SET_SCREEN:	
+			if (c->v) {
+				jz_fb_hw_ot_enable(ot->ctrl, 0);
+			}else{
+				jz_fb_hw_ot_disable(ot->ctrl, 0);
+			}
+
+			break;
+
+		case JZ_FB_CMD_COMMON_GET_WIN_ATTR:
+			memcpy(c->win_attr, ot->config->win_runtime_config, sizeof(c->win_attr));	
+			if (copy_to_user(p, c, sizeof(struct jz_fb_common_control))) 
+				rv = -EFAULT;
+
+			break;
+
+		case JZ_FB_CMD_COMMON_SET_WIN_ATTR:
+			memcpy(ot->config->win_runtime_config, c->win_attr, sizeof(c->win_attr));	
+			/* OT WIN Runtime CONFIG -> Current WIN Attr. 
+			   This allow each OT having its own Runtime ATTR.
+			*/
+
+			jz_fb_ot_load_runtime_config(ot);
+
+			if (c->active_now) {
+				for (i = 0; i < JZ_FB_NR_MAX_FG; i++)
+					jz_fb_win_active_attr(ot->ctrl->win[i]);
+			}
+				
+			/* Attr will be actived when OT is re-selected. */
+			break;
+	
+		case JZ_FB_CMD_COMMON_SELECT_OT:
+			rv = jz_fb_ot_set_current(ot);
+
+			break;
+
+	}
+
+	return rv;
+}
+
diff --git a/drivers/video/jz475x/output/lcd/auo-a043fl01v2.c b/drivers/video/jz475x/output/lcd/auo-a043fl01v2.c
new file mode 100644
index 0000000..9e098e5
--- /dev/null
+++ b/drivers/video/jz475x/output/lcd/auo-a043fl01v2.c
@@ -0,0 +1,161 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * LCD PANEL: AUO A043FL01V2 on CETUS Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifdef CONFIG_FB_JZ475X_LCD_PANEL_AUO_A043FL01V2
+static struct jz_fb_panel_info auo_panel_info = {
+	.lcd_ctrl = LCD_CTRL_OFUM | LCD_CTRL_BST_16,
+	.lcd_cfg = LCD_CFG_LCDPIN_LCD | LCD_CFG_RECOVER	/* Underrun recover */ 
+
+	/* ---------------- CUSTOM: Modify these by your panel. -----------*/
+		| LCD_CFG_MODE_GENERIC_TFT		/* General TFT panel */
+		| LCD_CFG_MODE_TFT_24BIT	 	/* output 18bpp */
+		| LCD_CFG_HSP				/* Hsync polarity: active low */
+		| LCD_CFG_VSP,	/* Vsync polarity: leading edge is falling edge */
+	480, 272, 60, 41, 10, 8, 4, 4, 2,
+	/* --------------------------------------------------------------- */
+};
+
+/* ------ CUSTOM: Modify these by your board. --------- */
+/* Get Backlight Level. */
+static int auo_panel_get_backlight(struct jz_fb_ot_info *ot)
+{
+	D("Called.");
+
+	return ot->config->backlight;
+}
+
+/* Set Backlight & PWM. */
+static int auo_panel_set_backlight(struct jz_fb_ot_info *ot, int backlight)
+{
+	D("Called.");
+
+	ot->config->backlight = backlight;
+
+	return 0;
+}
+
+/* 
+   For Display ON / OFF. 
+   Enablie / Disable Backlight / PWM Here.
+*/
+static int auo_panel_on(struct jz_fb_ot_info *ot)
+{
+	D("Called.");
+	
+	__gpio_set_pin(GPIO_LCD_PWM);	
+	__gpio_as_output(GPIO_LCD_PWM);	
+
+	return 0;
+}
+
+static int auo_panel_off(struct jz_fb_ot_info *ot)
+{
+	D("Called.");
+
+	__gpio_clear_pin(GPIO_LCD_PWM);
+	__gpio_as_output(GPIO_LCD_PWM);	
+
+	return 0;
+}
+
+/* 
+   For PM / Init Routines. 
+   Set GPIO Pins to normal/idle state. 
+   Enable / Disable VCC_EN/PWM etc..
+ */
+
+static int auo_panel_normal(struct jz_fb_ot_info *ot)
+{
+	D("Called.");
+	
+	__gpio_as_lcd_24bit();
+
+#ifdef CONFIG_JZ4750D_CETUS
+	__gpio_set_pin(GPIO_LCD_VCC_EN_N);
+#endif
+
+	__gpio_as_output(GPIO_LCD_VCC_EN_N);
+	
+	return 0;
+}
+
+static int auo_panel_idle(struct jz_fb_ot_info *ot)
+{
+	D("Called.");
+
+#ifdef CONFIG_JZ4750D_CETUS
+	__gpio_clear_pin(GPIO_LCD_VCC_EN_N);
+#endif
+	__gpio_as_output(GPIO_LCD_VCC_EN_N);
+
+	return 0;
+}
+/* ---------------------------------------------------------- */
+
+static struct jz_fb_panel_ops auo_panel_ops = {
+	.get_backlight = auo_panel_get_backlight,
+	.set_backlight = auo_panel_set_backlight,
+
+	.normal = auo_panel_normal,
+	.idle	= auo_panel_idle,
+
+	.on	= auo_panel_on,
+	.off	= auo_panel_off,
+};
+
+/* ------------ CUSTOM: Modify these by your need. ----------- */
+struct jz_fb_win_attr_info auo_win_init_config[] = {
+	[0] = {
+		.enable		= 1,
+		.x		= 0,
+		.y		= 0,
+		.w		= 480,
+		.h		= 272,
+		.bpp		= 32,
+	},
+	[1] = {
+		.enable		= 1,
+		.x		= 0,
+		.y		= 0,
+		.w		= 480,
+		.h		= 272,
+		.bpp		= 32,
+	},
+};
+/* ----------------------------------------------------------- */
+
+struct jz_fb_panel_config lcd_output_panel_config = {
+	.ops = &auo_panel_ops,
+	.panel = &auo_panel_info,
+	.win_init_config = auo_win_init_config,
+
+/* -------------- CUSTOM: Modify these by your need. --------- */
+	.enable_delay_ms = 80,	/* Delay in ms before backlight is enabled. */
+	.backlight = 80,
+	.use_palette = 0,
+	.max_win_bpp = 32,
+	.background_color = 0x000000FF,
+/* ----------------------------------------------------------- */
+};
+
+#endif	/* Define CONFIG_FB_JZ475X_LCD_PANEL_AUO_A043FL01V2 */
diff --git a/drivers/video/jz475x/output/lcd/lcd-control.c b/drivers/video/jz475x/output/lcd/lcd-control.c
new file mode 100644
index 0000000..bef78ba
--- /dev/null
+++ b/drivers/video/jz475x/output/lcd/lcd-control.c
@@ -0,0 +1,73 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * LCD Output Specific Control Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+static int lcd_output_control(struct jz_fb_ot_info *ot, 
+				void __user *p)
+{
+	struct jz_fb_panel_config *config = ot->config;
+
+	struct jz_fb_lcd_control lc;
+	struct jz_fb_common_control *c;
+
+	int rv = 0;
+
+	if (copy_from_user(&lc, p, sizeof(struct jz_fb_lcd_control))) {
+		E("Failed to do copy_from_user.\n");
+		return -EFAULT;
+	}
+	
+	c = &lc.common;
+	
+	/* Check Output ID - Prevent Userspace APP walk the error path. */
+	if (c->id != ot->id) {
+		E("Bad Output ID for LCD Path: %s.", ot->miscdev->name);
+		return -EINVAL;
+	}
+
+	switch (c->command) {
+		case JZ_FB_CMD_LCD_GET_BACKLIGHT:
+			c->v = config->ops->get_backlight(ot);
+
+			D("Get Backlight: Value: %d.", c->v);
+
+			if (copy_to_user(p, &lc, sizeof(struct jz_fb_lcd_control))) {
+				E("Failed to do copy_to_user.\n");
+				return -EFAULT;
+			}
+
+			break;
+
+		case JZ_FB_CMD_LCD_SET_BACKLIGHT:
+			D("Set Backlight: Value: %d.", c->v);
+
+			rv = config->ops->set_backlight(ot, c->v);
+			break;
+		
+		default:
+			rv = do_ot_common_control(ot, c, p);
+			break;
+	}
+
+	return rv;
+}
+
diff --git a/drivers/video/jz475x/output/lcd/lcd-output.c b/drivers/video/jz475x/output/lcd/lcd-output.c
new file mode 100644
index 0000000..b591b03
--- /dev/null
+++ b/drivers/video/jz475x/output/lcd/lcd-output.c
@@ -0,0 +1,193 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * LCD Output Main Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifdef CONFIG_FB_JZ475X_LCD_OUTPUT
+
+/* -------- CUSTOM: Add your specific panel here. ----------- */
+#include "auo-a043fl01v2.c"
+/* ---------------------------------------------------------- */
+
+static int lcd_output_desc_setup(struct jz_fb_win_info *win)
+{
+	struct jz_fb_panel_config *c = win->ctrl->ot->config;
+	struct jz_fb_dma_desc *desc;
+	
+	D("Called.");	
+
+	/* Setup DMA Palette Descriptor. */
+	if (c->use_palette && win->index == 0) { /* Palette cannot be used on FG1. */
+		unsigned long palette_size = 
+			jz_fb_hw_bpp_to_palette_size(win->attr.bpp);
+
+		D("Use Palette.");
+
+		desc = dma_desc_get(win);
+		if (!desc) {
+			return -ENOMEM;
+		}	
+
+		dma_desc_init(desc);
+
+		dma_desc_set_mem(desc, win->dma_palette);
+		dma_desc_set_data_size(desc, palette_size);
+
+		dma_desc_set_as_palette(desc);
+
+		/* Set as DMA Descriptor Chain Head. */
+		dma_desc_set_chain_head(desc);
+		
+		win->dma_desc_last_no_data = desc;
+	}
+
+	return 0;
+}
+
+static void lcd_output_desc_cleanup(struct jz_fb_win_info *win)
+{
+	/* Clean up ALL. */
+	dma_desc_pool_init(win);
+
+	return;
+}
+
+/* Dynamically Attach / Detach Framebuffer */
+/* LCD Output: 1 Descriptor -> 1 Framebuffer. */
+static int lcd_output_desc_attach(struct jz_fb_win_info *win, void *mem)
+{
+	/* Get new descriptor. */
+	struct jz_fb_dma_desc *desc = dma_desc_get(win);
+	struct jz_fb_win_attr_info *a = &win->attr;
+
+	D("Called.");
+
+	if (!desc) {
+		return -ENOMEM;
+	}
+
+	dma_desc_init(desc);
+
+	/* Attach framebuffer to desciptors. */
+	dma_desc_set_mem(desc, mem);
+	dma_desc_set_data_size(desc, win->fb_frame_len);
+
+	dma_desc_set_area_size(desc, a->w, a->h);
+	
+	dma_desc_add_to_chain(desc);
+
+	dump_desc(desc);
+
+	return 0;
+}
+
+static int lcd_output_desc_detach(struct jz_fb_win_info *win, void *mem)
+{
+	struct jz_fb_dma_desc *desc;
+
+	/* Find descriptor by mem pointer. */
+	desc = dma_desc_mem_to_desc(win, mem);
+	if (!desc) {
+		return -ENODEV;
+	}
+	
+	dma_desc_del_from_chain(desc);
+
+	/* Release descriptor. */
+	dma_desc_put(desc);
+	
+	return 0;
+}
+
+static struct jz_fb_ot_desc_ops lcd_output_desc_ops = {
+	.setup = lcd_output_desc_setup,
+	.attach = lcd_output_desc_attach,
+	.detach = lcd_output_desc_detach,
+	.cleanup = lcd_output_desc_cleanup,
+};
+
+static void lcd_output_enable(struct jz_fb_ot_info *ot)
+{
+	struct jz_fb_panel_config *c = ot->config;
+
+	/* Call specific panel screen on routines. */
+	c->ops->on(ot);
+
+	return;
+}
+
+static void lcd_output_disable(struct jz_fb_ot_info *ot)
+{
+	struct jz_fb_panel_config *c = ot->config;
+
+	/* Call specific panel screen off routines. */
+	c->ops->off(ot);
+
+	return;
+}
+
+static void lcd_output_start(struct jz_fb_ot_info *ot)
+{
+	struct jz_fb_panel_config *c = ot->config;
+	
+	/* Call specific panel working routines. */
+	c->ops->normal(ot);
+
+	return;
+}
+
+static void lcd_output_stop(struct jz_fb_ot_info *ot)
+{
+	struct jz_fb_panel_config *c = ot->config;
+
+	/* Call specific panel suspend routines. */
+	c->ops->idle(ot);
+
+	return;
+}
+
+#include "lcd-control.c"
+
+static struct jz_fb_ot_ops lcd_output_ops = {
+	.enable = lcd_output_enable,
+	.disable = lcd_output_disable,
+	.start = lcd_output_start,
+	.stop = lcd_output_stop,
+	.control = lcd_output_control,
+};
+
+static int lcd_output_init(struct jz_fb_ot_info *ot)
+{
+	ot->name = "lcd-ot";
+
+	ot->use_quick_disable = 0;
+	ot->use_tve = 0;
+	ot->use_rgb_to_yuv = 0;
+
+	ot->desc_ops = &lcd_output_desc_ops;
+	ot->ops = &lcd_output_ops;
+
+	ot->config = &lcd_output_panel_config;
+	
+	return 0;
+}
+
+#endif /* CONFIG_FB_JZ475X_LCD_OUTPUT */
diff --git a/drivers/video/jz475x/output/output.c b/drivers/video/jz475x/output/output.c
new file mode 100644
index 0000000..e1f8ee2
--- /dev/null
+++ b/drivers/video/jz475x/output/output.c
@@ -0,0 +1,38 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Output Main Path.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include "control.c"
+
+#ifdef CONFIG_FB_JZ475X_LCD_OUTPUT
+#include "lcd/lcd-output.c"
+#endif
+
+#ifdef CONFIG_FB_JZ475X_TVE_PAL_OUTPUT
+#include "tve/tve-pal-output.c"
+#endif
+
+#ifdef CONFIG_FB_JZ475X_TVE_NTSC_OUTPUT
+#include "tve/tve-ntsc-output.c"
+#endif
+
+
diff --git a/drivers/video/jz475x/output/tve/tve-common.c b/drivers/video/jz475x/output/tve/tve-common.c
new file mode 100644
index 0000000..bec5da1
--- /dev/null
+++ b/drivers/video/jz475x/output/tve/tve-common.c
@@ -0,0 +1,169 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * TVE Common Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __JZ_FB_TVE_COMMON__
+#define __JZ_FB_TVE_COMMON__
+
+static int tve_output_desc_setup(struct jz_fb_win_info *win)
+{
+	D("Called.");	
+	
+	return 0;
+}
+
+static void tve_output_desc_cleanup(struct jz_fb_win_info *win)
+{
+	/* Clean up ALL. */
+	dma_desc_pool_init(win);
+
+	return;
+}
+
+/* Dynamically Attach / Detach Framebuffer */
+/* TVE Output: 2 Descriptors -> 1 Framebuffer. */
+static int tve_output_desc_attach(struct jz_fb_win_info *win, void *mem)
+{
+	/* Get new descriptor. */
+	struct jz_fb_dma_desc *top, *bottom;
+	struct jz_fb_win_attr_info *a = &win->attr;
+
+	D("Called.");
+	
+	top = dma_desc_get(win);
+	if (!top) {
+		return -ENOMEM;
+	}
+
+	bottom = dma_desc_get(win);
+	if (!bottom) {
+		return -ENOMEM;
+	}
+
+	dma_desc_init(top);
+	dma_desc_init(bottom);
+
+	/* Attach framebuffer to desciptors. */
+	dma_desc_set_mem(top, mem);
+	dma_desc_set_mem(bottom, mem);
+
+	if (win->fb_frame_len & 0x1) {
+		dma_desc_set_data_size(top, win->fb_frame_len / 2 + win->fb_line_len);
+		dma_desc_set_data_size(bottom, win->fb_frame_len / 2 - win->fb_line_len);
+	}else{
+		dma_desc_set_data_size(top, win->fb_frame_len / 2);
+		dma_desc_set_data_size(bottom, win->fb_frame_len / 2);
+	}
+
+	dma_desc_set_area_size(top, a->w, a->h);
+	dma_desc_set_area_size(bottom, a->w, a->h);
+	
+	dma_desc_set_stride(top, win->fb_line_len, win->fb_line_len);
+	dma_desc_set_stride(bottom, win->fb_line_len, win->fb_line_len);
+
+	/* Add bottom to top's group -> Link bottom after top. */
+	dma_desc_group_add(bottom, top);
+	
+	dma_desc_add_to_chain(top);
+
+	dump_desc(top);
+	dump_desc(bottom);
+
+	return 0;
+}
+
+static int tve_output_desc_detach(struct jz_fb_win_info *win, void *mem)
+{
+	struct jz_fb_dma_desc *desc, *node;
+	
+	struct list_head *pos, *n;
+
+	/* Locate descriptor by mem pointer. */
+	desc = dma_desc_mem_to_desc(win, mem);
+	if (!desc) {
+		return -ENODEV;
+	}
+	
+	/* Remove us from current chain. */
+	dma_desc_del_from_chain(desc);
+	
+	/* Release Group. */
+	list_for_each_safe(pos, n, &desc->group) {
+		node = list_entry(pos, struct jz_fb_dma_desc, group);
+
+		list_del(pos);
+		dma_desc_put(node);
+	}
+
+	/* Release descriptor. */
+	dma_desc_put(desc);
+	
+	return 0;
+}
+
+static struct jz_fb_ot_desc_ops tve_output_desc_ops = {
+	.setup = tve_output_desc_setup,
+	.attach = tve_output_desc_attach,
+	.detach = tve_output_desc_detach,
+	.cleanup = tve_output_desc_cleanup,
+};
+
+#include "tve-hw.c"
+
+static void tve_output_start(struct jz_fb_ot_info *ot)
+{
+	jz_fb_tve_set_output((int)ot->config->priv);
+	jz_fb_tve_start();
+	
+	return;
+}
+
+static void tve_output_stop(struct jz_fb_ot_info *ot)
+{
+	jz_fb_tve_stop();
+
+	return;
+}
+
+static inline int tve_output_get_path(struct jz_fb_ot_info *ot)
+{
+	return (int)(ot->config->priv);
+}
+
+static inline int tve_output_set_path(struct jz_fb_ot_info *ot, int path)
+{
+	int rv;
+	
+	rv = jz_fb_tve_valid_output(path);
+	if (rv) {
+		E("Invaild Output Path: %d.", path);
+		return rv;
+	}
+
+	ot->config->priv = (void *)path;
+	
+	return 0;
+}
+
+#include "tve-control.c"
+
+#endif
diff --git a/drivers/video/jz475x/output/tve/tve-control.c b/drivers/video/jz475x/output/tve/tve-control.c
new file mode 100644
index 0000000..1e706e4
--- /dev/null
+++ b/drivers/video/jz475x/output/tve/tve-control.c
@@ -0,0 +1,64 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * TVE Common Control Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+static int tve_output_control(struct jz_fb_ot_info *ot, 
+				void __user *p)
+{
+	struct jz_fb_tve_control lc;
+	struct jz_fb_common_control *c = &lc.common;
+
+	int rv = 0;
+
+	if (copy_from_user(&lc, p, sizeof(struct jz_fb_tve_control))) {
+		E("Failed to do copy_from_user.\n");
+		return -EFAULT;
+	}
+	
+	/* Prevent Userspace APP walk the error path. */
+	if (c->id != ot->id) {
+		E("Bad Output ID for TVE Path: %s.", ot->miscdev->name);
+		return -EINVAL;
+	}
+
+	switch (c->command) {
+		case JZ_FB_CMD_TVE_GET_PATH:
+			c->v = tve_output_get_path(ot);
+
+			if (copy_to_user(p, &lc, sizeof(struct jz_fb_tve_control))) {
+				E("Failed to do copy_to_user().");
+				rv = -EFAULT;
+			}
+
+			break;
+
+		case JZ_FB_CMD_TVE_SET_PATH:
+			rv = tve_output_set_path(ot, c->v);
+			break;
+
+		default:
+			rv = do_ot_common_control(ot, c, p);
+			break;
+	}
+
+	return rv;
+}
diff --git a/drivers/video/jz475x/output/tve/tve-hw.c b/drivers/video/jz475x/output/tve/tve-hw.c
new file mode 100644
index 0000000..13d3479
--- /dev/null
+++ b/drivers/video/jz475x/output/tve/tve-hw.c
@@ -0,0 +1,272 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * TVE Controller Routines. 
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+/* TV parameter */
+#define TVE_WIDTH_PAL 		720
+#define TVE_HEIGHT_PAL 		573
+#define TVE_FREQ_PAL 		50
+#define TVE_WIDTH_NTSC 		720
+#define TVE_HEIGHT_NTSC 	482
+#define TVE_FREQ_NTSC 		60
+
+struct jz_fb_tve_regs {
+	unsigned int ctrl;
+	unsigned int frcfg;
+	unsigned int slcfg1;
+	unsigned int slcfg2;
+	unsigned int slcfg3;
+	unsigned int ltcfg1;
+	unsigned int ltcfg2;
+	unsigned int cfreq;
+	unsigned int cphase;
+	unsigned int cbcrcfg;
+	unsigned int wsscr;
+	unsigned int wsscfg1;
+	unsigned int wsscfg2;
+	unsigned int wsscfg3;
+};
+
+struct jz_fb_tve_info {
+	int output;
+	int standard;
+	int b_enable;
+
+	struct jz_fb_tve_regs regs;
+};
+
+enum {
+	JZ_FB_TVE_STANDARD_PAL = 0,
+	JZ_FB_TVE_STANDARD_NTSC,
+};
+
+static struct jz_fb_tve_info g_tve_info;
+
+static struct jz_fb_tve_regs tve_pal_regs_config = {
+	.ctrl = (4 << TVE_CTRL_YCDLY_BIT) | TVE_CTRL_SYNCT | TVE_CTRL_PAL | TVE_CTRL_SWRST,
+	.frcfg = (23 << TVE_FRCFG_L1ST_BIT) | (625 << TVE_FRCFG_NLINE_BIT),
+	.slcfg1 = (800<<TVE_SLCFG1_WHITEL_BIT) | (282<<TVE_SLCFG1_BLACKL_BIT),
+	.slcfg2 = (296<<TVE_SLCFG2_VBLANKL_BIT) | (240<<TVE_SLCFG2_BLANKL_BIT),
+	.slcfg3 = (72 <<TVE_SLCFG3_SYNCL_BIT),
+	.ltcfg1 = (20<<TVE_LTCFG1_FRONTP_BIT) | (63<<TVE_LTCFG1_HSYNCW_BIT) | (78<<TVE_LTCFG1_BACKP_BIT),
+	.ltcfg2 = (1440 << TVE_LTCFG2_ACTLIN_BIT) | (24 << TVE_LTCFG2_PREBW_BIT) | (68 << TVE_LTCFG2_BURSTW_BIT),
+	.cfreq = 0x2a098acb,
+	.cphase = (0 << TVE_CPHASE_INITPH_BIT) | (0 << TVE_CPHASE_ACTPH_BIT) | (1 << TVE_CPHASE_CCRSTP_BIT),
+	.cbcrcfg = (32<<TVE_CBCRCFG_CBBA_BIT) | (59<<TVE_CBCRCFG_CRBA_BIT) | (137<<TVE_CBCRCFG_CBGAIN_BIT) | (137<<TVE_CBCRCFG_CRGAIN_BIT), /* CBGAIN CRGAIN??? */
+	.wsscr = 0x00000070,	/* default value */
+	.wsscfg1 = 0x0,
+	.wsscfg2 = 0x0,
+	.wsscfg3 = 0x0,
+};
+
+struct jz_fb_tve_regs tve_ntsc_regs_config = {
+	.ctrl = (4 << TVE_CTRL_YCDLY_BIT) | TVE_CTRL_SWRST,
+	.frcfg = (21 << TVE_FRCFG_L1ST_BIT) | (525 << TVE_FRCFG_NLINE_BIT),
+	.slcfg1 = (800<<TVE_SLCFG1_WHITEL_BIT) | (282<<TVE_SLCFG1_BLACKL_BIT),
+	.slcfg2 = (296<<TVE_SLCFG2_VBLANKL_BIT) | (240<<TVE_SLCFG2_BLANKL_BIT),
+	.slcfg3 = (72 <<TVE_SLCFG3_SYNCL_BIT),
+	.ltcfg1 = (16<<TVE_LTCFG1_FRONTP_BIT) | (63<<TVE_LTCFG1_HSYNCW_BIT) | (59<<TVE_LTCFG1_BACKP_BIT),
+	.ltcfg2 = (1440 << TVE_LTCFG2_ACTLIN_BIT) | (22 << TVE_LTCFG2_PREBW_BIT) | (68 << TVE_LTCFG2_BURSTW_BIT),
+	.cfreq = 0x21f07c1f,
+	.cphase = (0x17 << TVE_CPHASE_INITPH_BIT) | (0 << TVE_CPHASE_ACTPH_BIT) | (1 << TVE_CPHASE_CCRSTP_BIT),
+	.cbcrcfg = (59<<TVE_CBCRCFG_CBBA_BIT) | (0<<TVE_CBCRCFG_CRBA_BIT) | (137<<TVE_CBCRCFG_CBGAIN_BIT) | (137<<TVE_CBCRCFG_CRGAIN_BIT),
+	.wsscr = 0x00000070,	/* default value */
+	.wsscfg1 = 0x0,
+	.wsscfg2 = 0x0,
+	.wsscfg3 = 0x0,
+};
+
+static void jz_fb_tve_write_regs(struct jz_fb_tve_regs *tve)
+{
+	REG_TVE_CTRL 		= tve->ctrl;
+	REG_TVE_FRCFG 		= tve->frcfg;
+	REG_TVE_SLCFG1 		= tve->slcfg1;
+	REG_TVE_SLCFG2 		= tve->slcfg2;
+	REG_TVE_SLCFG3 		= tve->slcfg3;
+	REG_TVE_LTCFG1 		= tve->ltcfg1;
+	REG_TVE_LTCFG2 		= tve->ltcfg2;
+	REG_TVE_CFREQ 		= tve->cfreq;
+	REG_TVE_CPHASE 		= tve->cphase;
+	REG_TVE_CBCRCFG 	= tve->cbcrcfg;
+	REG_TVE_WSSCR 		= tve->wsscr;
+	REG_TVE_WSSCFG1 	= tve->wsscfg1;
+	REG_TVE_WSSCFG2 	= tve->wsscfg2;
+	REG_TVE_WSSCFG3 	= tve->wsscfg3;
+}
+
+static void jz_fb_tve_dac_power_on(struct jz_fb_tve_info *info)
+{
+	unsigned long v = REG_TVE_CTRL;
+
+	v &= ~(TVE_CTRL_DAPD | TVE_CTRL_DAPD1 | TVE_CTRL_DAPD2);
+
+	switch (info->output) {
+		case JZ_FB_TVE_PATH_CVBS:
+			v |= TVE_CTRL_DAPD;
+			break;
+
+		case JZ_FB_TVE_PATH_SVIDEO:
+
+#ifdef CONFIG_SOC_JZ4750D
+		case JZ_FB_TVE_PATH_YUV:
+#endif
+			v |= (TVE_CTRL_DAPD | TVE_CTRL_DAPD1 | TVE_CTRL_DAPD2);
+			break;
+
+	}
+	
+	REG_TVE_CTRL = v;
+
+	return;
+}
+
+static void jz_fb_tve_dac_power_off(struct jz_fb_tve_info *info)
+{
+	REG_TVE_CTRL &= ~(TVE_CTRL_DAPD | TVE_CTRL_DAPD1 | TVE_CTRL_DAPD2);
+
+	return;
+}
+
+static void jz_fb_tve_load_standard(struct jz_fb_tve_info *info)
+{
+	switch (info->standard) {
+		case JZ_FB_TVE_STANDARD_PAL:
+			memcpy(&info->regs, 
+				&tve_pal_regs_config, sizeof(struct jz_fb_tve_regs));
+			break;
+
+		case JZ_FB_TVE_STANDARD_NTSC:
+			memcpy(&info->regs, 
+				&tve_ntsc_regs_config, sizeof(struct jz_fb_tve_regs));
+			break;
+	}
+
+	return;
+}
+
+static void jz_fb_tve_select_output(struct jz_fb_tve_info *info)
+{
+	switch (info->output) {
+
+#ifdef CONFIG_SOC_JZ4750D		
+		case JZ_FB_TVE_PATH_YUV:
+			info->regs.ctrl |= TVE_CTRL_EYCBCR;
+			break;
+#endif
+
+		case JZ_FB_TVE_PATH_CVBS:
+			info->regs.ctrl |= TVE_CTRL_ECVBS;
+			break;
+
+		case JZ_FB_TVE_PATH_SVIDEO:
+			break;
+	}
+	
+	return;
+}
+
+static void jz_fb_tve_start(void)
+{
+	struct jz_fb_tve_info *info = &g_tve_info;
+	
+	jz_fb_tve_load_standard(info);
+	jz_fb_tve_select_output(info);
+
+	jz_fb_tve_write_regs(&info->regs);
+
+	jz_fb_tve_dac_power_on(info);
+	REG_TVE_CTRL &= ~TVE_CTRL_SWRST;
+	
+	info->b_enable = 1;
+	
+	return;
+}
+
+static void jz_fb_tve_stop(void)
+{
+	struct jz_fb_tve_info *info = &g_tve_info;
+	
+	jz_fb_tve_dac_power_off(info);
+	REG_TVE_CTRL |= TVE_CTRL_SWRST;
+
+	info->b_enable = 0;
+
+	return;
+}
+
+static int jz_fb_tve_set_standard(int standard)
+{
+	struct jz_fb_tve_info *info = &g_tve_info;
+
+	int rv = 0;
+
+	switch (standard) {
+		case JZ_FB_TVE_STANDARD_PAL:
+		case JZ_FB_TVE_STANDARD_NTSC:
+			info->standard = standard;
+
+			break;
+		default:
+			rv = -EINVAL;
+
+			break;
+	}
+
+	return rv;
+}
+
+static int jz_fb_tve_valid_output(int output)
+{
+	int rv = 0;
+
+	switch (output) {
+		case JZ_FB_TVE_PATH_CVBS:
+		case JZ_FB_TVE_PATH_SVIDEO:
+
+#ifdef CONFIG_SOC_JZ4750D
+		case JZ_FB_TVE_PATH_YUV:
+#endif
+			break;
+		default:
+			rv = -EINVAL;
+
+			break;
+	}
+
+	return rv;
+}
+
+static int jz_fb_tve_set_output(int output)
+{
+	struct jz_fb_tve_info *info = &g_tve_info;
+
+	int rv;
+
+	rv = jz_fb_tve_valid_output(output);
+	if (rv)
+		return rv;
+
+	info->output = output;
+
+	return 0;
+}
+
diff --git a/drivers/video/jz475x/output/tve/tve-ntsc-output.c b/drivers/video/jz475x/output/tve/tve-ntsc-output.c
new file mode 100644
index 0000000..637ba32
--- /dev/null
+++ b/drivers/video/jz475x/output/tve/tve-ntsc-output.c
@@ -0,0 +1,99 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * TVE NTSC Output Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifdef CONFIG_FB_JZ475X_TVE_NTSC_OUTPUT
+
+#include "tve-common.c"
+
+static struct jz_fb_panel_info tve_ntsc_output_panel_info = {
+	.lcd_ctrl = LCD_CTRL_OFUM | LCD_CTRL_BST_16,	/* Underrun recover */ 
+	.lcd_cfg = LCD_CFG_RECOVER | LCD_CFG_TVEN 
+		| LCD_CFG_MODE_INTER_CCIR656,
+		TVE_WIDTH_NTSC, TVE_HEIGHT_NTSC, TVE_FREQ_NTSC, 0, 0, 0, 0, 0, 0,
+};
+
+/* ------------ CUSTOM: Modify these by your need. ----------- */
+struct jz_fb_win_attr_info tve_ntsc_output_win_init_config[] = {
+	[0] = {
+		.enable		= 1,
+		.x		= 0,
+		.y		= 0,
+		.w		= TVE_WIDTH_NTSC,
+		.h		= TVE_HEIGHT_NTSC,
+		.bpp		= 32,
+	},
+	[1] = {
+		.enable		= 0,
+		.x		= 0,
+		.y		= 0,
+		.w		= TVE_WIDTH_NTSC,
+		.h		= TVE_HEIGHT_NTSC,
+		.bpp		= 32,
+	},
+};
+/* ----------------------------------------------------------- */
+struct jz_fb_panel_config tve_ntsc_output_panel_config = {
+	.win_init_config = tve_ntsc_output_win_init_config,
+	.panel = &tve_ntsc_output_panel_info,
+	.use_palette = 0,
+
+/* -------------- CUSTOM: Modify these by your need. --------- */
+	.max_win_bpp = 32,
+	.background_color = 0x000000FF,
+/* ----------------------------------------------------------- */
+};
+
+#include "tve-common.c"
+
+static void tve_ntsc_output_start(struct jz_fb_ot_info *ot)
+{
+	jz_fb_tve_set_standard(JZ_FB_TVE_STANDARD_NTSC);
+
+	tve_output_start(ot);
+
+	return;
+}
+
+static struct jz_fb_ot_ops tve_ntsc_output_ops = {
+	.start = tve_ntsc_output_start,
+	.stop = tve_output_stop,
+	.control = tve_output_control,
+};
+
+static int tve_ntsc_output_init(struct jz_fb_ot_info *ot)
+{
+	ot->name = "tve-ntsc-ot";
+
+	ot->use_quick_disable = 1;
+	ot->use_tve = 1;
+	ot->use_rgb_to_yuv = 1;
+
+	ot->desc_ops = &tve_output_desc_ops;
+	ot->ops = &tve_ntsc_output_ops;
+
+	ot->config = &tve_ntsc_output_panel_config;
+	
+	return 0;
+}
+
+#endif /* CONFIG_FB_JZ475X_TVE_NTSC_OUTPUT */
diff --git a/drivers/video/jz475x/output/tve/tve-pal-output.c b/drivers/video/jz475x/output/tve/tve-pal-output.c
new file mode 100644
index 0000000..4be78db
--- /dev/null
+++ b/drivers/video/jz475x/output/tve/tve-pal-output.c
@@ -0,0 +1,98 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * TVE PAL Output Routines.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifdef CONFIG_FB_JZ475X_TVE_PAL_OUTPUT
+
+#include "tve-common.c"
+
+static struct jz_fb_panel_info tve_pal_output_panel_info = {
+	.lcd_ctrl = LCD_CTRL_OFUM | LCD_CTRL_BST_16,	/* Underrun recover */ 
+	.lcd_cfg = LCD_CFG_RECOVER
+		| LCD_CFG_TVEN | LCD_CFG_TVEPEH 
+		| LCD_CFG_MODE_INTER_CCIR656,
+		TVE_WIDTH_PAL, TVE_HEIGHT_PAL, TVE_FREQ_PAL, 0, 0, 0, 0, 0, 0,
+};
+
+/* ------------ CUSTOM: Modify these by your need. ----------- */
+struct jz_fb_win_attr_info tve_pal_output_win_init_config[] = {
+	[0] = {
+		.enable		= 1,
+		.x		= 0,
+		.y		= 0,
+		.w		= TVE_WIDTH_PAL,
+		.h		= TVE_HEIGHT_PAL,
+		.bpp		= 32,
+	},
+	[1] = {
+		.enable		= 0,
+		.x		= 0,
+		.y		= 0,
+		.w		= TVE_WIDTH_PAL,
+		.h		= TVE_HEIGHT_PAL,
+		.bpp		= 32,
+	},
+};
+/* ----------------------------------------------------------- */
+struct jz_fb_panel_config tve_pal_output_panel_config = {
+	.win_init_config = tve_pal_output_win_init_config,
+	.panel = &tve_pal_output_panel_info,
+	.use_palette = 0,
+
+/* -------------- CUSTOM: Modify these by your need. --------- */
+	.max_win_bpp = 32,
+	.background_color = 0x000000FF,
+/* ----------------------------------------------------------- */
+};
+
+static void tve_pal_output_start(struct jz_fb_ot_info *ot)
+{
+	jz_fb_tve_set_standard(JZ_FB_TVE_STANDARD_PAL);
+
+	tve_output_start(ot);
+
+	return;
+}
+
+static struct jz_fb_ot_ops tve_pal_output_ops = {
+	.start = tve_pal_output_start,
+	.stop = tve_output_stop,
+	.control = tve_output_control,
+};
+
+static int tve_pal_output_init(struct jz_fb_ot_info *ot)
+{
+	ot->name = "tve-pal-ot";
+
+	ot->use_quick_disable = 1;
+	ot->use_tve = 1;
+	ot->use_rgb_to_yuv = 1;
+
+	ot->desc_ops = &tve_output_desc_ops;
+	ot->ops = &tve_pal_output_ops;
+
+	ot->config = &tve_pal_output_panel_config;
+	
+	return 0;
+}
+
+#endif /* CONFIG_FB_JZ475X_TVE_PAL_OUTPUT */
diff --git a/drivers/video/jz475x/test/Makefile b/drivers/video/jz475x/test/Makefile
new file mode 100644
index 0000000..b17da83
--- /dev/null
+++ b/drivers/video/jz475x/test/Makefile
@@ -0,0 +1,23 @@
+CC := mipsel-linux-gcc
+DESTDIR := /home/zwang
+
+TARGET := fb_fill \
+	fb_info \
+	fb_v_colorbar \
+	fb_h_colorbar \
+	lcd_ot_ctrl \
+	tve_pal_ot_ctrl \
+	tve_ntsc_ot_ctrl
+
+.PHONY: all install clean
+
+%.o : %.c
+	$(CC) $(CFLAGS) $(CWARN) $(CDEFS) $(CINCLUDE) -c -o $@ $<
+
+all: $(TARGET)
+
+install: $(TARGET)
+	cp -av $(TARGET) $(DESTDIR)
+
+clean:
+	rm -rf $(TARGET)
diff --git a/drivers/video/jz475x/test/fb_common.c b/drivers/video/jz475x/test/fb_common.c
new file mode 100644
index 0000000..1a6b31b
--- /dev/null
+++ b/drivers/video/jz475x/test/fb_common.c
@@ -0,0 +1,88 @@
+/*
+ * Framebuffer Test Common Routines.
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <string.h>
+#include <linux/fb.h>
+
+struct fb {
+	int fd;
+	uint32_t w;
+	uint32_t h;
+	uint32_t bpp;
+	uint32_t bpp_byte;
+	uint32_t mem_size;
+	void *mem;
+};
+
+int fb_open(char *name, struct fb *fb)
+{
+	struct fb_var_screeninfo var;
+	
+	int rv;
+
+	fb->fd = open(name, O_RDWR);
+	if (fb->fd == -1) {
+		perror("open():");
+		return -1;
+	}
+	
+	rv = ioctl(fb->fd, FBIOGET_VSCREENINFO, &var);
+	if (rv) {
+		perror("ioctl");
+		close(fb->fd);
+		return -1;
+	}
+	
+	fb->w = var.xres;
+	fb->h = var.yres;
+	fb->bpp = var.bits_per_pixel;
+	fb->bpp_byte = fb->bpp / 8;
+	fb->mem_size = fb->w * fb->h * fb->bpp_byte;
+
+	fb->mem = mmap(NULL, fb->mem_size, PROT_READ | PROT_WRITE, MAP_SHARED, fb->fd, 0L);
+	if (fb->mem == (void *)-1) {
+		perror("mmap():");
+		close(fb->fd);
+		return -1;
+	}
+
+	fprintf(stderr, "%s(): w: %d h: %d bpp: %d bpp_byte: %d mem_size: 0x%lu mem: %p.\n", __func__, fb->w, fb->h, fb->bpp, fb->bpp_byte, fb->mem_size, fb->mem);
+
+	return 0;
+}
+
+int fb_close(struct fb *fb)
+{
+	close(fb->fd);
+	munmap(fb->mem, fb->mem_size);
+
+	return 0;
+}
+
diff --git a/drivers/video/jz475x/test/fb_fill.c b/drivers/video/jz475x/test/fb_fill.c
new file mode 100644
index 0000000..df88d14
--- /dev/null
+++ b/drivers/video/jz475x/test/fb_fill.c
@@ -0,0 +1,76 @@
+/*
+ * Framebuffer Fill Test.
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <string.h>
+
+#include "fb_common.c"
+
+int main(int argc, char **argv)
+{
+	struct fb fb;
+	uint32_t word;
+
+	void *mem;
+	int fd;	
+
+	char *p;
+
+	uint32_t i;
+
+	int rv;
+
+	if (argc != 3)
+		return -1;
+	
+	word = strtoul(argv[2], &p, 16);	
+	if (*p != '\0') {
+		fprintf(stderr, "Invalid value.\n");
+		exit(EXIT_FAILURE);
+	}
+	
+	rv = fb_open(argv[1], &fb);
+	if (rv) {
+		fprintf(stderr, "Failed to open framebuffer device.\n");
+		exit(EXIT_FAILURE);
+	}
+
+	fprintf(stderr, "Word: 0x%x, Bpp_byte: 0x%u.\n", word, fb.bpp_byte);
+	
+	mem = fb.mem;
+
+	for (i = 0; i < fb.mem_size; i += fb.bpp_byte) {
+		memcpy(mem, &word, fb.bpp_byte);
+		mem += fb.bpp_byte;
+	}
+	
+	fb_close(&fb);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/test/fb_h_colorbar.c b/drivers/video/jz475x/test/fb_h_colorbar.c
new file mode 100644
index 0000000..1a2da3c
--- /dev/null
+++ b/drivers/video/jz475x/test/fb_h_colorbar.c
@@ -0,0 +1,138 @@
+/*
+ * Framebuffer H Color Bar.
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ * 
+ *  Based on original LCDC Driver.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <string.h>
+
+#include "fb_common.c"
+
+static void display_h_color_bar(int *ptr, int w, int h, int bpp) {
+	int i, data = 0;
+	int wpl; //word_per_line
+	wpl = w*bpp/32;
+	if (!(bpp > 8))
+		for (i = 0;i < wpl*h;i++) {
+			switch(bpp){
+			case 1:
+				if(i%(wpl*8)==0)
+					data = ((i/(wpl*8))%2)*0xffffffff;
+					*ptr++ = data; 
+				break;
+			case 2:
+				if(i%(wpl*8)==0)
+					data = ((i/(wpl*8))%4)*0x55555555;
+					*ptr++ = data; 
+				break;
+			case 4:
+				if(i%(wpl*8)==0)
+					data = ((i/(wpl*8))%16)*0x11111111;
+				*ptr++ = data; 
+				break;
+			case 8:
+				if(i%(wpl*8)==0)
+					data = ((i/(wpl*8))%256)*0x01010101;
+				*ptr++ = data; 
+				break;
+			}
+		}
+	else {
+
+		switch(bpp) {
+		case 15:
+		case 16:
+			for (i = 0;i < wpl*h;i++) {
+				if (((i/(wpl*8)) % 8) == 0)
+					*ptr++ = 0xffffffff;
+				else if (((i/(wpl*8)) % 8) == 1)
+					*ptr++ = 0xf800f800;
+				else if (((i/(wpl*8)) % 8) == 2)
+					*ptr++ = 0xffe0ffe0;
+				else if (((i/(wpl*8)) % 8) == 3)
+					*ptr++ = 0x07e007e0;
+				else if (((i/(wpl*8)) % 8) == 4)
+					*ptr++ = 0x07ff07ff;
+				else if (((i/(wpl*8)) % 8) == 5)
+					*ptr++ = 0x001f001f;
+				else if (((i/(wpl*8)) % 8) == 6)
+					*ptr++ = 0xf81ff81f;
+				else if (((i/(wpl*8)) % 8) == 7)
+					*ptr++ = 0x00000000;
+			}
+				break;
+		case 18:
+		case 24:
+		case 32:
+		default:
+			for (i = 0;i < wpl*h;i++) {
+				if (((i/(wpl*8)) % 8) == 7)
+					*ptr++ = 0xffffff;
+				else if (((i/(wpl*8)) % 8) == 2)
+					*ptr++ = 0xff0000;
+				else if (((i/(wpl*8)) % 8) == 4)
+					*ptr++ = 0xffff00;
+				else if (((i/(wpl*8)) % 8) == 6)
+					*ptr++ = 0x00ff00;
+				else if (((i/(wpl*8)) % 8) == 1)
+					*ptr++ = 0x00ffff;
+				else if (((i/(wpl*8)) % 8) == 3)
+					*ptr++ = 0x0000ff;
+				else if (((i/(wpl*8)) % 8) == 5)
+					*ptr++ = 0x000000;
+				else if (((i/(wpl*8)) % 8) == 0)
+					*ptr++ = 0xff00ff;
+			}
+			break;
+		}
+
+	}
+
+}
+
+int main(int argc, char **argv)
+{
+	struct fb fb;
+
+	int rv;
+
+	if (argc != 2)
+		return -1;
+	
+	rv = fb_open(argv[1], &fb);
+	if (rv) {
+		exit(EXIT_FAILURE);
+	}
+
+	display_h_color_bar(fb.mem, fb.w, fb.h, fb.bpp);
+	
+	fb_close(&fb);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/test/fb_info.c b/drivers/video/jz475x/test/fb_info.c
new file mode 100644
index 0000000..4b4c5ec
--- /dev/null
+++ b/drivers/video/jz475x/test/fb_info.c
@@ -0,0 +1,126 @@
+/*
+ * Dump Framebuffer Info.
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ * 
+ *  Based on original LCDC Driver.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <linux/fb.h>
+
+#define DUMP(fmt, args...) \
+	fprintf(stderr, fmt"\n", ##args)
+
+/* ------------ Framebuffer ----------------- */
+static void dump_fb_info_var(struct fb_var_screeninfo *var)
+{
+	DUMP("Framebuffer VAR Info: ");
+	DUMP("=============================================");
+
+	DUMP("var->xres: 0x%08lx.",var->xres);
+	DUMP("var->yres: 0x%08lx.",var->yres);
+	DUMP("var->xres_virtual: 0x%08lx.",var->xres_virtual);
+	DUMP("var->yres_virtual: 0x%08lx.",var->yres_virtual);
+	DUMP("var->xoffset: 0x%08lx.",var->xoffset);
+	DUMP("var->yoffset: 0x%08lx.",var->yoffset);
+	DUMP("var->bits_per_pixel: 0x%08lx.",var->bits_per_pixel);
+	DUMP("var->grayscale: 0x%08lx.",var->grayscale);
+	DUMP("var->nonstd: 0x%08lx.",var->nonstd);
+	DUMP("var->activate: 0x%08lx.",var->activate);
+	DUMP("var->height: 0x%08lx.",var->height);
+	DUMP("var->width: 0x%08lx.",var->width);
+	DUMP("var->accel_flags: 0x%08lx.",var->accel_flags);
+	DUMP("var->pixclock: 0x%08lx.",var->pixclock);
+	DUMP("var->left_margin: 0x%08lx.",var->left_margin);
+	DUMP("var->right_margin: 0x%08lx.",var->right_margin);
+	DUMP("var->upper_margin: 0x%08lx.",var->upper_margin);
+	DUMP("var->lower_margin: 0x%08lx.",var->lower_margin);
+	DUMP("var->hsync_len: 0x%08lx.",var->hsync_len);
+	DUMP("var->vsync_len: 0x%08lx.",var->vsync_len);
+	DUMP("var->sync: 0x%08lx.",var->sync);
+	DUMP("var->vmode: 0x%08lx.",var->vmode);
+	DUMP("var->rotate: 0x%08lx.",var->rotate);
+
+	return;
+}
+
+static void dump_fb_info_fix(struct fb_fix_screeninfo *fix)
+{
+	DUMP("Framebuffer FIX Info: ");
+	DUMP("=============================================");
+
+	DUMP("fix->id: %s.",fix->id);
+
+	DUMP("fix->smem_start: 0x%08lx.",fix->smem_start);
+	DUMP("fix->smem_len: 0x%08lx.",fix->smem_len);
+	DUMP("fix->type: 0x%08lx.",fix->type);
+	DUMP("fix->type_aux: 0x%08lx.",fix->type_aux);
+	DUMP("fix->visual: 0x%08lx.",fix->visual);
+	DUMP("fix->xpanstep: 0x%08lx.",fix->xpanstep);
+	DUMP("fix->ypanstep: 0x%08lx.",fix->ypanstep);
+	DUMP("fix->ywrapstep: 0x%08lx.",fix->ywrapstep);
+	DUMP("fix->line_length: 0x%08lx.",fix->line_length);
+	DUMP("fix->mmio_start: 0x%08lx.",fix->mmio_start);
+	DUMP("fix->mmio_len: 0x%08lx.",fix->mmio_len);
+	DUMP("fix->accel: 0x%08lx.",fix->accel);
+
+	return;
+}
+
+int main(int argc, char **argv)
+{
+	struct fb_var_screeninfo var;
+	struct fb_fix_screeninfo fix;
+	
+	int fd;	
+
+	int rv;
+
+	if (argc != 2)
+		return -1;
+
+	fd = open(argv[1], O_RDWR);
+	if (fd == -1) {
+		perror("open():");
+		exit(EXIT_FAILURE);
+	}
+	
+	rv = ioctl(fd, FBIOGET_VSCREENINFO, &var);
+	if (rv) {
+		perror("ioctl():");
+		exit(EXIT_FAILURE);
+	}
+
+	rv = ioctl(fd, FBIOGET_FSCREENINFO, &fix);
+	if (rv) {
+		perror("ioctl():");
+		exit(EXIT_FAILURE);
+	}	
+
+	dump_fb_info_var(&var);
+	dump_fb_info_fix(&fix);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/test/fb_v_colorbar.c b/drivers/video/jz475x/test/fb_v_colorbar.c
new file mode 100644
index 0000000..8e7ab73
--- /dev/null
+++ b/drivers/video/jz475x/test/fb_v_colorbar.c
@@ -0,0 +1,163 @@
+/*
+ * Framebuffer V Color Bar.
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ * 
+ *  Based on original LCDC Driver.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <string.h>
+
+#include "fb_common.c"
+
+static void display_v_color_bar(int *ptr, int w, int h, int bpp) {
+	int i, j, wpl, data = 0;
+	wpl = w*bpp/32;
+	if (!(bpp > 8))
+		switch(bpp){
+		case 1:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					*ptr++ = 0x00ff00ff;
+				}
+			break;
+		case 2:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					data = (i%4)*0x55555555;
+					*ptr++ = data;
+				}
+			break;
+		case 4:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					data = (i%16)*0x11111111;
+					*ptr++ = data;
+				}
+			break;
+		case 8:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i+=2) {
+					data = (i%(256))*0x01010101;
+					*ptr++ = data;
+					*ptr++ = data;
+				}
+			break;
+		}
+	else {
+		switch(bpp) {
+		case 16:
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					if((i/4)%8==0)
+						*ptr++ = 0xffffffff;
+					else if ((i/4)%8==1)
+						*ptr++ = 0xf800f800;
+					else if ((i/4)%8==2)
+						*ptr++ = 0xffe0ffe0;
+					else if ((i/4)%8==3)
+						*ptr++ = 0x07e007e0;
+					else if ((i/4)%8==4)
+						*ptr++ = 0x07ff07ff;
+					else if ((i/4)%8==5)
+						*ptr++ = 0x001f001f;
+					else if ((i/4)%8==6)
+						*ptr++ = 0xf81ff81f;
+					else if ((i/4)%8==7)
+						*ptr++ = 0x00000000;
+				}
+			break;
+		case 18:
+		case 24:
+		case 32:
+		default:
+#if 1
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					if((i/8)%8==7) 
+						*ptr++ = 0xffffff;
+					else if ((i/8)%8==1)
+						*ptr++ = 0xff0000;
+					else if ((i/8)%8==2)
+						*ptr++ = 0xffff00;
+					else if ((i/8)%8==3)
+						*ptr++ = 0x00ff00;
+					else if ((i/8)%8==4)
+						*ptr++ = 0x00ffff;
+					else if ((i/8)%8==5)
+						*ptr++ = 0x0000ff;
+					else if ((i/8)%8==6)
+						*ptr++ = 0xff00ff;
+					else if ((i/8)%8==0)
+						*ptr++ = 0x000000;
+				}
+#else
+			for (j = 0;j < h; j++)
+				for (i = 0;i < wpl; i++) {
+					if((i/8)%8==7) 
+						*ptr++ = 0x00ff0000;
+					else if ((i/8)%8==1)
+						*ptr++ = 0xffff0000;
+					else if ((i/8)%8==2)
+						*ptr++ = 0x20ff0000;
+					else if ((i/8)%8==3)
+						*ptr++ = 0x40ff0000;
+					else if ((i/8)%8==4)
+						*ptr++ = 0x60ff0000;
+					else if ((i/8)%8==5)
+						*ptr++ = 0x80ff0000;
+					else if ((i/8)%8==6)
+						*ptr++ = 0xa0ff0000;
+					else if ((i/8)%8==0)
+						*ptr++ = 0xc0ff0000;
+				}
+#endif
+			break;
+		}
+	}
+}
+
+int main(int argc, char **argv)
+{
+	struct fb fb;
+
+	int rv;
+
+	if (argc != 2)
+		return -1;
+	
+	rv = fb_open(argv[1], &fb);
+	if (rv) {
+		exit(EXIT_FAILURE);
+	}
+
+	display_v_color_bar(fb.mem, fb.w, fb.h, fb.bpp);
+	
+	fb_close(&fb);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/test/lcd_ot_ctrl.c b/drivers/video/jz475x/test/lcd_ot_ctrl.c
new file mode 100644
index 0000000..97d31ba
--- /dev/null
+++ b/drivers/video/jz475x/test/lcd_ot_ctrl.c
@@ -0,0 +1,167 @@
+/*
+ * LCD Output Path Control.
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ * 
+ *  Based on original LCDC Driver.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <string.h>
+
+#include "../abi.h"
+
+int main(int argc, char **argv)
+{
+	struct jz_fb_lcd_control control;
+	struct jz_fb_common_control *c = &control.common;
+
+	int fd;	
+	int rv;
+
+	if (argc < 2)
+		return -1;
+
+	fd = open("/dev/lcd-ot-ctrl", O_RDWR);
+	if (fd == -1) {
+		perror("open():");
+		exit(EXIT_FAILURE);
+	}
+	
+	c->id = 0;
+	
+	if (!strcmp(argv[1], "power")) {
+		if (argc < 3)
+			return -1;
+
+		c->command = JZ_FB_CMD_COMMON_SET_POWER;
+		c->v = strcmp(argv[2], "off");
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+	}else if (!strcmp(argv[1], "screen")) {
+		if (argc < 3)
+			return -1;
+
+		c->command = JZ_FB_CMD_COMMON_SET_SCREEN;
+		c->v = strcmp(argv[2], "off");
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+	}else if (!strcmp(argv[1], "get_attr")) {
+		c->command = JZ_FB_CMD_COMMON_GET_WIN_ATTR;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+		fprintf(stderr, "Current Win ATTR:\n");
+		fprintf(stderr, "WIN 0: enable: %d, x: %d, y: %d, w: %d, h: %d, bpp: %d.\n",
+				c->win_attr[0].enable,
+				c->win_attr[0].x,
+				c->win_attr[0].y,
+				c->win_attr[0].w,
+				c->win_attr[0].h,
+				c->win_attr[0].bpp);
+
+		fprintf(stderr, "WIN 1: enable: %d, x: %d, y: %d, w: %d, h: %d, bpp: %d.\n",
+				c->win_attr[1].enable,
+				c->win_attr[1].x,
+				c->win_attr[1].y,
+				c->win_attr[1].w,
+				c->win_attr[1].h,
+				c->win_attr[1].bpp);
+
+		return 0;
+
+	}else if (!strcmp(argv[1], "set_attr")) {
+		/*    1         2           3     4   5   6   7   8      9      */
+		/* set_attr [win index] [enable] [x] [y] [w] [h] [bpp] [active] */
+
+		unsigned int index = atoi(argv[2]);
+		unsigned int enable = atoi(argv[3]);
+		unsigned int x = atoi(argv[4]);
+		unsigned int y = atoi(argv[5]);
+		unsigned int w = atoi(argv[6]);
+		unsigned int h = atoi(argv[7]);
+		unsigned int bpp = atoi(argv[8]);
+		unsigned int active = atoi(argv[9]);
+
+		if (argc < 9 || index > JZ_FB_NR_MAX_FG)
+			return -1;
+		
+		/* Get current win attr. */
+		c->command = JZ_FB_CMD_COMMON_GET_WIN_ATTR;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+		c->command = JZ_FB_CMD_COMMON_SET_WIN_ATTR;
+		
+		c->active_now = active;
+
+		c->win_attr[index].enable = enable;	
+		c->win_attr[index].x = x;	
+		c->win_attr[index].y = y;	
+		c->win_attr[index].w = w;	
+		c->win_attr[index].h = h;	
+		c->win_attr[index].bpp = bpp;
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+		
+		return 0;	
+	}else if (!strcmp(argv[1], "select")) {
+		c->command = JZ_FB_CMD_COMMON_SELECT_OT;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+		
+	}
+
+	close(fd);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/test/tve_ntsc_ot_ctrl.c b/drivers/video/jz475x/test/tve_ntsc_ot_ctrl.c
new file mode 100644
index 0000000..b969bf5
--- /dev/null
+++ b/drivers/video/jz475x/test/tve_ntsc_ot_ctrl.c
@@ -0,0 +1,189 @@
+/*
+ * LCD Output Path Control.
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ * 
+ *  Based on original LCDC Driver.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <string.h>
+
+#include "../abi.h"
+
+#define TVE_NTSC_PATH "/dev/tve-ntsc-ot-ctrl"
+#define TVE_NTSC_ID	2
+
+int main(int argc, char **argv)
+{
+	struct jz_fb_lcd_control control;
+	struct jz_fb_common_control *c = &control.common;
+
+	int fd;	
+	int rv;
+
+	if (argc < 2)
+		return -1;
+
+	fd = open(TVE_NTSC_PATH, O_RDWR);
+	if (fd == -1) {
+		perror("open():");
+		exit(EXIT_FAILURE);
+	}
+	
+	c->id = TVE_NTSC_ID;
+	
+	if (!strcmp(argv[1], "power")) {
+		if (argc < 3)
+			return -1;
+
+		c->command = JZ_FB_CMD_COMMON_SET_POWER;
+		c->v = strcmp(argv[2], "off");
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+	}else if (!strcmp(argv[1], "get_attr")) {
+		c->command = JZ_FB_CMD_COMMON_GET_WIN_ATTR;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+		fprintf(stderr, "Current Win ATTR:\n");
+		fprintf(stderr, "WIN 0: enable: %d, x: %d, y: %d, w: %d, h: %d, bpp: %d.\n",
+				c->win_attr[0].enable,
+				c->win_attr[0].x,
+				c->win_attr[0].y,
+				c->win_attr[0].w,
+				c->win_attr[0].h,
+				c->win_attr[0].bpp);
+
+		fprintf(stderr, "WIN 1: enable: %d, x: %d, y: %d, w: %d, h: %d, bpp: %d.\n",
+				c->win_attr[1].enable,
+				c->win_attr[1].x,
+				c->win_attr[1].y,
+				c->win_attr[1].w,
+				c->win_attr[1].h,
+				c->win_attr[1].bpp);
+
+		return 0;
+
+	}else if (!strcmp(argv[1], "set_attr")) {
+		/*    1         2           3     4   5   6   7   8      9      */
+		/* set_attr [win index] [enable] [x] [y] [w] [h] [bpp] [active] */
+
+		unsigned int index = atoi(argv[2]);
+		unsigned int enable = atoi(argv[3]);
+		unsigned int x = atoi(argv[4]);
+		unsigned int y = atoi(argv[5]);
+		unsigned int w = atoi(argv[6]);
+		unsigned int h = atoi(argv[7]);
+		unsigned int bpp = atoi(argv[8]);
+		unsigned int active = atoi(argv[9]);
+
+		if (argc < 9 || index > JZ_FB_NR_MAX_FG)
+			return -1;
+		
+		/* Get current win attr. */
+		c->command = JZ_FB_CMD_COMMON_GET_WIN_ATTR;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+		c->command = JZ_FB_CMD_COMMON_SET_WIN_ATTR;
+		
+		c->active_now = active;
+
+		c->win_attr[index].enable = enable;	
+		c->win_attr[index].x = x;	
+		c->win_attr[index].y = y;	
+		c->win_attr[index].w = w;	
+		c->win_attr[index].h = h;	
+		c->win_attr[index].bpp = bpp;
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+		
+		return 0;	
+
+	}else if (!strcmp(argv[1], "select")) {
+		c->command = JZ_FB_CMD_COMMON_SELECT_OT;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+		return 0;
+
+	}else if (!strcmp(argv[1], "get_path")) {
+		if (argc < 2)
+			return -1;
+		
+		c->command = JZ_FB_CMD_TVE_GET_PATH;
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}	
+	
+		fprintf(stderr, "Current TVE Path: %d.\n", c->v);
+
+		return 0;
+
+	}else if (!strcmp(argv[1], "set_path")) {
+		if (argc < 3)
+			return -1;
+		
+		c->command = JZ_FB_CMD_TVE_SET_PATH;
+		c->v = atoi(argv[2]);
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}	
+		
+		return 0;
+	}
+
+	close(fd);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/test/tve_pal_ot_ctrl.c b/drivers/video/jz475x/test/tve_pal_ot_ctrl.c
new file mode 100644
index 0000000..f0b3aea
--- /dev/null
+++ b/drivers/video/jz475x/test/tve_pal_ot_ctrl.c
@@ -0,0 +1,189 @@
+/*
+ * LCD Output Path Control.
+ *  
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ * 
+ *  Based on original LCDC Driver.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <string.h>
+
+#include "../abi.h"
+
+#define TVE_PAL_PATH "/dev/tve-pal-ot-ctrl"
+#define TVE_PAL_ID 1
+
+int main(int argc, char **argv)
+{
+	struct jz_fb_lcd_control control;
+	struct jz_fb_common_control *c = &control.common;
+
+	int fd;	
+	int rv;
+
+	if (argc < 2)
+		return -1;
+
+	fd = open(TVE_PAL_PATH, O_RDWR);
+	if (fd == -1) {
+		perror("open():");
+		exit(EXIT_FAILURE);
+	}
+	
+	c->id = TVE_PAL_ID;
+	
+	if (!strcmp(argv[1], "power")) {
+		if (argc < 3)
+			return -1;
+
+		c->command = JZ_FB_CMD_COMMON_SET_POWER;
+		c->v = strcmp(argv[2], "off");
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+	}else if (!strcmp(argv[1], "get_attr")) {
+		c->command = JZ_FB_CMD_COMMON_GET_WIN_ATTR;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+		fprintf(stderr, "Current Win ATTR:\n");
+		fprintf(stderr, "WIN 0: enable: %d, x: %d, y: %d, w: %d, h: %d, bpp: %d.\n",
+				c->win_attr[0].enable,
+				c->win_attr[0].x,
+				c->win_attr[0].y,
+				c->win_attr[0].w,
+				c->win_attr[0].h,
+				c->win_attr[0].bpp);
+
+		fprintf(stderr, "WIN 1: enable: %d, x: %d, y: %d, w: %d, h: %d, bpp: %d.\n",
+				c->win_attr[1].enable,
+				c->win_attr[1].x,
+				c->win_attr[1].y,
+				c->win_attr[1].w,
+				c->win_attr[1].h,
+				c->win_attr[1].bpp);
+
+		return 0;
+
+	}else if (!strcmp(argv[1], "set_attr")) {
+		/*    1         2           3     4   5   6   7   8      9      */
+		/* set_attr [win index] [enable] [x] [y] [w] [h] [bpp] [active] */
+
+		unsigned int index = atoi(argv[2]);
+		unsigned int enable = atoi(argv[3]);
+		unsigned int x = atoi(argv[4]);
+		unsigned int y = atoi(argv[5]);
+		unsigned int w = atoi(argv[6]);
+		unsigned int h = atoi(argv[7]);
+		unsigned int bpp = atoi(argv[8]);
+		unsigned int active = atoi(argv[9]);
+
+		if (argc < 9 || index > JZ_FB_NR_MAX_FG)
+			return -1;
+		
+		/* Get current win attr. */
+		c->command = JZ_FB_CMD_COMMON_GET_WIN_ATTR;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+		c->command = JZ_FB_CMD_COMMON_SET_WIN_ATTR;
+		
+		c->active_now = active;
+
+		c->win_attr[index].enable = enable;	
+		c->win_attr[index].x = x;	
+		c->win_attr[index].y = y;	
+		c->win_attr[index].w = w;	
+		c->win_attr[index].h = h;	
+		c->win_attr[index].bpp = bpp;
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+		
+		return 0;	
+
+	}else if (!strcmp(argv[1], "select")) {
+		c->command = JZ_FB_CMD_COMMON_SELECT_OT;
+		
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}		
+
+		return 0;
+
+	}else if (!strcmp(argv[1], "get_path")) {
+		if (argc < 2)
+			return -1;
+		
+		c->command = JZ_FB_CMD_TVE_GET_PATH;
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}	
+	
+		fprintf(stderr, "Current TVE Path: %d.\n", c->v);
+
+		return 0;
+
+	}else if (!strcmp(argv[1], "set_path")) {
+		if (argc < 3)
+			return -1;
+		
+		c->command = JZ_FB_CMD_TVE_SET_PATH;
+		c->v = atoi(argv[2]);
+
+		rv = ioctl(fd, 0, &control);
+		if (rv) {
+			perror("ioctl");
+			return -1;
+		}	
+		
+		return 0;
+	}
+
+	close(fd);
+
+	return 0;
+}
diff --git a/drivers/video/jz475x/userspace-config.h b/drivers/video/jz475x/userspace-config.h
new file mode 100644
index 0000000..b95d4f2
--- /dev/null
+++ b/drivers/video/jz475x/userspace-config.h
@@ -0,0 +1,22 @@
+/*
+ * Ingenic JZ475X Display Controllers Driver.
+ * 
+ * Copyright (C) 2005-2010 Ingenic Semiconductor Inc.
+ * Author: River Wang <zwang@ingenic.cn>
+ *		
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#define CONFIG_SOC_JZ4750 1
diff --git a/fs/mpage.c b/fs/mpage.c
index fd56ca2..c79acba 100644
--- a/fs/mpage.c
+++ b/fs/mpage.c
@@ -53,6 +53,17 @@ static void mpage_end_io_read(struct bio *bio, int err)
 
 		if (uptodate) {
 			SetPageUptodate(page);
+			/*
+			 * It seems that there is a IO coherent bug in generic_file_mmap(),
+			 * When __do_fault() calls vma->ops->falut(filemap_fault)->aops->readpage(),
+			 * the PG_dcache_dirty is not set, so the page should be flushed (often with EXEC flags)
+			 * will not be flushed in the update_mmu_cache().
+			 *
+			 * This causes some larger ELF files failing to execute with errors like illegal instruction...
+			 *
+			 * - River.
+			 */
+			flush_dcache_page(page);
 		} else {
 			ClearPageUptodate(page);
 			SetPageError(page);
diff --git a/include/linux/vt.h b/include/linux/vt.h
index d5dd0bc..1074a61 100644
--- a/include/linux/vt.h
+++ b/include/linux/vt.h
@@ -7,10 +7,16 @@
  * resizing).
  */
 #define MIN_NR_CONSOLES 1       /* must be at least 1 */
+
+#if defined(CONFIG_JZSOC)
+#define MAX_NR_CONSOLES	2
+#define MAX_NR_USER_CONSOLES 2
+#else
 #define MAX_NR_CONSOLES	63	/* serial lines start at 64 */
 #define MAX_NR_USER_CONSOLES 63	/* must be root to allocate above this */
 		/* Note: the ioctl VT_GETSTATE does not work for
 		   consoles 16 and higher (since it returns a short) */
+#endif
 
 /* 0x56 is 'V', to avoid collision with termios and kd */
 
diff --git a/init/do_mounts.c b/init/do_mounts.c
index 02e3ca4..34c3aa4 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -387,7 +387,8 @@ void __init prepare_namespace(void)
 	if (saved_root_name[0]) {
 		root_device_name = saved_root_name;
 		if (!strncmp(root_device_name, "mtd", 3) ||
-		    !strncmp(root_device_name, "ubi", 3)) {
+		    !strncmp(root_device_name, "ubi", 3) ||
+		    !strncmp(root_device_name, "mmc", 3)) {
 			mount_block_root(root_device_name, root_mountflags);
 			goto out;
 		}
-- 
1.7.9.1

